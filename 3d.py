# -*- coding: utf-8 -*-
"""3d.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1wx7GDCIXuYZRTOqw_w6Xa9LDNwl6wB-h
"""

import numpy as np
import os
import matplotlib.pyplot as plt

# --- 3D dynamic lattice parameters ---
N = 64             # Grid size
STEPS = 500        # Time steps
DT = 0.05

# Dwarf analog
NP_dwarf = 1000
v_th_dwarf = 0.1

# Massive analog
NP_massive = 5000
v_th_massive = 0.05

# Lattice parameters
s_src = 2.5
lam = 0.01
D_C = 0.05
mu = 1.0
r_rep = 2

OUT_DIR = "simulation_output_3d"
os.makedirs(OUT_DIR, exist_ok=True)

# --- Helper functions ---
def laplacian(F):
    return (np.roll(F,1,0)+np.roll(F,-1,0)+
            np.roll(F,1,1)+np.roll(F,-1,1)+
            np.roll(F,1,2)+np.roll(F,-1,2)-6*F)

def cic_deposit(xp, yp, zp):
    rho = np.zeros((N,N,N))
    i0 = np.floor(xp).astype(int) % N
    j0 = np.floor(yp).astype(int) % N
    k0 = np.floor(zp).astype(int) % N
    i1, j1, k1 = (i0+1)%N, (j0+1)%N, (k0+1)%N
    tx, ty, tz = xp - np.floor(xp), yp - np.floor(yp), zp - np.floor(zp)
    w000 = (1-tx)*(1-ty)*(1-tz)
    w100 = tx*(1-ty)*(1-tz)
    w010 = (1-tx)*ty*(1-tz)
    w001 = (1-tx)*(1-ty)*tz
    w101 = tx*(1-ty)*tz
    w011 = (1-tx)*ty*tz
    w110 = tx*ty*(1-tz)
    w111 = tx*ty*tz
    np.add.at(rho, (i0,j0,k0), w000)
    np.add.at(rho, (i1,j0,k0), w100)
    np.add.at(rho, (i0,j1,k0), w010)
    np.add.at(rho, (i0,j0,k1), w001)
    np.add.at(rho, (i1,j0,k1), w101)
    np.add.at(rho, (i0,j1,k1), w011)
    np.add.at(rho, (i1,j1,k0), w110)
    np.add.at(rho, (i1,j1,k1), w111)
    return rho

def grad_xyz(F):
    Fx = (np.roll(F,-1,0)-np.roll(F,1,0))/2
    Fy = (np.roll(F,-1,1)-np.roll(F,1,1))/2
    Fz = (np.roll(F,-1,2)-np.roll(F,1,2))/2
    return Fx, Fy, Fz

def trilinear_sample(F, xp, yp, zp):
    i0 = np.floor(xp).astype(int) % N
    j0 = np.floor(yp).astype(int) % N
    k0 = np.floor(zp).astype(int) % N
    i1, j1, k1 = (i0+1)%N, (j0+1)%N, (k0+1)%N
    tx, ty, tz = xp - np.floor(xp), yp - np.floor(yp), zp - np.floor(zp)
    f000 = F[i0,j0,k0]; f100 = F[i1,j0,k0]; f010 = F[i0,j1,k0]; f001 = F[i0,j0,k1]
    f101 = F[i1,j0,k1]; f011 = F[i0,j1,k1]; f110 = F[i1,j1,k0]; f111 = F[i1,j1,k1]
    c00 = f000*(1-tx)+f100*tx
    c01 = f001*(1-tx)+f101*tx
    c10 = f010*(1-tx)+f110*tx
    c11 = f011*(1-tx)+f111*tx
    c0 = c00*(1-ty)+c10*ty
    c1 = c01*(1-ty)+c11*ty
    return c0*(1-tz)+c1*tz

# --- Simulation runner for a single Krep ---
def run_simulation_3d(NP_val, Krep, v_th, seed=12345):
    rng = np.random.default_rng(seed)
    xp = rng.normal(N/2,10,size=NP_val)%N
    yp = rng.normal(N/2,10,size=NP_val)%N
    zp = rng.normal(N/2,10,size=NP_val)%N
    vx = np.zeros(NP_val); vy = np.zeros(NP_val); vz = np.zeros(NP_val)
    C = np.zeros((N,N,N))
    max_C_history = []

    for step in range(1,STEPS+1):
        rho = cic_deposit(xp, yp, zp)
        C += DT*(s_src*rho - lam*C + D_C*laplacian(C))
        Cx, Cy, Cz = grad_xyz(C)
        ax = mu * trilinear_sample(Cx, xp, yp, zp)
        ay = mu * trilinear_sample(Cy, xp, yp, zp)
        az = mu * trilinear_sample(Cz, xp, yp, zp)
        # Simple isotropic repulsion
        dx = (xp[:,None]-xp[None,:]+N/2)%N-N/2
        dy = (yp[:,None]-yp[None,:]+N/2)%N-N/2
        dz = (zp[:,None]-zp[None,:]+N/2)%N-N/2
        dist2 = dx**2+dy**2+dz**2
        mask = (dist2>0) & (dist2<=r_rep**2)
        ax += Krep*np.sum(dx*mask/dist2.clip(min=1e-12),axis=1)
        ay += Krep*np.sum(dy*mask/dist2.clip(min=1e-12),axis=1)
        az += Krep*np.sum(dz*mask/dist2.clip(min=1e-12),axis=1)
        # Thermal noise
        ax += rng.normal(0,v_th,NP_val); ay += rng.normal(0,v_th,NP_val); az += rng.normal(0,v_th,NP_val)
        vx += DT*ax; vy += DT*ay; vz += DT*az
        xp = (xp + vx*DT)%N; yp = (yp + vy*DT)%N; zp = (zp + vz*DT)%N
        max_C_history.append(C[N//2,N//2,N//2])
    return np.max(max_C_history)  # Return max central curvature for this Krep

# --- Krep sweep ---
Krep_values = np.linspace(0.01, 2.0, 20)

maxC_dwarf = []
maxC_massive = []

print("Running 3D dwarf Krep sweep...")
for k in Krep_values:
    print(f"Krep={k:.2f}")
    maxC_dwarf.append(run_simulation_3d(NP_dwarf, k, v_th_dwarf))

print("Running 3D massive Krep sweep...")
for k in Krep_values:
    print(f"Krep={k:.2f}")
    maxC_massive.append(run_simulation_3d(NP_massive, k, v_th_massive))

# --- Plotting ---
plt.figure(figsize=(10,6))
plt.plot(Krep_values, maxC_dwarf, marker='o', linestyle='-', color='blue', label='Dwarf Analog')
plt.plot(Krep_values, maxC_massive, marker='s', linestyle='-', color='red', label='Massive Analog')
plt.xlabel("Krep (Repulsion Strength)")
plt.ylabel("Max Central Curvature")
plt.title("3D Dynamic Lattice: Max Central Curvature vs Krep")
plt.axhline(0.2, color='green', linestyle='--', label='Stability threshold')
plt.legend()
plt.grid(True)
plt.savefig(os.path.join(OUT_DIR,"Krep_sweep_3d.png"))
plt.show()
print(f"Krep sweep plot saved to '{OUT_DIR}/Krep_sweep_3d.png'")

import numpy as np
import os
import matplotlib.pyplot as plt

# =============================================================================
# Fast 3D Dynamic Lattice Simulation (Krep sweep)
# =============================================================================

# --- Parameters ---
N = 32              # Grid size
STEPS = 150         # Time steps
DT = 0.05

# Particle counts
NP_dwarf = 200
NP_massive = 500
v_th_dwarf = 0.1
v_th_massive = 0.05

# Lattice parameters
s_src = 2.5
lam = 0.01
D_C = 0.05
mu = 1.0
r_rep = 2

OUT_DIR = "simulation_output_3d_fast"
os.makedirs(OUT_DIR, exist_ok=True)

# --- Helper functions ---
def laplacian(F):
    return (np.roll(F,1,0)+np.roll(F,-1,0)+
            np.roll(F,1,1)+np.roll(F,-1,1)+
            np.roll(F,1,2)+np.roll(F,-1,2)-6*F)

def cic_deposit(xp, yp, zp):
    rho = np.zeros((N,N,N))
    i0 = np.floor(xp).astype(int)%N
    j0 = np.floor(yp).astype(int)%N
    k0 = np.floor(zp).astype(int)%N
    i1,j1,k1 = (i0+1)%N,(j0+1)%N,(k0+1)%N
    tx, ty, tz = xp-np.floor(xp), yp-np.floor(yp), zp-np.floor(zp)
    w000 = (1-tx)*(1-ty)*(1-tz)
    w100 = tx*(1-ty)*(1-tz)
    w010 = (1-tx)*ty*(1-tz)
    w001 = (1-tx)*(1-ty)*tz
    w101 = tx*(1-ty)*tz
    w011 = (1-tx)*ty*tz
    w110 = tx*ty*(1-tz)
    w111 = tx*ty*tz
    np.add.at(rho,(i0,j0,k0),w000)
    np.add.at(rho,(i1,j0,k0),w100)
    np.add.at(rho,(i0,j1,k0),w010)
    np.add.at(rho,(i0,j0,k1),w001)
    np.add.at(rho,(i1,j0,k1),w101)
    np.add.at(rho,(i0,j1,k1),w011)
    np.add.at(rho,(i1,j1,k0),w110)
    np.add.at(rho,(i1,j1,k1),w111)
    return rho

def grad_xyz(F):
    Fx = (np.roll(F,-1,0)-np.roll(F,1,0))/2
    Fy = (np.roll(F,-1,1)-np.roll(F,1,1))/2
    Fz = (np.roll(F,-1,2)-np.roll(F,1,2))/2
    return Fx, Fy, Fz

def trilinear_sample(F,xp,yp,zp):
    i0 = np.floor(xp).astype(int)%N
    j0 = np.floor(yp).astype(int)%N
    k0 = np.floor(zp).astype(int)%N
    i1,j1,k1 = (i0+1)%N,(j0+1)%N,(k0+1)%N
    tx, ty, tz = xp-np.floor(xp), yp-np.floor(yp), zp-np.floor(zp)
    f000 = F[i0,j0,k0]; f100 = F[i1,j0,k0]; f010 = F[i0,j1,k0]; f001 = F[i0,j0,k1]
    f101 = F[i1,j0,k1]; f011 = F[i0,j1,k1]; f110 = F[i1,j1,k0]; f111 = F[i1,j1,k1]
    c00 = f000*(1-tx)+f100*tx; c01 = f001*(1-tx)+f101*tx
    c10 = f010*(1-tx)+f110*tx; c11 = f011*(1-tx)+f111*tx
    c0 = c00*(1-ty)+c10*ty; c1 = c01*(1-ty)+c11*ty
    return c0*(1-tz)+c1*tz

# --- Simulation runner ---
def run_sim(NP_val,Krep,v_th,seed=12345):
    rng = np.random.default_rng(seed)
    xp = rng.normal(N/2,5,NP_val)%N
    yp = rng.normal(N/2,5,NP_val)%N
    zp = rng.normal(N/2,5,NP_val)%N
    vx = vy = vz = np.zeros(NP_val)
    C = np.zeros((N,N,N))
    max_C_history = []

    for step in range(STEPS):
        rho = cic_deposit(xp,yp,zp)
        C += DT*(s_src*rho-lam*C+D_C*laplacian(C))
        Cx,Cy,Cz = grad_xyz(C)
        ax = mu*trilinear_sample(Cx,xp,yp,zp)
        ay = mu*trilinear_sample(Cy,xp,yp,zp)
        az = mu*trilinear_sample(Cz,xp,yp,zp)
        # Simple repulsion: only local neighbor approximation
        dx = (xp[:,None]-xp[None,:]+N/2)%N-N/2
        dy = (yp[:,None]-yp[None,:]+N/2)%N-N/2
        dz = (zp[:,None]-zp[None,:]+N/2)%N-N/2
        mask = (dx**2+dy**2+dz**2>0)&(dx**2+dy**2+dz**2<=r_rep**2)
        ax += Krep*np.sum(dx*mask,axis=1)
        ay += Krep*np.sum(dy*mask,axis=1)
        az += Krep*np.sum(dz*mask,axis=1)
        # Thermal noise
        ax += rng.normal(0,v_th,NP_val)
        ay += rng.normal(0,v_th,NP_val)
        az += rng.normal(0,v_th,NP_val)
        vx += DT*ax; vy += DT*ay; vz += DT*az
        xp = (xp+vx*DT)%N; yp = (yp+vy*DT)%N; zp = (zp+vz*DT)%N
        max_C_history.append(C[N//2,N//2,N//2])
    return np.max(max_C_history)

# --- Krep sweep ---
Krep_values = np.linspace(0.01,2.0,15)
maxC_dwarf = []
maxC_massive = []

for k in Krep_values:
    maxC_dwarf.append(run_sim(NP_dwarf,k,v_th_dwarf))
for k in Krep_values:
    maxC_massive.append(run_sim(NP_massive,k,v_th_massive))

# --- Save data ---
np.savetxt(os.path.join(OUT_DIR,"cmax_vs_krep_dwarf.txt"),
           np.column_stack((Krep_values,maxC_dwarf)),
           header="Krep Max_Central_Curvature")
np.savetxt(os.path.join(OUT_DIR,"cmax_vs_krep_massive.txt"),
           np.column_stack((Krep_values,maxC_massive)),
           header="Krep Max_Central_Curvature")
print(f"Data saved in '{OUT_DIR}'")

# --- Plot ---
plt.figure(figsize=(10,6))
plt.plot(Krep_values,maxC_dwarf,marker='o',color='blue',label='Dwarf')
plt.plot(Krep_values,maxC_massive,marker='s',color='red',label='Massive')
plt.xlabel("Krep")
plt.ylabel("Max Central Curvature")
plt.title("Fast 3D Dynamic Lattice: Cmax vs Krep")
plt.axhline(0.2,color='green',linestyle='--',label='Stability threshold')
plt.legend()
plt.grid(True)
plt.savefig(os.path.join(OUT_DIR,"Krep_sweep_fast.png"))
plt.show()

print("Dwarf analog data (Krep, Cmax):")
print(np.column_stack((Krep_values, maxC_dwarf)))

print("\nMassive analog data (Krep, Cmax):")
print(np.column_stack((Krep_values, maxC_massive)))

import numpy as np
import os
import matplotlib.pyplot as plt

# =============================================================================
# Fast 3D Dynamic Lattice Simulation for Core–Cusp Formation (Sweet Spot)
# =============================================================================

# --- Simulation parameters ---
N = 32           # 3D grid size (small to keep runtime short)
STEPS = 200      # Time steps
DT = 0.05

# Dwarf analog
NP_dwarf = 500
v_th_dwarf = 0.1

# Massive analog
NP_massive = 1000
v_th_massive = 0.05

# Lattice parameters
s_src = 2.5
lam = 0.01
D_C = 0.05
mu = 1.0
r_rep = 2

OUT_DIR = "simulation_output_3d_fast"
os.makedirs(OUT_DIR, exist_ok=True)

# --- Helper functions ---
def laplacian(F):
    return (np.roll(F,1,0)+np.roll(F,-1,0)+
            np.roll(F,1,1)+np.roll(F,-1,1)+
            np.roll(F,1,2)+np.roll(F,-1,2)-6*F)

def cic_deposit(xp, yp, zp):
    rho = np.zeros((N,N,N))
    i0 = np.floor(xp).astype(int) % N
    j0 = np.floor(yp).astype(int) % N
    k0 = np.floor(zp).astype(int) % N
    i1, j1, k1 = (i0+1)%N, (j0+1)%N, (k0+1)%N
    tx, ty, tz = xp - np.floor(xp), yp - np.floor(yp), zp - np.floor(zp)
    w000 = (1-tx)*(1-ty)*(1-tz)
    w100 = tx*(1-ty)*(1-tz)
    w010 = (1-tx)*ty*(1-tz)
    w001 = (1-tx)*(1-ty)*tz
    w101 = tx*(1-ty)*tz
    w011 = (1-tx)*ty*tz
    w110 = tx*ty*(1-tz)
    w111 = tx*ty*tz
    np.add.at(rho, (i0,j0,k0), w000)
    np.add.at(rho, (i1,j0,k0), w100)
    np.add.at(rho, (i0,j1,k0), w010)
    np.add.at(rho, (i0,j0,k1), w001)
    np.add.at(rho, (i1,j0,k1), w101)
    np.add.at(rho, (i0,j1,k1), w011)
    np.add.at(rho, (i1,j1,k0), w110)
    np.add.at(rho, (i1,j1,k1), w111)
    return rho

def grad_xyz(F):
    Fx = (np.roll(F,-1,0)-np.roll(F,1,0))/2
    Fy = (np.roll(F,-1,1)-np.roll(F,1,1))/2
    Fz = (np.roll(F,-1,2)-np.roll(F,1,2))/2
    return Fx, Fy, Fz

def trilinear_sample(F, xp, yp, zp):
    i0 = np.floor(xp).astype(int) % N
    j0 = np.floor(yp).astype(int) % N
    k0 = np.floor(zp).astype(int) % N
    i1, j1, k1 = (i0+1)%N, (j0+1)%N, (k0+1)%N
    tx, ty, tz = xp - np.floor(xp), yp - np.floor(yp), zp - np.floor(zp)
    f000, f100 = F[i0,j0,k0], F[i1,j0,k0]
    f010, f001 = F[i0,j1,k0], F[i0,j0,k1]
    f101, f011 = F[i1,j0,k1], F[i0,j1,k1]
    f110, f111 = F[i1,j1,k0], F[i1,j1,k1]
    c00 = f000*(1-tx)+f100*tx
    c01 = f001*(1-tx)+f101*tx
    c10 = f010*(1-tx)+f110*tx
    c11 = f011*(1-tx)+f111*tx
    c0 = c00*(1-ty)+c10*ty
    c1 = c01*(1-ty)+c11*ty
    return c0*(1-tz)+c1*tz

# --- Simulation runner ---
def run_sim(NP_val, Krep, v_th, seed=12345):
    rng = np.random.default_rng(seed)
    xp = rng.normal(N/2, 5, NP_val) % N
    yp = rng.normal(N/2, 5, NP_val) % N
    zp = rng.normal(N/2, 5, NP_val) % N
    vx, vy, vz = np.zeros(NP_val), np.zeros(NP_val), np.zeros(NP_val)
    C = np.zeros((N,N,N))
    max_C_history = []

    for step in range(STEPS):
        rho = cic_deposit(xp, yp, zp)
        C += DT*(s_src*rho - lam*C + D_C*laplacian(C))
        Cx, Cy, Cz = grad_xyz(C)
        ax = mu * trilinear_sample(Cx, xp, yp, zp)
        ay = mu * trilinear_sample(Cy, xp, yp, zp)
        az = mu * trilinear_sample(Cz, xp, yp, zp)

        # Simple repulsion
        dx = (xp[:,None]-xp[None,:]+N/2)%N-N/2
        dy = (yp[:,None]-yp[None,:]+N/2)%N-N/2
        dz = (zp[:,None]-zp[None,:]+N/2)%N-N/2
        dist2 = dx**2+dy**2+dz**2
        mask = (dist2>0)&(dist2<=r_rep**2)
        ax += Krep*np.sum(dx*mask/dist2.clip(1e-12), axis=1)
        ay += Krep*np.sum(dy*mask/dist2.clip(1e-12), axis=1)
        az += Krep*np.sum(dz*mask/dist2.clip(1e-12), axis=1)

        # Thermal noise
        ax += rng.normal(0, v_th, NP_val)
        ay += rng.normal(0, v_th, NP_val)
        az += rng.normal(0, v_th, NP_val)

        vx += DT*ax; vy += DT*ay; vz += DT*az
        xp = (xp + DT*vx)%N
        yp = (yp + DT*vy)%N
        zp = (zp + DT*vz)%N

        max_C_history.append(C[N//2,N//2,N//2])

    return np.max(max_C_history)

# --- Krep sweep ---
Krep_values = np.linspace(0.01, 2.0, 15)
maxC_dwarf, maxC_massive = [], []

print("Running Krep sweep for Dwarf Analog...")
for k in Krep_values:
    maxC_dwarf.append(run_sim(NP_dwarf, k, v_th_dwarf))

print("Running Krep sweep for Massive Analog...")
for k in Krep_values:
    maxC_massive.append(run_sim(NP_massive, k, v_th_massive))

maxC_dwarf = np.array(maxC_dwarf)
maxC_massive = np.array(maxC_massive)

# --- Save data ---
np.savetxt(os.path.join(OUT_DIR,"dwarf_sweep.txt"), np.column_stack([Krep_values,maxC_dwarf]),
           header="Krep\tCmax")
np.savetxt(os.path.join(OUT_DIR,"massive_sweep.txt"), np.column_stack([Krep_values,maxC_massive]),
           header="Krep\tCmax")
print(f"Data saved in '{OUT_DIR}'")

# --- Plot sweep ---
plt.figure(figsize=(10,6))
plt.plot(Krep_values, maxC_dwarf, 'o-', label='Dwarf Analog')
plt.plot(Krep_values, maxC_massive, 's-', label='Massive Analog')
plt.xlabel("Krep (Repulsion Strength)")
plt.ylabel("Max Central Curvature")
plt.title("3D Dynamic Lattice: Max Central Curvature vs Krep")
plt.axhline(0.2, color='green', linestyle='--', label='Stability Threshold')
plt.legend()
plt.grid(True)
plt.savefig(os.path.join(OUT_DIR,"Krep_sweep.png"))
plt.show()

import numpy as np
import os
import matplotlib.pyplot as plt

# =============================================================================
# Fast 3D Dynamic Lattice Simulation for Core–Cusp Formation (Sweet Spot)
# =============================================================================

# --- Simulation parameters ---
N = 32           # 3D grid size (small to keep runtime short)
STEPS = 200      # Time steps
DT = 0.05

# Dwarf analog
NP_dwarf = 500
v_th_dwarf = 0.1

# Massive analog
NP_massive = 1000
v_th_massive = 0.05

# Lattice parameters
s_src = 2.5
lam = 0.01
D_C = 0.05
mu = 1.0
r_rep = 2

OUT_DIR = "simulation_output_3d_fast"
os.makedirs(OUT_DIR, exist_ok=True)

# --- Helper functions ---
def laplacian(F):
    return (np.roll(F,1,0)+np.roll(F,-1,0)+
            np.roll(F,1,1)+np.roll(F,-1,1)+
            np.roll(F,1,2)+np.roll(F,-1,2)-6*F)

def cic_deposit(xp, yp, zp):
    rho = np.zeros((N,N,N))
    i0 = np.floor(xp).astype(int) % N
    j0 = np.floor(yp).astype(int) % N
    k0 = np.floor(zp).astype(int) % N
    i1, j1, k1 = (i0+1)%N, (j0+1)%N, (k0+1)%N
    tx, ty, tz = xp - np.floor(xp), yp - np.floor(yp), zp - np.floor(zp)
    w000 = (1-tx)*(1-ty)*(1-tz)
    w100 = tx*(1-ty)*(1-tz)
    w010 = (1-tx)*ty*(1-tz)
    w001 = (1-tx)*(1-ty)*tz
    w101 = tx*(1-ty)*tz
    w011 = (1-tx)*ty*tz
    w110 = tx*ty*(1-tz)
    w111 = tx*ty*tz
    np.add.at(rho, (i0,j0,k0), w000)
    np.add.at(rho, (i1,j0,k0), w100)
    np.add.at(rho, (i0,j1,k0), w010)
    np.add.at(rho, (i0,j0,k1), w001)
    np.add.at(rho, (i1,j0,k1), w101)
    np.add.at(rho, (i0,j1,k1), w011)
    np.add.at(rho, (i1,j1,k0), w110)
    np.add.at(rho, (i1,j1,k1), w111)
    return rho

def grad_xyz(F):
    Fx = (np.roll(F,-1,0)-np.roll(F,1,0))/2
    Fy = (np.roll(F,-1,1)-np.roll(F,1,1))/2
    Fz = (np.roll(F,-1,2)-np.roll(F,1,2))/2
    return Fx, Fy, Fz

def trilinear_sample(F, xp, yp, zp):
    i0 = np.floor(xp).astype(int) % N
    j0 = np.floor(yp).astype(int) % N
    k0 = np.floor(zp).astype(int) % N
    i1, j1, k1 = (i0+1)%N, (j0+1)%N, (k0+1)%N
    tx, ty, tz = xp - np.floor(xp), yp - np.floor(yp), zp - np.floor(zp)
    f000, f100 = F[i0,j0,k0], F[i1,j0,k0]
    f010, f001 = F[i0,j1,k0], F[i0,j0,k1]
    f101, f011 = F[i1,j0,k1], F[i0,j1,k1]
    f110, f111 = F[i1,j1,k0], F[i1,j1,k1]
    c00 = f000*(1-tx)+f100*tx
    c01 = f001*(1-tx)+f101*tx
    c10 = f010*(1-tx)+f110*tx
    c11 = f011*(1-tx)+f111*tx
    c0 = c00*(1-ty)+c10*ty
    c1 = c01*(1-ty)+c11*ty
    return c0*(1-tz)+c1*tz

# --- Simulation runner ---
def run_sim(NP_val, Krep, v_th, seed=12345):
    rng = np.random.default_rng(seed)
    xp = rng.normal(N/2, 5, NP_val) % N
    yp = rng.normal(N/2, 5, NP_val) % N
    zp = rng.normal(N/2, 5, NP_val) % N
    vx, vy, vz = np.zeros(NP_val), np.zeros(NP_val), np.zeros(NP_val)
    C = np.zeros((N,N,N))
    max_C_history = []

    for step in range(STEPS):
        rho = cic_deposit(xp, yp, zp)
        C += DT*(s_src*rho - lam*C + D_C*laplacian(C))
        Cx, Cy, Cz = grad_xyz(C)
        ax = mu * trilinear_sample(Cx, xp, yp, zp)
        ay = mu * trilinear_sample(Cy, xp, yp, zp)
        az = mu * trilinear_sample(Cz, xp, yp, zp)

        # Simple repulsion
        dx = (xp[:,None]-xp[None,:]+N/2)%N-N/2
        dy = (yp[:,None]-yp[None,:]+N/2)%N-N/2
        dz = (zp[:,None]-zp[None,:]+N/2)%N-N/2
        dist2 = dx**2+dy**2+dz**2
        mask = (dist2>0)&(dist2<=r_rep**2)
        ax += Krep*np.sum(dx*mask/dist2.clip(1e-12), axis=1)
        ay += Krep*np.sum(dy*mask/dist2.clip(1e-12), axis=1)
        az += Krep*np.sum(dz*mask/dist2.clip(1e-12), axis=1)

        # Thermal noise
        ax += rng.normal(0, v_th, NP_val)
        ay += rng.normal(0, v_th, NP_val)
        az += rng.normal(0, v_th, NP_val)

        vx += DT*ax; vy += DT*ay; vz += DT*az
        xp = (xp + DT*vx)%N
        yp = (yp + DT*vy)%N
        zp = (zp + DT*vz)%N

        max_C_history.append(C[N//2,N//2,N//2])

    return np.max(max_C_history)

# --- Krep sweep ---
Krep_values = np.linspace(0.01, 2.0, 15)
maxC_dwarf, maxC_massive = [], []

print("Running Krep sweep for Dwarf Analog...")
for k in Krep_values:
    maxC_dwarf.append(run_sim(NP_dwarf, k, v_th_dwarf))

print("Running Krep sweep for Massive Analog...")
for k in Krep_values:
    maxC_massive.append(run_sim(NP_massive, k, v_th_massive))

maxC_dwarf = np.array(maxC_dwarf)
maxC_massive = np.array(maxC_massive)

# --- Save data ---
np.savetxt(os.path.join(OUT_DIR,"dwarf_sweep.txt"), np.column_stack([Krep_values,maxC_dwarf]),
           header="Krep\tCmax")
np.savetxt(os.path.join(OUT_DIR,"massive_sweep.txt"), np.column_stack([Krep_values,maxC_massive]),
           header="Krep\tCmax")
print(f"Data saved in '{OUT_DIR}'")

# --- Plot sweep ---
plt.figure(figsize=(10,6))
plt.plot(Krep_values, maxC_dwarf, 'o-', label='Dwarf Analog')
plt.plot(Krep_values, maxC_massive, 's-', label='Massive Analog')
plt.xlabel("Krep (Repulsion Strength)")
plt.ylabel("Max Central Curvature")
plt.title("3D Dynamic Lattice: Max Central Curvature vs Krep")
plt.axhline(0.2, color='green', linestyle='--', label='Stability Threshold')
plt.legend()
plt.grid(True)
plt.savefig(os.path.join(OUT_DIR,"Krep_sweep.png"))
plt.show()

import numpy as np

# --- Krep sweep parameters ---
Krep_values = np.linspace(0.01, 2.0, 15)

# Placeholder arrays for results
maxC_dwarf = np.zeros_like(Krep_values)
maxC_massive = np.zeros_like(Krep_values)

# Function run_sim should be defined as in your existing script

# --- Run sweep and store maxC ---
for i, k in enumerate(Krep_values):
    maxC_dwarf[i] = run_sim(NP_dwarf, k, v_th_dwarf)
    maxC_massive[i] = run_sim(NP_massive, k, v_th_massive)

# --- Print results as table ---
print("Dwarf Analog: Krep vs Max Central Curvature")
print("{:<10} {:<15}".format("Krep", "MaxC"))
for k, mc in zip(Krep_values, maxC_dwarf):
    print(f"{k:<10.3f} {mc:<15.5f}")

print("\nMassive Analog: Krep vs Max Central Curvature")
print("{:<10} {:<15}".format("Krep", "MaxC"))
for k, mc in zip(Krep_values, maxC_massive):
    print(f"{k:<10.3f} {mc:<15.5f}")

import numpy as np
import os

# =============================================================================
# 3D Dynamic Lattice Simulation for Core–Cusp Formation (Table Output Only)
# =============================================================================

# --- Simulation parameters ---
N = 32           # 3D grid size
STEPS = 200      # Time steps
DT = 0.05

# Dwarf analog
NP_dwarf = 500
v_th_dwarf = 0.1

# Massive analog
NP_massive = 1000
v_th_massive = 0.05

# Lattice parameters
s_src = 2.5
lam = 0.01
D_C = 0.05
mu = 1.0
r_rep = 2

OUT_DIR = "simulation_output_3d_table"
os.makedirs(OUT_DIR, exist_ok=True)

# --- Helper functions ---
def laplacian(F):
    return (np.roll(F,1,0)+np.roll(F,-1,0)+
            np.roll(F,1,1)+np.roll(F,-1,1)+
            np.roll(F,1,2)+np.roll(F,-1,2)-6*F)

def cic_deposit(xp, yp, zp):
    rho = np.zeros((N,N,N))
    i0 = np.floor(xp).astype(int) % N
    j0 = np.floor(yp).astype(int) % N
    k0 = np.floor(zp).astype(int) % N
    i1, j1, k1 = (i0+1)%N, (j0+1)%N, (k0+1)%N
    tx, ty, tz = xp - np.floor(xp), yp - np.floor(yp), zp - np.floor(zp)
    w000 = (1-tx)*(1-ty)*(1-tz)
    w100 = tx*(1-ty)*(1-tz)
    w010 = (1-tx)*ty*(1-tz)
    w001 = (1-tx)*(1-ty)*tz
    w101 = tx*(1-ty)*tz
    w011 = (1-tx)*ty*tz
    w110 = tx*ty*(1-tz)
    w111 = tx*ty*tz
    np.add.at(rho, (i0,j0,k0), w000)
    np.add.at(rho, (i1,j0,k0), w100)
    np.add.at(rho, (i0,j1,k0), w010)
    np.add.at(rho, (i0,j0,k1), w001)
    np.add.at(rho, (i1,j0,k1), w101)
    np.add.at(rho, (i0,j1,k1), w011)
    np.add.at(rho, (i1,j1,k0), w110)
    np.add.at(rho, (i1,j1,k1), w111)
    return rho

def grad_xyz(F):
    Fx = (np.roll(F,-1,0)-np.roll(F,1,0))/2
    Fy = (np.roll(F,-1,1)-np.roll(F,1,1))/2
    Fz = (np.roll(F,-1,2)-np.roll(F,1,2))/2
    return Fx, Fy, Fz

def trilinear_sample(F, xp, yp, zp):
    i0 = np.floor(xp).astype(int) % N
    j0 = np.floor(yp).astype(int) % N
    k0 = np.floor(zp).astype(int) % N
    i1, j1, k1 = (i0+1)%N, (j0+1)%N, (k0+1)%N
    tx, ty, tz = xp - np.floor(xp), yp - np.floor(yp), zp - np.floor(zp)
    f000, f100 = F[i0,j0,k0], F[i1,j0,k0]
    f010, f001 = F[i0,j1,k0], F[i0,j0,k1]
    f101, f011 = F[i1,j0,k1], F[i0,j1,k1]
    f110, f111 = F[i1,j1,k0], F[i1,j1,k1]
    c00 = f000*(1-tx)+f100*tx
    c01 = f001*(1-tx)+f101*tx
    c10 = f010*(1-tx)+f110*tx
    c11 = f011*(1-tx)+f111*tx
    c0 = c00*(1-ty)+c10*ty
    c1 = c01*(1-ty)+c11*ty
    return c0*(1-tz)+c1*tz

# --- Simulation runner ---
def run_sim(NP_val, Krep, v_th, seed=12345):
    rng = np.random.default_rng(seed)
    xp = rng.normal(N/2, 5, NP_val) % N
    yp = rng.normal(N/2, 5, NP_val) % N
    zp = rng.normal(N/2, 5, NP_val) % N
    vx, vy, vz = np.zeros(NP_val), np.zeros(NP_val), np.zeros(NP_val)
    C = np.zeros((N,N,N))
    max_C_history = []

    for step in range(STEPS):
        rho = cic_deposit(xp, yp, zp)
        C += DT*(s_src*rho - lam*C + D_C*laplacian(C))
        Cx, Cy, Cz = grad_xyz(C)
        ax = mu * trilinear_sample(Cx, xp, yp, zp)
        ay = mu * trilinear_sample(Cy, xp, yp, zp)
        az = mu * trilinear_sample(Cz, xp, yp, zp)

        dx = (xp[:,None]-xp[None,:]+N/2)%N-N/2
        dy = (yp[:,None]-yp[None,:]+N/2)%N-N/2
        dz = (zp[:,None]-zp[None,:]+N/2)%N-N/2
        dist2 = dx**2+dy**2+dz**2
        mask = (dist2>0)&(dist2<=r_rep**2)
        ax += Krep*np.sum(dx*mask/dist2.clip(1e-12), axis=1)
        ay += Krep*np.sum(dy*mask/dist2.clip(1e-12), axis=1)
        az += Krep*np.sum(dz*mask/dist2.clip/dist2.clip(1e-12), axis=1)

        ax += rng.normal(0, v_th, NP_val)
        ay += rng.normal(0, v_th, NP_val)
        az += rng.normal(0, v_th, NP_val)

        vx += DT*ax; vy += DT*ay; vz += DT*az
        xp = (xp + DT*vx)%N
        yp = (yp + DT*vy)%N
        zp = (zp + DT*vz)%N

        max_C_history.append(C[N//2,N//2,N//2])

    return np.max(max_C_history)

# --- Krep sweep ---
Krep_values = np.linspace(0.01, 2.0, 15)
maxC_dwarf, maxC_massive = [], []

for k in Krep_values:
    maxC_dwarf.append(run_sim(NP_dwarf, k, v_th_dwarf))
    maxC_massive.append(run_sim(NP_massive, k, v_th_massive))

maxC_dwarf = np.array(maxC_dwarf)
maxC_massive = np.array(maxC_massive)

# --- Print tabular results ---
print("\nDwarf Analog Krep vs MaxC:")
print("Krep\tMaxC")
for k, c in zip(Krep_values, maxC_dwarf):
    print(f"{k:.3f}\t{c:.6f}")

print("\nMassive Analog Krep vs MaxC:")
print("Krep\tMaxC")
for k, c in zip(Krep_values, maxC_massive):
    print(f"{k:.3f}\t{c:.6f}")

# --- Save data ---
np.savetxt(os.path.join(OUT_DIR,"dwarf_sweep.txt"), np.column_stack([Krep_values,maxC_dwarf]),
           header="Krep\tMaxC", fmt="%.6f")
np.savetxt(os.path.join(OUT_DIR,"massive_sweep.txt"), np.column_stack([Krep_values,maxC_massive]),
           header="Krep\tMaxC", fmt="%.6f")

print(f"\nData saved in '{OUT_DIR}'")

---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
/tmp/ipython-input-4145682494.py in <cell line: 0>()
    129
    130 for k in Krep_values:
--> 131     maxC_dwarf.append(run_sim(NP_dwarf, k, v_th_dwarf))
    132     maxC_massive.append(run_sim(NP_massive, k, v_th_massive))
    133

/tmp/ipython-input-4145682494.py in run_sim(NP_val, Krep, v_th, seed)
    109         ax += Krep*np.sum(dx*mask/dist2.clip(1e-12), axis=1)
    110         ay += Krep*np.sum(dy*mask/dist2.clip(1e-12), axis=1)
--> 111         az += Krep*np.sum(dz*mask/dist2.clip/dist2.clip(1e-12), axis=1)
    112
    113         ax += rng.normal(0, v_th, NP_val)

TypeError: unsupported operand type(s) for /: 'float' and 'builtin_function_or_method'

import numpy as np
import os

# =============================================================================
# Fast 3D Dynamic Lattice Simulation for Core–Cusp Formation (Tabular Output)
# =============================================================================

# --- Simulation parameters ---
N = 32           # 3D grid size (small to keep runtime short)
STEPS = 200      # Time steps
DT = 0.05

# Dwarf analog
NP_dwarf = 500
v_th_dwarf = 0.1

# Massive analog
NP_massive = 1000
v_th_massive = 0.05

# Lattice parameters
s_src = 2.5
lam = 0.01
D_C = 0.05
mu = 1.0
r_rep = 2

OUT_DIR = "simulation_output_3d_fast"
os.makedirs(OUT_DIR, exist_ok=True)

# --- Helper functions ---
def laplacian(F):
    return (np.roll(F,1,0)+np.roll(F,-1,0)+
            np.roll(F,1,1)+np.roll(F,-1,1)+
            np.roll(F,1,2)+np.roll(F,-1,2)-6*F)

def cic_deposit(xp, yp, zp):
    rho = np.zeros((N,N,N))
    i0 = np.floor(xp).astype(int) % N
    j0 = np.floor(yp).astype(int) % N
    k0 = np.floor(zp).astype(int) % N
    i1, j1, k1 = (i0+1)%N, (j0+1)%N, (k0+1)%N
    tx, ty, tz = xp - np.floor(xp), yp - np.floor(yp), zp - np.floor(zp)
    w000 = (1-tx)*(1-ty)*(1-tz)
    w100 = tx*(1-ty)*(1-tz)
    w010 = (1-tx)*ty*(1-tz)
    w001 = (1-tx)*(1-ty)*tz
    w101 = tx*(1-ty)*tz
    w011 = (1-tx)*ty*tz
    w110 = tx*ty*(1-tz)
    w111 = tx*ty*tz
    np.add.at(rho, (i0,j0,k0), w000)
    np.add.at(rho, (i1,j0,k0), w100)
    np.add.at(rho, (i0,j1,k0), w010)
    np.add.at(rho, (i0,j0,k1), w001)
    np.add.at(rho, (i1,j0,k1), w101)
    np.add.at(rho, (i0,j1,k1), w011)
    np.add.at(rho, (i1,j1,k0), w110)
    np.add.at(rho, (i1,j1,k1), w111)
    return rho

def grad_xyz(F):
    Fx = (np.roll(F,-1,0)-np.roll(F,1,0))/2
    Fy = (np.roll(F,-1,1)-np.roll(F,1,1))/2
    Fz = (np.roll(F,-1,2)-np.roll(F,1,2))/2
    return Fx, Fy, Fz

def trilinear_sample(F, xp, yp, zp):
    i0 = np.floor(xp).astype(int) % N
    j0 = np.floor(yp).astype(int) % N
    k0 = np.floor(zp).astype(int) % N
    i1, j1, k1 = (i0+1)%N, (j0+1)%N, (k0+1)%N
    tx, ty, tz = xp - np.floor(xp), yp - np.floor(yp), zp - np.floor(zp)
    f000, f100 = F[i0,j0,k0], F[i1,j0,k0]
    f010, f001 = F[i0,j1,k0], F[i0,j0,k1]
    f101, f011 = F[i1,j0,k1], F[i0,j1,k1]
    f110, f111 = F[i1,j1,k0], F[i1,j1,k1]
    c00 = f000*(1-tx)+f100*tx
    c01 = f001*(1-tx)+f101*tx
    c10 = f010*(1-tx)+f110*tx
    c11 = f011*(1-tx)+f111*tx
    c0 = c00*(1-ty)+c10*ty
    c1 = c01*(1-ty)+c11*ty
    return c0*(1-tz)+c1*tz

# --- Simulation runner ---
def run_sim(NP_val, Krep, v_th, seed=12345):
    rng = np.random.default_rng(seed)
    xp = rng.normal(N/2, 5, NP_val) % N
    yp = rng.normal(N/2, 5, NP_val) % N
    zp = rng.normal(N/2, 5, NP_val) % N
    vx, vy, vz = np.zeros(NP_val), np.zeros(NP_val), np.zeros(NP_val)
    C = np.zeros((N,N,N))
    max_C_history = []

    for step in range(STEPS):
        rho = cic_deposit(xp, yp, zp)
        C += DT*(s_src*rho - lam*C + D_C*laplacian(C))
        Cx, Cy, Cz = grad_xyz(C)
        ax = mu * trilinear_sample(Cx, xp, yp, zp)
        ay = mu * trilinear_sample(Cy, xp, yp, zp)
        az = mu * trilinear_sample(Cz, xp, yp, zp)

        # Simple repulsion
        dx = (xp[:,None]-xp[None,:]+N/2)%N-N/2
        dy = (yp[:,None]-yp[None,:]+N/2)%N-N/2
        dz = (zp[:,None]-zp[None,:]+N/2)%N-N/2
        dist2 = dx**2+dy**2+dz**2
        mask = (dist2>0)&(dist2<=r_rep**2)
        ax += Krep*np.sum(dx*mask/dist2.clip(1e-12), axis=1)
        ay += Krep*np.sum(dy*mask/dist2.clip(1e-12), axis=1)
        az += Krep*np.sum(dz*mask/dist2.clip(1e-12), axis=1)

        # Thermal noise
        ax += rng.normal(0, v_th, NP_val)
        ay += rng.normal(0, v_th, NP_val)
        az += rng.normal(0, v_th, NP_val)

        vx += DT*ax; vy += DT*ay; vz += DT*az
        xp = (xp + DT*vx)%N
        yp = (yp + DT*vy)%N
        zp = (zp + DT*vz)%N

        max_C_history.append(C[N//2,N//2,N//2])

    return np.max(max_C_history)

# --- Krep sweep ---
Krep_values = np.linspace(0.01, 2.0, 15)
maxC_dwarf, maxC_massive = [], []

print("Running Krep sweep for Dwarf Analog...")
for k in Krep_values:
    maxC_dwarf.append(run_sim(NP_dwarf, k, v_th_dwarf))

print("Running Krep sweep for Massive Analog...")
for k in Krep_values:
    maxC_massive.append(run_sim(NP_massive, k, v_th_massive))

maxC_dwarf = np.array(maxC_dwarf)
maxC_massive = np.array(maxC_massive)

# --- Save data as tables ---
np.savetxt(os.path.join(OUT_DIR,"dwarf_sweep.txt"),
           np.column_stack([Krep_values,maxC_dwarf]),
           header="Krep\tCmax", fmt="%.6f", delimiter="\t")

np.savetxt(os.path.join(OUT_DIR,"massive_sweep.txt"),
           np.column_stack([Krep_values,maxC_massive]),
           header="Krep\tCmax", fmt="%.6f", delimiter="\t")

print(f"Data saved as tabular output in '{OUT_DIR}'")

import numpy as np

dwarf_data = np.loadtxt("simulation_output_3d_fast/dwarf_sweep.txt", skiprows=1)
massive_data = np.loadtxt("simulation_output_3d_fast/massive_sweep.txt", skiprows=1)

print("Dwarf Analog Krep vs Cmax:")
for row in dwarf_data:
    print(f"{row[0]:.3f}\t{row[1]:.6f}")

print("\nMassive Analog Krep vs Cmax:")
for row in massive_data:
    print(f"{row[0]:.3f}\t{row[1]:.6f}")

import numpy as np
import os

# =============================================================================
# 3D Dynamic Lattice Simulation (Tabular Output Only)
# =============================================================================

# --- Simulation parameters ---
N = 32
STEPS = 200
DT = 0.05

# Particle numbers and thermal velocities
NP_dwarf = 500
v_th_dwarf = 0.1

NP_massive = 1000
v_th_massive = 0.05

# Lattice parameters
s_src = 2.5
lam = 0.01
D_C = 0.05
mu = 1.0
r_rep = 2

OUT_DIR = "simulation_output_3d_table"
os.makedirs(OUT_DIR, exist_ok=True)

# --- Helper functions ---
def laplacian(F):
    return (np.roll(F,1,0)+np.roll(F,-1,0)+
            np.roll(F,1,1)+np.roll(F,-1,1)+
            np.roll(F,1,2)+np.roll(F,-1,2)-6*F)

def cic_deposit(xp, yp, zp):
    rho = np.zeros((N,N,N))
    i0 = np.floor(xp).astype(int) % N
    j0 = np.floor(yp).astype(int) % N
    k0 = np.floor(zp).astype(int) % N
    i1, j1, k1 = (i0+1)%N, (j0+1)%N, (k0+1)%N
    tx, ty, tz = xp - np.floor(xp), yp - np.floor(yp), zp - np.floor(zp)
    w000 = (1-tx)*(1-ty)*(1-tz)
    w10

import numpy as np
import os

# =============================================================================
# 3D Dynamic Lattice Simulation (Tabular Output Only)
# =============================================================================

# --- Simulation parameters ---
N = 32
STEPS = 200
DT = 0.05

# Particle numbers and thermal velocities
NP_dwarf = 500
v_th_dwarf = 0.1

NP_massive = 1000
v_th_massive = 0.05

# Lattice parameters
s_src = 2.5
lam = 0.01
D_C = 0.05
mu = 1.0
r_rep = 2

OUT_DIR = "simulation_output_3d_table"
os.makedirs(OUT_DIR, exist_ok=True)

# --- Helper functions ---
def laplacian(F):
    return (np.roll(F,1,0)+np.roll(F,-1,0)+
            np.roll(F,1,1)+np.roll(F,-1,1)+
            np.roll(F,1,2)+np.roll(F,-1,2)-6*F)

def cic_deposit(xp, yp, zp):
    rho = np.zeros((N,N,N))
    i0 = np.floor(xp).astype(int) % N
    j0 = np.floor(yp).astype(int) % N
    k0 = np.floor(zp).astype(int) % N
    i1, j1, k1 = (i0+1)%N, (j0+1)%N, (k0+1)%N
    tx, ty, tz = xp - np.floor(xp), yp - np.floor(yp), zp - np.floor(zp)
    w000 = (1-tx)*(1-ty)*(1-tz)
    w100 = tx*(1-ty)*(1-tz)
    w010 = (1-tx)*ty*(1-tz)
    w001 = (1-tx)*(1-ty)*tz
    w101 = tx*(1-ty)*tz
    w011 = (1-tx)*ty*tz
    w110 = tx*ty*(1-tz)
    w111 = tx*ty*tz
    np.add.at(rho, (i0,j0,k0), w000)
    np.add.at(rho, (i1,j0,k0), w100)
    np.add.at(rho, (i0,j1,k0), w010)
    np.add.at(rho, (i0,j0,k1), w001)
    np.add.at(rho, (i1,j0,k1), w101)
    np.add.at(rho, (i0,j1,k1), w011)
    np.add.at(rho, (i1,j1,k0), w110)
    np.add.at(rho, (i1,j1,k1), w111)
    return rho

def grad_xyz(F):
    Fx = (np.roll(F,-1,0)-np.roll(F,1,0))/2
    Fy = (np.roll(F,-1,1)-np.roll(F,1,1))/2
    Fz = (np.roll(F,-1,2)-np.roll(F,1,2))/2
    return Fx, Fy, Fz

def trilinear_sample(F, xp, yp, zp):
    i0 = np.floor(xp).astype(int) % N
    j0 = np.floor(yp).astype(int) % N
    k0 = np.floor(zp).astype(int) % N
    i1, j1, k1 = (i0+1)%N, (j0+1)%N, (k0+1)%N
    tx, ty, tz = xp - np.floor(xp), yp - np.floor(yp), zp - np.floor(zp)
    f000, f100 = F[i0,j0,k0], F[i1,j0,k0]
    f010, f001 = F[i0,j1,k0], F[i0,j0,k1]
    f101, f011 = F[i1,j0,k1], F[i0,j1,k1]
    f110, f111 = F[i1,j1,k0], F[i1,j1,k1]
    c00 = f000*(1-tx)+f100*tx
    c01 = f001*(1-tx)+f101*tx
    c10 = f010*(1-tx)+f110*tx
    c11 = f011*(1-tx)+f111*tx
    c0 = c00*(1-ty)+c10*ty
    c1 = c01*(1-ty)+c11*ty
    return c0*(1-tz)+c1*tz

# --- Simulation runner ---
def run_sim(NP_val, Krep, v_th, seed=12345):
    rng = np.random.default_rng(seed)
    xp = rng.normal(N/2, 5, NP_val) % N
    yp = rng.normal(N/2, 5, NP_val) % N
    zp = rng.normal(N/2, 5, NP_val) % N
    vx, vy, vz = np.zeros(NP_val), np.zeros(NP_val), np.zeros(NP_val)
    C = np.zeros((N,N,N))
    max_C_history = []

    for step in range(STEPS):
        rho = cic_deposit(xp, yp, zp)
        C += DT*(s_src*rho - lam*C + D_C*laplacian(C))
        Cx, Cy, Cz = grad_xyz(C)
        ax = mu * trilinear_sample(Cx, xp, yp, zp)
        ay = mu * trilinear_sample(Cy, xp, yp, zp)
        az = mu * trilinear_sample(Cz, xp, yp, zp)

        dx = (xp[:,None]-xp[None,:]+N/2)%N-N/2
        dy = (yp[:,None]-yp[None,:]+N/2)%N-N/2
        dz = (zp[:,None]-zp[None,:]+N/2)%N-N/2
        dist2 = dx**2+dy**2+dz**2
        mask = (dist2>0)&(dist2<=r_rep**2)
        ax += Krep*np.sum(dx*mask/dist2.clip(1e-12), axis=1)
        ay += Krep*np.sum(dy*mask/dist2.clip(1e-12), axis=1)
        az += Krep*np.sum(dz*mask/dist2.clip(1e-12), axis=1)

        ax += rng.normal(0, v_th, NP_val)
        ay += rng.normal(0, v_th, NP_val)
        az += rng.normal(0, v_th, NP_val)

        vx += DT*ax; vy += DT*ay; vz += DT*az
        xp = (xp + DT*vx)%N
        yp = (yp + DT*vy)%N
        zp = (zp + DT*vz)%N

        max_C_history.append(C[N//2,N//2,N//2])

    return np.max(max_C_history)

# --- Krep sweep ---
Krep_values = np.linspace(0.01, 2.0, 15)
maxC_dwarf, maxC_massive = [], []

for k in Krep_values:
    maxC_dwarf.append(run_sim(NP_dwarf, k, v_th_dwarf))
    maxC_massive.append(run_sim(NP_massive, k, v_th_massive))

# --- Print table ---
print("\nDwarf Analog Krep vs MaxC:")
for k, c in zip(Krep_values, maxC_dwarf):
    print(f"{k:.3f}\t{c:.6f}")

print("\nMassive Analog Krep vs MaxC:")
for k, c in zip(Krep_values, maxC_massive):
    print(f"{k:.3f}\t{c:.6f}")

import matplotlib.pyplot as plt
import numpy as np

# Krep values
Krep_values = np.array([0.010,0.152,0.294,0.436,0.579,0.721,0.863,1.005,
                        1.147,1.289,1.431,1.574,1.716,1.858,2.000])

# MaxC values from your latest run
maxC_dwarf = np.array([7.456666,11.066711,5.716911,4.704362,3.391397,
                       3.403314,3.508229,2.704998,2.480399,2.829534,
                       3.122628,3.435125,2.294053,2.154627,2.165375])

maxC_massive = np.array([4.861954,7.112852,24.892795,19.142198,12.845896,
                         9.064415,6.397248,4.740558,3.901363,4.572857,
                         3.545676,3.903572,4.027502,2.801909,2.971736])

plt.figure(figsize=(10,6))
plt.plot(Krep_values, maxC_dwarf, 'o-', label='Dwarf Analog')
plt.plot(Krep_values, maxC_massive, 's-', label='Massive Analog')
plt.xlabel("Krep (Repulsion Strength)")
plt.ylabel("Max Central Curvature (MaxC)")
plt.title("3D Dynamic Lattice: MaxC vs Krep")
plt.axhline(0.2, color='green', linestyle='--', label='Stability Threshold')
plt.legend()
plt.grid(True)
plt.show()

import numpy as np
import os
import matplotlib.pyplot as plt

# =============================================================================
# 3D Dynamic Lattice Simulation with Cusp–Core Triggering
# =============================================================================

N = 32           # 3D grid size
STEPS = 200
DT = 0.05

# Particle numbers
NP_dwarf = 500
NP_massive = 1000

# Initial thermal noise
v_th_dwarf = 0.1
v_th_massive = 0.05

# Lattice parameters
s_src = 2.5
lam = 0.01
D_C = 0.05
mu = 1.0
r_rep = 2

OUT_DIR = "simulation_output_3d_cusp"
os.makedirs(OUT_DIR, exist_ok=True)

# --- Helper functions ---
def laplacian(F):
    return (np.roll(F,1,0)+np.roll(F,-1,0)+
            np.roll(F,1,1)+np.roll(F,-1,1)+
            np.roll(F,1,2)+np.roll(F,-1,2)-6*F)

def cic_deposit(xp, yp, zp):
    rho = np.zeros((N,N,N))
    i0 = np.floor(xp).astype(int) % N
    j0 = np.floor(yp).astype(int) % N
    k0 = np.floor(zp).astype(int) % N
    i1, j1, k1 = (i0+1)%N, (j0+1)%N, (k0+1)%N
    tx, ty, tz = xp - np.floor(xp), yp - np.floor(yp), zp - np.floor(zp)
    w000 = (1-tx)*(1-ty)*(1-tz)
    w100 = tx*(1-ty)*(1-tz)
    w010 = (1-tx)*ty*(1-tz)
    w001 = (1-tx)*(1-ty)*tz
    w101 = tx*(1-ty)*tz
    w011 = (1-tx)*ty*tz
    w110 = tx*ty*(1-tz)
    w111 = tx*ty*tz
    np.add.at(rho, (i0,j0,k0), w000)
    np.add.at(rho, (i1,j0,k0), w100)
    np.add.at(rho, (i0,j1,k0), w010)
    np.add.at(rho, (i0,j0,k1), w001)
    np.add.at(rho, (i1,j0,k1), w101)
    np.add.at(rho, (i0,j1,k1), w011)
    np.add.at(rho, (i1,j1,k0), w110)
    np.add.at(rho, (i1,j1,k1), w111)
    return rho

def grad_xyz(F):
    Fx = (np.roll(F,-1,0)-np.roll(F,1,0))/2
    Fy = (np.roll(F,-1,1)-np.roll(F,1,1))/2
    Fz = (np.roll(F,-1,2)-np.roll(F,1,2))/2
    return Fx, Fy, Fz

def trilinear_sample(F, xp, yp, zp):
    i0 = np.floor(xp).astype(int) % N
    j0 = np.floor(yp).astype(int) % N
    k0 = np.floor(zp).astype(int) % N
    i1, j1, k1 = (i0+1)%N, (j0+1)%N, (k0+1)%N
    tx, ty, tz = xp - np.floor(xp), yp - np.floor(yp), zp - np.floor(zp)
    f000, f100 = F[i0,j0,k0], F[i1,j0,k0]
    f010, f001 = F[i0,j1,k0], F[i0,j0,k1]
    f101, f011 = F[i1,j0,k1], F[i0,j1,k1]
    f110, f111 = F[i1,j1,k0], F[i1,j1,k1]
    c00 = f000*(1-tx)+f100*tx
    c01 = f001*(1-tx)+f101*tx
    c10 = f010*(1-tx)+f110*tx
    c11 = f011*(1-tx)+f111*tx
    c0 = c00*(1-ty)+c10*ty
    c1 = c01*(1-ty)+c11*ty
    return c0*(1-tz)+c1*tz

# --- Simulation runner with dynamic adjustments ---
def run_sim(NP_val, Krep, v_th, seed=12345):
    rng = np.random.default_rng(seed)

    # Introduce heterogeneity for cusp formation
    xp = rng.normal(N/2, 5, NP_val) + rng.normal(0, 2, NP_val)
    yp = rng.normal(N/2, 5, NP_val) + rng.normal(0, 2, NP_val)
    zp = rng.normal(N/2, 5, NP_val) + rng.normal(0, 2, NP_val)

    vx, vy, vz = np.zeros(NP_val), np.zeros(NP_val), np.zeros(NP_val)
    C = np.zeros((N,N,N))
    max_C_history = []

    for step in range(STEPS):
        # Dynamic adjustments
        Krep_step = Krep * (step/STEPS)**0.5
        D_C_step = D_C * (step/50) if step>0 else 0.001
        v_th_dynamic = v_th * (1 + 5*np.exp(-step/50))

        rho = cic_deposit(xp, yp, zp)
        C += DT*(s_src*rho - lam*C + D_C_step*laplacian(C))
        Cx, Cy, Cz = grad_xyz(C)
        ax = mu * trilinear_sample(Cx, xp, yp, zp)
        ay = mu * trilinear_sample(Cy, xp, yp, zp)
        az = mu * trilinear_sample(Cz, xp, yp, zp)

        # Simple repulsion
        dx = (xp[:,None]-xp[None,:]+N/2)%N-N/2
        dy = (yp[:,None]-yp[None,:]+N/2)%N-N/2
        dz = (zp[:,None]-zp[None,:]+N/2)%N-N/2
        dist2 = dx**2+dy**2+dz**2
        mask = (dist2>0)&(dist2<=r_rep**2)
        ax += Krep_step*np.sum(dx*mask/dist2.clip(1e-12), axis=1)
        ay += Krep_step*np.sum(dy*mask/dist2.clip(1e-12), axis=1)
        az += Krep_step*np.sum(dz*mask/dist2.clip(1e-12), axis=1)

        # Thermal noise
        ax += rng.normal(0, v_th_dynamic, NP_val)
        ay += rng.normal(0, v_th_dynamic, NP_val)
        az += rng.normal(0, v_th_dynamic, NP_val)

        vx += DT*ax; vy += DT*ay; vz += DT*az
        xp = (xp + DT*vx)%N
        yp = (yp + DT*vy)%N
        zp = (zp + DT*vz)%N

        max_C_history.append(C[N//2,N//2,N//2])

    return np.max(max_C_history)

# --- Krep sweep ---
Krep_values = np.linspace(0.01, 2.0, 15)
maxC_dwarf, maxC_massive = [], []

print("Running Krep sweep for Dwarf Analog...")
for k in Krep_values:
    maxC_dwarf.append(run_sim(NP_dwarf, k, v_th_dwarf))

print("Running Krep sweep for Massive Analog...")
for k in Krep_values:
    maxC_massive.append(run_sim(NP_massive, k, v_th_massive))

maxC_dwarf = np.array(maxC_dwarf)
maxC_massive = np.array(maxC_massive)

# --- Save tables ---
np.savetxt(os.path.join(OUT_DIR,"dwarf_sweep_cusp.txt"),
           np.column_stack([Krep_values,maxC_dwarf]), header="Krep\tCmax")
np.savetxt(os.path.join(OUT_DIR,"massive_sweep_cusp.txt"),
           np.column_stack([Krep_values,maxC_massive]), header="Krep\tCmax")
print(f"Data saved in '{OUT_DIR}'")

# --- Plot ---
plt.figure(figsize=(10,6))
plt.plot(Krep_values, maxC_dwarf, 'o-', label='Dwarf Analog')
plt.plot(Krep_values, maxC_massive, 's-', label='Massive Analog')
plt.xlabel("Krep (Repulsion Strength)")
plt.ylabel("Max Central Curvature")
plt.title("3D Dynamic Lattice: Max Central Curvature vs Krep (Cusp–Core Triggering)")
plt.axhline(y=np.median(maxC_dwarf), color='green', linestyle='--', label='Dwarf Core Threshold')
plt.axhline(y=np.median(maxC_massive), color='orange', linestyle='--', label='Massive Core Threshold')
plt.legend()
plt.grid(True)
plt.show()

# quick_3d_sweep_with_thresholds.py
# ------------------------------------------------------------
# 3D cusp-core sweep (dwarf + massive) with REAL thresholding:
# - runs sims
# - saves MaxC vs Krep tables
# - computes radial density profiles
# - derives thresholds from inner/outer log–log slope difference
# - plots all 6 curves + vertical dotted threshold lines
# ------------------------------------------------------------

import numpy as np
import matplotlib.pyplot as plt
import os

# ----------------------------
# Output
# ----------------------------
OUT_DIR = "quick_sweep_output"
os.makedirs(OUT_DIR, exist_ok=True)

# ----------------------------
# Simulation settings (fast but representative)
# ----------------------------
N = 32
STEPS = 200
DT = 0.05

# Dwarf & Massive particle counts
NP_dwarf = 500
NP_massive = 1000

# Thermal noise (base)
v_th_dwarf = 0.12
v_th_massive = 0.08

# Lattice params
s_src = 2.5
lam = 0.01
mu = 1.0
r_rep = 2

# Sweep parameters
D_C_values = [0.01, 0.02, 0.05]
Krep_values = np.linspace(0.01, 2.0, 15)

# Dynamics knobs (same as earlier fast runs)
alpha = 0.5        # ramp exponent for Krep_step
vth_A = 5.0        # early noise amplitude multiplier
vth_tau = 50.0     # noise decay timescale
rng_seed = 12345

# ----------------------------
# Helpers
# ----------------------------
def laplacian(F):
    return (np.roll(F,1,0)+np.roll(F,-1,0)+
            np.roll(F,1,1)+np.roll(F,-1,1)+
            np.roll(F,1,2)+np.roll(F,-1,2) - 6*F)

def cic_deposit(xp, yp, zp):
    rho = np.zeros((N,N,N))
    i0 = np.floor(xp).astype(int) % N
    j0 = np.floor(yp).astype(int) % N
    k0 = np.floor(zp).astype(int) % N
    i1, j1, k1 = (i0+1)%N, (j0+1)%N, (k0+1)%N
    tx, ty, tz = xp - np.floor(xp), yp - np.floor(yp), zp - np.floor(zp)
    w000 = (1-tx)*(1-ty)*(1-tz)
    w100 = tx*(1-ty)*(1-tz)
    w010 = (1-tx)*ty*(1-tz)
    w001 = (1-tx)*(1-ty)*tz
    w101 = tx*(1-ty)*tz
    w011 = (1-tx)*ty*tz
    w110 = tx*ty*(1-tz)
    w111 = tx*ty*tz
    np.add.at(rho, (i0,j0,k0), w000)
    np.add.at(rho, (i1,j0,k0), w100)
    np.add.at(rho, (i0,j1,k0), w010)
    np.add.at(rho, (i0,j0,k1), w001)
    np.add.at(rho, (i1,j0,k1), w101)
    np.add.at(rho, (i0,j1,k1), w011)
    np.add.at(rho, (i1,j1,k0), w110)
    np.add.at(rho, (i1,j1,k1), w111)
    return rho

def grad_xyz(F):
    Fx = (np.roll(F,-1,0)-np.roll(F,1,0))/2
    Fy = (np.roll(F,-1,1)-np.roll(F,1,1))/2
    Fz = (np.roll(F,-1,2)-np.roll(F,1,2))/2
    return Fx, Fy, Fz

def trilinear_sample(F, xp, yp, zp):
    i0 = np.floor(xp).astype(int) % N
    j0 = np.floor(yp).astype(int) % N
    k0 = np.floor(zp).astype(int) % N
    i1, j1, k1 = (i0+1)%N, (j0+1)%N, (k0+1)%N
    tx, ty, tz = xp - np.floor(xp), yp - np.floor(yp), zp - np.floor(zp)
    f000, f100 = F[i0,j0,k0], F[i1,j0,k0]
    f010, f001 = F[i0,j1,k0], F[i0,j0,k1]
    f101, f011 = F[i1,j0,k1], F[i0,j1,k1]
    f110, f111 = F[i1,j1,k0], F[i1,j1,k1]
    c00 = f000*(1-tx)+f100*tx
    c01 = f001*(1-tx)+f101*tx
    c10 = f010*(1-tx)+f110*tx
    c11 = f011*(1-tx)+f111*tx
    c0 = c00*(1-ty)+c10*ty
    c1 = c01*(1-ty)+c11*ty
    return c0*(1-tz)+c1*tz

def minimum_image(dx):
    # map displacement to [-N/2, N/2)
    return (dx + N/2) % N - N/2

def radial_profile_from_particles(xp, yp, zp, nbins=24, rmax=None):
    """
    3D radial number-density profile from particle positions using shell volumes.
    Returns r_mid (bin centers), rho (density per shell).
    """
    cx = cy = cz = N/2.0
    dx = minimum_image(xp - cx)
    dy = minimum_image(yp - cy)
    dz = minimum_image(zp - cz)
    r = np.sqrt(dx*dx + dy*dy + dz*dz)
    if rmax is None:
        rmax = N/2.0  # up to half-box
    edges = np.linspace(0.5, rmax, nbins+1)  # start at 0.5 cell to avoid 0
    counts, _ = np.histogram(r, bins=edges)
    # shell volumes in lattice units (approx. spheres)
    r3 = edges**3
    vol = (4.0/3.0)*np.pi*(r3[1:] - r3[:-1])
    rho = counts / np.maximum(vol, 1e-9)
    r_mid = 0.5*(edges[1:] + edges[:-1])
    # avoid zeros for log fits
    rho = np.where(rho <= 0, np.nan, rho)
    return r_mid, rho

def fit_loglog_slope(r, rho, rmin, rmax):
    """Fit slope d log rho / d log r in [rmin, rmax]."""
    mask = (r >= rmin) & (r <= rmax) & np.isfinite(rho) & (rho > 0)
    if mask.sum() < 3:
        return np.nan
    x = np.log(r[mask])
    y = np.log(rho[mask])
    p = np.polyfit(x, y, 1)  # y = p[0]*x + p[1]
    return p[0]  # slope

def classify_core_by_slopes(r, rho, delta_alpha_cut=0.3):
    """
    Compute inner vs outer slopes and return:
      alpha_in, alpha_out, is_core (bool)
    Inner window:   [1.0, 0.25*(N/2)]
    Outer window:   [0.35*(N/2), 0.60*(N/2)]
    """
    R = N/2.0
    alpha_in  = fit_loglog_slope(r, rho, rmin=1.0,        rmax=0.25*R)
    alpha_out = fit_loglog_slope(r, rho, rmin=0.35*R,     rmax=0.60*R)
    if np.isnan(alpha_in) or np.isnan(alpha_out):
        return alpha_in, alpha_out, False
    # Use magnitude comparison: core if outer is noticeably steeper than inner
    delta = abs(alpha_out) - abs(alpha_in)
    return alpha_in, alpha_out, (delta >= delta_alpha_cut)

# ----------------------------
# Core simulation routine
# ----------------------------
def run_one_run(NP_val, Krep_base, v_th_base, D_C_choice, seed=rng_seed):
    rng = np.random.default_rng(seed)
    xp = rng.normal(N/2, 5, NP_val) + rng.normal(0, 2, NP_val)
    yp = rng.normal(N/2, 5, NP_val) + rng.normal(0, 2, NP_val)
    zp = rng.normal(N/2, 5, NP_val) + rng.normal(0, 2, NP_val)
    vx = np.zeros(NP_val); vy = np.zeros(NP_val); vz = np.zeros(NP_val)
    C = np.zeros((N,N,N))
    maxC_history = []

    for step in range(STEPS):
        Krep_step = Krep_base * ((step+1)/STEPS)**alpha
        D_C_step  = D_C_choice * (step/100) if step < 100 else D_C_choice
        v_th_dynamic = v_th_base * (1 + vth_A * np.exp(-step/vth_tau))

        rho = cic_deposit(xp, yp, zp)
        C += DT*(s_src*rho - lam*C + D_C_step*laplacian(C))
        Cx, Cy, Cz = grad_xyz(C)

        ax = mu * trilinear_sample(Cx, xp, yp, zp)
        ay = mu * trilinear_sample(Cy, xp, yp, zp)
        az = mu * trilinear_sample(Cz, xp, yp, zp)

        # short-range repulsion with minimum-image distances
        dx = minimum_image(xp[:,None] - xp[None,:])
        dy = minimum_image(yp[:,None] - yp[None,:])
        dz = minimum_image(zp[:,None] - zp[None,:])
        dist2 = dx*dx + dy*dy + dz*dz
        mask = (dist2 > 0) & (dist2 <= r_rep**2)
        invr = np.zeros_like(dist2)
        invr[mask] = 1.0 / np.sqrt(dist2[mask])
        ax += Krep_step * np.sum(dx * mask * invr, axis=1)
        ay += Krep_step * np.sum(dy * mask * invr, axis=1)
        az += Krep_step * np.sum(dz * mask * invr, axis=1)

        # Thermal kicks
        ax += rng.normal(0, v_th_dynamic, NP_val)
        ay += rng.normal(0, v_th_dynamic, NP_val)
        az += rng.normal(0, v_th_dynamic, NP_val)

        vx += DT * ax; vy += DT * ay; vz += DT * az
        xp = (xp + DT * vx) % N
        yp = (yp + DT * vy) % N
        zp = (zp + DT * vz) % N

        maxC_history.append(C[N//2, N//2, N//2])

    # final radial profile from particle distribution
    r_mid, rho_shell = radial_profile_from_particles(xp, yp, zp, nbins=24)

    return np.max(maxC_history), r_mid, rho_shell

# ----------------------------
# Run sweeps, save data, compute thresholds
# ----------------------------
results = {}          # {(gal, D_C): dict with arrays}
thresholds = {}       # {(gal, D_C): Krep_threshold or np.nan}
slope_tables = {}     # optional: store slopes per Krep for debugging

for D_C_choice in D_C_values:
    print(f"\n=== Running sweep for D_C = {D_C_choice:.4f} ===")
    for gal, NP_val, vth in [("dwarf", NP_dwarf, v_th_dwarf),
                             ("massive", NP_massive, v_th_massive)]:

        maxC_list = []
        all_slopes = []  # list of (Krep, alpha_in, alpha_out, is_core)
        core_found = False
        Krep_threshold = np.nan

        for k in Krep_values:
            Cmax, r_mid, rho_shell = run_one_run(NP_val, k, vth, D_C_choice, seed=rng_seed)
            maxC_list.append(Cmax)
            a_in, a_out, is_core = classify_core_by_slopes(r_mid, rho_shell, delta_alpha_cut=0.3)
            all_slopes.append((k, a_in, a_out, is_core))
            print(f"{gal:7s} D_C={D_C_choice:.3f} Krep={k:.3f}  MaxC={Cmax:.4f}  "
                  f"alpha_in={a_in:.3f} alpha_out={a_out:.3f} core={is_core}")

            if (not core_found) and is_core:
                Krep_threshold = k
                core_found = True

        # Save MaxC vs Krep
        maxC_arr = np.array(maxC_list)
        fname = os.path.join(OUT_DIR, f"{gal}_DC_{D_C_choice:.3f}.txt")
        np.savetxt(fname, np.column_stack([Krep_values, maxC_arr]),
                   header="Krep\tMaxC", fmt="%.6f")
        print(f"Saved table: {fname}")

        # Store results
        results[(gal, D_C_choice)] = {"Krep": Krep_values, "MaxC": maxC_arr}
        thresholds[(gal, D_C_choice)] = Krep_threshold
        slope_tables[(gal, D_C_choice)] = np.array(all_slopes, dtype=float)

# ----------------------------
# Plot: all 6 curves + vertical dotted threshold lines
# ----------------------------
plt.figure(figsize=(10,6))
color_map = {("dwarf"): "tab:blue", ("massive"): "tab:red"}
linestyles = {("dwarf"): "-", ("massive"): "--"}

for gal in ["dwarf", "massive"]:
    for D_C_choice in D_C_values:
        dat = results[(gal, D_C_choice)]
        label = f"{gal.capitalize()} $D_C={D_C_choice:.2f}$"
        plt.plot(dat["Krep"], dat["MaxC"],
                 linestyles[(gal)], marker='o', color=color_map[gal],
                 alpha=0.9, label=label)

        kthr = thresholds[(gal, D_C_choice)]
        if not np.isnan(kthr):
            plt.axvline(kthr, color=color_map[gal], linestyle=":", alpha=0.5)

plt.xlabel(r"Repulsion Strength $K_{\rm rep}$")
plt.ylabel(r"Max Central Curvature (MaxC; proxy for Central Density)")
plt.title("3D Cusp–Core Transitions Across Dwarf and Massive Galaxy Simulations")
plt.grid(True, alpha=0.3)
plt.legend(ncol=2)
plt.tight_layout()
figfile = os.path.join(OUT_DIR, "quick_sweep_summary_with_thresholds.png")
plt.savefig(figfile, dpi=300)
plt.show()
print(f"\nSaved summary figure: {figfile}")

# ----------------------------
# Save thresholds to disk (CSV-like)
# ----------------------------
thr_file = os.path.join(OUT_DIR, "thresholds_by_slope.txt")
with open(thr_file, "w") as f:
    f.write("galaxy,DC,Krep_threshold(Δ|α|≥0.3)\n")
    for gal in ["dwarf", "massive"]:
        for D_C_choice in D_C_values:
            kthr = thresholds[(gal, D_C_choice)]
            f.write(f"{gal},{D_C_choice:.3f},{'' if np.isnan(kthr) else f'{kthr:.3f}'}\n")
print("Saved thresholds:", thr_file)

# (optional) Save the slope diagnostics, one file per (gal, DC)
for gal in ["dwarf", "massive"]:
    for D_C_choice in D_C_values:
        arr = slope_tables[(gal, D_C_choice)]
        fn = os.path.join(OUT_DIR, f"slopes_{gal}_DC_{D_C_choice:.3f}.txt")
        np.savetxt(fn, arr, header="Krep alpha_in alpha_out is_core(0/1)", fmt="%.6f")

#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# quick_3d_sweep_with_thresholds.py
# ------------------------------------------------------------
# 3D Cusp–Core Sweep for Dwarf & Massive Analogs
# ------------------------------------------------------------
# Description:
# - Runs 3D lattice particle simulations for dwarfs & massive galaxies
# - Sweeps over Krep (repulsion) and D_C (diffusion coefficient)
# - Computes MaxC (proxy for central curvature/density) vs Krep
# - Computes radial density profiles and inner/outer log-log slopes
# - Automatically detects core vs cusp transitions using slope differences
# - Saves MaxC tables, slope diagnostics, and thresholds
# - Generates publication-ready figure with all 6 curves + threshold lines
#
# Requirements:
#   numpy, matplotlib, os
#
# Output:
#   - quick_sweep_output/<gal>_DC_<D_C>.txt  (MaxC tables)
#   - quick_sweep_output/slopes_<gal>_DC_<D_C>.txt (slope diagnostics)
#   - quick_sweep_output/thresholds_by_slope.txt
#   - quick_sweep_output/quick_sweep_summary_with_thresholds.png
# ------------------------------------------------------------

import numpy as np
import matplotlib.pyplot as plt
import os

# ----------------------------
# Output
# ----------------------------
OUT_DIR = "quick_sweep_output"
os.makedirs(OUT_DIR, exist_ok=True)

# ----------------------------
# Simulation settings (fast but representative)
# ----------------------------
N = 32
STEPS = 200
DT = 0.05

# Dwarf & Massive particle counts
NP_dwarf = 500
NP_massive = 1000

# Thermal noise (base)
v_th_dwarf = 0.12
v_th_massive = 0.08

# Lattice params
s_src = 2.5
lam = 0.01
mu = 1.0
r_rep = 2

# Sweep parameters
D_C_values = [0.01, 0.02, 0.05]
Krep_values = np.linspace(0.01, 2.0, 15)

# Dynamics knobs
alpha = 0.5        # ramp exponent for Krep_step
vth_A = 5.0        # early noise amplitude multiplier
vth_tau = 50.0     # noise decay timescale
rng_seed = 12345

# ----------------------------
# Helper functions
# ----------------------------
def laplacian(F):
    return (np.roll(F,1,0)+np.roll(F,-1,0)+
            np.roll(F,1,1)+np.roll(F,-1,1)+
            np.roll(F,1,2)+np.roll(F,-1,2) - 6*F)

def cic_deposit(xp, yp, zp):
    rho = np.zeros((N,N,N))
    i0 = np.floor(xp).astype(int) % N
    j0 = np.floor(yp).astype(int) % N
    k0 = np.floor(zp).astype(int) % N
    i1, j1, k1 = (i0+1)%N, (j0+1)%N, (k0+1)%N
    tx, ty, tz = xp - np.floor(xp), yp - np.floor(yp), zp - np.floor(zp)
    w000 = (1-tx)*(1-ty)*(1-tz)
    w100 = tx*(1-ty)*(1-tz)
    w010 = (1-tx)*ty*(1-tz)
    w001 = (1-tx)*(1-ty)*tz
    w101 = tx*(1-ty)*tz
    w011 = (1-tx)*ty*tz
    w110 = tx*ty*(1-tz)
    w111 = tx*ty*tz
    np.add.at(rho, (i0,j0,k0), w000)
    np.add.at(rho, (i1,j0,k0), w100)
    np.add.at(rho, (i0,j1,k0), w010)
    np.add.at(rho, (i0,j0,k1), w001)
    np.add.at(rho, (i1,j0,k1), w101)
    np.add.at(rho, (i0,j1,k1), w011)
    np.add.at(rho, (i1,j1,k0), w110)
    np.add.at(rho, (i1,j1,k1), w111)
    return rho

def grad_xyz(F):
    Fx = (np.roll(F,-1,0)-np.roll(F,1,0))/2
    Fy = (np.roll(F,-1,1)-np.roll(F,1,1))/2
    Fz = (np.roll(F,-1,2)-np.roll(F,1,2))/2
    return Fx, Fy, Fz

def trilinear_sample(F, xp, yp, zp):
    i0 = np.floor(xp).astype(int) % N
    j0 = np.floor(yp).astype(int) % N
    k0 = np.floor(zp).astype(int) % N
    i1, j1, k1 = (i0+1)%N, (j0+1)%N, (k0+1)%N
    tx, ty, tz = xp - np.floor(xp), yp - np.floor(yp), zp - np.floor(zp)
    f000, f100 = F[i0,j0,k0], F[i1,j0,k0]
    f010, f001 = F[i0,j1,k0], F[i0,j0,k1]
    f101, f011 = F[i1,j0,k1], F[i0,j1,k1]
    f110, f111 = F[i1,j1,k0], F[i1,j1,k1]
    c00 = f000*(1-tx)+f100*tx
    c01 = f001*(1-tx)+f101*tx
    c10 = f010*(1-tx)+f110*tx
    c11 = f011*(1-tx)+f111*tx
    c0 = c00*(1-ty)+c10*ty
    c1 = c01*(1-ty)+c11*ty
    return c0*(1-tz)+c1*tz

def minimum_image(dx):
    return (dx + N/2) % N - N/2

def radial_profile_from_particles(xp, yp, zp, nbins=24, rmax=None):
    cx = cy = cz = N/2.0
    dx = minimum_image(xp - cx)
    dy = minimum_image(yp - cy)
    dz = minimum_image(zp - cz)
    r = np.sqrt(dx*dx + dy*dy + dz*dz)
    if rmax is None:
        rmax = N/2.0
    edges = np.linspace(0.5, rmax, nbins+1)
    counts, _ = np.histogram(r, bins=edges)
    r3 = edges**3
    vol = (4.0/3.0)*np.pi*(r3[1:] - r3[:-1])
    rho = counts / np.maximum(vol, 1e-9)
    r_mid = 0.5*(edges[1:] + edges[:-1])
    rho = np.where(rho <= 0, np.nan, rho)
    return r_mid, rho

def fit_loglog_slope(r, rho, rmin, rmax):
    mask = (r >= rmin) & (r <= rmax) & np.isfinite(rho) & (rho > 0)
    if mask.sum() < 3:
        return np.nan
    x = np.log(r[mask])
    y = np.log(rho[mask])
    return np.polyfit(x, y, 1)[0]

def classify_core_by_slopes(r, rho, delta_alpha_cut=0.3):
    R = N/2.0
    alpha_in  = fit_loglog_slope(r, rho, rmin=1.0,        rmax=0.25*R)
    alpha_out = fit_loglog_slope(r, rho, rmin=0.35*R,     rmax=0.60*R)
    if np.isnan(alpha_in) or np.isnan(alpha_out):
        return alpha_in, alpha_out, False
    delta = abs(alpha_out) - abs(alpha_in)
    return alpha_in, alpha_out, (delta >= delta_alpha_cut)

# ----------------------------
# Core simulation routine
# ----------------------------
def run_one_run(NP_val, Krep_base, v_th_base, D_C_choice, seed=rng_seed):
    rng = np.random.default_rng(seed)
    xp = rng.normal(N/2, 5, NP_val) + rng.normal(0, 2, NP_val)
    yp = rng.normal(N/2, 5, NP_val) + rng.normal(0, 2, NP_val)
    zp = rng.normal(N/2, 5, NP_val) + rng.normal(0, 2, NP_val)
    vx = np.zeros(NP_val); vy = np.zeros(NP_val); vz = np.zeros(NP_val)
    C = np.zeros((N,N,N))
    maxC_history = []

    for step in range(STEPS):
        Krep_step = Krep_base * ((step+1)/STEPS)**alpha
        D_C_step  = D_C_choice * (step/100) if step < 100 else D_C_choice
        v_th_dynamic = v_th_base * (1 + vth_A * np.exp(-step/vth_tau))

        rho = cic_deposit(xp, yp, zp)
        C += DT*(s_src*rho - lam*C + D_C_step*laplacian(C))
        Cx, Cy, Cz = grad_xyz(C)

        ax = mu * trilinear_sample(Cx, xp, yp, zp)
        ay = mu * trilinear_sample(Cy, xp, yp, zp)
        az = mu * trilinear_sample(Cz, xp, yp, zp)

        dx = minimum_image(xp[:,None] - xp[None,:])
        dy = minimum_image(yp[:,None] - yp[None,:])
        dz = minimum_image(zp[:,None] - zp[None,:])
        dist2 = dx*dx + dy*dy + dz*dz
        mask = (dist2 > 0) & (dist2 <= r_rep**2)
        invr = np.zeros_like(dist2)
        invr[mask] = 1.0 / np.sqrt(dist2[mask])
        ax += Krep_step * np.sum(dx * mask * invr, axis=1)
        ay += Krep_step * np.sum(dy * mask * invr, axis=1)
        az += Krep_step * np.sum(dz * mask * invr, axis=1)

        ax += rng.normal(0, v_th_dynamic, NP_val)
        ay += rng.normal(0, v_th_dynamic, NP_val)
        az += rng.normal(0, v_th_dynamic, NP_val)

        vx += DT * ax; vy += DT * ay; vz += DT * az
        xp = (xp + DT * vx) % N
        yp = (yp + DT * vy) % N
        zp = (zp + DT * vz) % N

        maxC_history.append(C[N//2, N//2, N//2])

    r_mid, rho_shell = radial_profile_from_particles(xp, yp, zp, nbins=24)
    return np.max(maxC_history), r_mid, rho_shell

# ----------------------------
# Run sweeps, save data, compute thresholds
# ----------------------------
results = {}
thresholds = {}
slope_tables = {}

for D_C_choice in D_C_values:
    print(f"\n=== Running sweep for D_C = {D_C_choice:.4f} ===")
    for gal, NP_val, vth in [("dwarf", NP_dwarf, v_th_dwarf),
                             ("massive", NP_massive, v_th_massive)]:

        maxC_list = []
        all_slopes = []
        core_found = False
        Krep_threshold = np.nan

        for k in Krep_values:
            Cmax, r_mid, rho_shell = run_one_run(NP_val, k, vth, D_C_choice, seed=rng_seed)
            maxC_list.append(Cmax)
            a_in, a_out, is_core = classify_core_by_slopes(r_mid, rho_shell, delta_alpha_cut=0.3)
            all_slopes.append((k, a_in, a_out, is_core))
            print(f"{gal:7s} D_C={D_C_choice:.3f} Krep={k:.3f}  MaxC={Cmax:.4f}  alpha_in={a_in:.3f} alpha_out={a_out:.3f} core={is_core}")

            if (not core_found) and is_core:
                Krep_threshold = k
                core_found = True

        maxC_arr = np.array(maxC_list)
        fname = os.path.join(OUT_DIR, f"{gal}_DC_{D_C_choice:.3f}.txt")
        np.savetxt(fname, np.column_stack([Krep_values, maxC_arr]),
                   header="Krep\tMaxC", fmt="%.6f")
        print(f"Saved table: {fname}")

        results[(gal, D_C_choice)] = {"Krep": Krep_values, "MaxC": maxC_arr}
        thresholds[(gal, D_C_choice)] = Krep_threshold
        slope_tables[(gal, D_C_choice)] = np.array(all_slopes, dtype=float)

# ----------------------------
# Plot all curves + thresholds
# ----------------------------
plt.figure(figsize=(10,6))
color_map = {"dwarf": "tab:blue", "massive": "tab:red"}
linestyles = {"dwarf": "-", "massive": "--"}

for gal in ["dwarf", "massive"]:
    for D_C_choice in D_C_values:
        dat = results[(gal, D_C_choice)]
        label = f"{gal.capitalize()} $D_C={D_C_choice:.2f}$"
        plt.plot(dat["Krep"], dat["MaxC"],
                 linestyles[gal], marker='o', color=color_map[gal],
                 alpha=0.9, label=label)

        kthr = thresholds[(gal, D_C_choice)]
        if not np.isnan(kthr):
            plt.axvline(kthr, color=color_map[gal], linestyle=":", alpha=0.5)

plt.xlabel("Krep (Repulsion)")
plt.ylabel("MaxC (Max Central Curvature/Density)")
plt.title("3D Lattice Sweep: Dwarf versus Massive Analog and Krep (Repulsion)")
plt.grid(True, alpha=0.3)
plt.legend(ncol=2)
plt.tight_layout()
figfile = os.path.join(OUT_DIR, "quick_sweep_summary_with_thresholds.png")
plt.savefig(figfile, dpi=300)
plt.show()
print(f"\nSaved summary figure: {figfile}")

# ----------------------------
# Save thresholds to disk
# ----------------------------
thr_file = os.path.join(OUT_DIR, "thresholds_by_slope.txt")
with open(thr_file, "w") as f:
    f.write("galaxy,DC,Krep_threshold(Δ|α|≥0.3)\n")
    for gal in ["dwarf", "massive"]:
        for D_C_choice in D_C_values:
            kthr = thresholds[(gal, D_C_choice)]
            f.write(f"{gal},{D_C_choice:.3f},{'' if np.isnan(kthr) else f'{kthr:.3f}'}\n")
print("Saved thresholds:", thr_file)

# ----------------------------
# Optional: Save slope diagnostics
# ----------------------------
for gal in ["dwarf", "massive"]:
    for D_C_choice in D_C_values:
        arr = slope_tables[(gal, D_C_choice)]
        fn = os.path.join(OUT_DIR, f"slopes_{gal}_DC_{D_C_choice:.3f}.txt")
        np.savetxt(fn, arr, header="Krep alpha_in alpha_out is_core(0/1)", fmt="%.6f")

#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# quick_3d_sweep_with_thresholds.py
# ------------------------------------------------------------
# 3D Cusp–Core Sweep for Dwarf & Massive Analogs
# ------------------------------------------------------------
# Description:
# - Runs 3D lattice particle simulations for dwarfs & massive galaxies
# - Sweeps over Krep (repulsion) and D_C (diffusion coefficient)
# - Computes MaxC (proxy for central curvature/density) vs Krep
# - Computes radial density profiles and inner/outer log-log slopes
# - Automatically detects core vs cusp transitions using slope differences
# - Saves MaxC tables, slope diagnostics, and thresholds
# - Generates publication-ready figure with all 6 curves + horizontal threshold lines
#
# Requirements:
#   numpy, matplotlib, os
#
# Output:
#   - quick_sweep_output/<gal>_DC_<D_C>.txt  (MaxC tables)
#   - quick_sweep_output/slopes_<gal>_DC_<D_C>.txt (slope diagnostics)
#   - quick_sweep_output/thresholds_by_slope.txt
#   - quick_sweep_output/quick_sweep_summary_with_thresholds.png
# ------------------------------------------------------------

import numpy as np
import matplotlib.pyplot as plt
import os

# ----------------------------
# Output
# ----------------------------
OUT_DIR = "quick_sweep_output"
os.makedirs(OUT_DIR, exist_ok=True)

# ----------------------------
# Simulation settings (fast but representative)
# ----------------------------
N = 32
STEPS = 200
DT = 0.05

# Dwarf & Massive particle counts
NP_dwarf = 500
NP_massive = 1000

# Thermal noise (base)
v_th_dwarf = 0.12
v_th_massive = 0.08

# Lattice params
s_src = 2.5
lam = 0.01
mu = 1.0
r_rep = 2

# Sweep parameters
D_C_values = [0.01, 0.02, 0.05]
Krep_values = np.linspace(0.01, 2.0, 15)

# Dynamics knobs
alpha = 0.5        # ramp exponent for Krep_step
vth_A = 5.0        # early noise amplitude multiplier
vth_tau = 50.0     # noise decay timescale
rng_seed = 12345

# ----------------------------
# Helper functions
# ----------------------------
def laplacian(F):
    return (np.roll(F,1,0)+np.roll(F,-1,0)+
            np.roll(F,1,1)+np.roll(F,-1,1)+
            np.roll(F,1,2)+np.roll(F,-1,2) - 6*F)

def cic_deposit(xp, yp, zp):
    rho = np.zeros((N,N,N))
    i0 = np.floor(xp).astype(int) % N
    j0 = np.floor(yp).astype(int) % N
    k0 = np.floor(zp).astype(int) % N
    i1, j1, k1 = (i0+1)%N, (j0+1)%N, (k0+1)%N
    tx, ty, tz = xp - np.floor(xp), yp - np.floor(yp), zp - np.floor(zp)
    w000 = (1-tx)*(1-ty)*(1-tz)
    w100 = tx*(1-ty)*(1-tz)
    w010 = (1-tx)*ty*(1-tz)
    w001 = (1-tx)*(1-ty)*tz
    w101 = tx*(1-ty)*tz
    w011 = (1-tx)*ty*tz
    w110 = tx*ty*(1-tz)
    w111 = tx*ty*tz
    np.add.at(rho, (i0,j0,k0), w000)
    np.add.at(rho, (i1,j0,k0), w100)
    np.add.at(rho, (i0,j1,k0), w010)
    np.add.at(rho, (i0,j0,k1), w001)
    np.add.at(rho, (i1,j0,k1), w101)
    np.add.at(rho, (i0,j1,k1), w011)
    np.add.at(rho, (i1,j1,k0), w110)
    np.add.at(rho, (i1,j1,k1), w111)
    return rho

def grad_xyz(F):
    Fx = (np.roll(F,-1,0)-np.roll(F,1,0))/2
    Fy = (np.roll(F,-1,1)-np.roll(F,1,1))/2
    Fz = (np.roll(F,-1,2)-np.roll(F,1,2))/2
    return Fx, Fy, Fz

def trilinear_sample(F, xp, yp, zp):
    i0 = np.floor(xp).astype(int) % N
    j0 = np.floor(yp).astype(int) % N
    k0 = np.floor(zp).astype(int) % N
    i1, j1, k1 = (i0+1)%N, (j0+1)%N, (k0+1)%N
    tx, ty, tz = xp - np.floor(xp), yp - np.floor(yp), zp - np.floor(zp)
    f000, f100 = F[i0,j0,k0], F[i1,j0,k0]
    f010, f001 = F[i0,j1,k0], F[i0,j0,k1]
    f101, f011 = F[i1,j0,k1], F[i0,j1,k1]
    f110, f111 = F[i1,j1,k0], F[i1,j1,k1]
    c00 = f000*(1-tx)+f100*tx
    c01 = f001*(1-tx)+f101*tx
    c10 = f010*(1-tx)+f110*tx
    c11 = f011*(1-tx)+f111*tx
    c0 = c00*(1-ty)+c10*ty
    c1 = c01*(1-ty)+c11*ty
    return c0*(1-tz)+c1*tz

def minimum_image(dx):
    return (dx + N/2) % N - N/2

def radial_profile_from_particles(xp, yp, zp, nbins=24, rmax=None):
    cx = cy = cz = N/2.0
    dx = minimum_image(xp - cx)
    dy = minimum_image(yp - cy)
    dz = minimum_image(zp - cz)
    r = np.sqrt(dx*dx + dy*dy + dz*dz)
    if rmax is None:
        rmax = N/2.0
    edges = np.linspace(0.5, rmax, nbins+1)
    counts, _ = np.histogram(r, bins=edges)
    r3 = edges**3
    vol = (4.0/3.0)*np.pi*(r3[1:] - r3[:-1])
    rho = counts / np.maximum(vol, 1e-9)
    r_mid = 0.5*(edges[1:] + edges[:-1])
    rho = np.where(rho <= 0, np.nan, rho)
    return r_mid, rho

def fit_loglog_slope(r, rho, rmin, rmax):
    mask = (r >= rmin) & (r <= rmax) & np.isfinite(rho) & (rho > 0)
    if mask.sum() < 3:
        return np.nan
    x = np.log(r[mask])
    y = np.log(rho[mask])
    return np.polyfit(x, y, 1)[0]

def classify_core_by_slopes(r, rho, delta_alpha_cut=0.3):
    R = N/2.0
    alpha_in  = fit_loglog_slope(r, rho, rmin=1.0,        rmax=0.25*R)
    alpha_out = fit_loglog_slope(r, rho, rmin=0.35*R,     rmax=0.60*R)
    if np.isnan(alpha_in) or np.isnan(alpha_out):
        return alpha_in, alpha_out, False
    delta = abs(alpha_out) - abs(alpha_in)
    return alpha_in, alpha_out, (delta >= delta_alpha_cut)

# ----------------------------
# Core simulation routine
# ----------------------------
def run_one_run(NP_val, Krep_base, v_th_base, D_C_choice, seed=rng_seed):
    rng = np.random.default_rng(seed)
    xp = rng.normal(N/2, 5, NP_val) + rng.normal(0, 2, NP_val)
    yp = rng.normal(N/2, 5, NP_val) + rng.normal(0, 2, NP_val)
    zp = rng.normal(N/2, 5, NP_val) + rng.normal(0, 2, NP_val)
    vx = np.zeros(NP_val); vy = np.zeros(NP_val); vz = np.zeros(NP_val)
    C = np.zeros((N,N,N))
    maxC_history = []

    for step in range(STEPS):
        Krep_step = Krep_base * ((step+1)/STEPS)**alpha
        D_C_step  = D_C_choice * (step/100) if step < 100 else D_C_choice
        v_th_dynamic = v_th_base * (1 + vth_A * np.exp(-step/vth_tau))

        rho = cic_deposit(xp, yp, zp)
        C += DT*(s_src*rho - lam*C + D_C_step*laplacian(C))
        Cx, Cy, Cz = grad_xyz(C)

        ax = mu * trilinear_sample(Cx, xp, yp, zp)
        ay = mu * trilinear_sample(Cy, xp, yp, zp)
        az = mu * trilinear_sample(Cz, xp, yp, zp)

#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# quick_3d_sweep_with_thresholds.py
# ------------------------------------------------------------
# 3D Cusp–Core Sweep for Dwarf & Massive Analogs
# ------------------------------------------------------------
# Description:
# - Runs 3D lattice particle simulations for dwarfs & massive galaxies
# - Sweeps over Krep (repulsion) and D_C (diffusion coefficient)
# - Computes MaxC (proxy for central curvature/density) vs Krep
# - Computes radial density profiles and inner/outer log-log slopes
# - Automatically detects core vs cusp transitions using slope differences
# - Saves MaxC tables, slope diagnostics, and thresholds
# - Generates publication-ready figure with all 6 curves + horizontal threshold lines
#
# Requirements:
#   numpy, matplotlib, os
#
# Output:
#   - quick_sweep_output/<gal>_DC_<D_C>.txt  (MaxC tables)
#   - quick_sweep_output/slopes_<gal>_DC_<D_C>.txt (slope diagnostics)
#   - quick_sweep_output/thresholds_by_slope.txt
#   - quick_sweep_output/quick_sweep_summary_with_thresholds.png
# ------------------------------------------------------------

import numpy as np
import matplotlib.pyplot as plt
import os

# ----------------------------
# Output
# ----------------------------
OUT_DIR = "quick_sweep_output"
os.makedirs(OUT_DIR, exist_ok=True)

# ----------------------------
# Simulation settings (fast but representative)
# ----------------------------
N = 32
STEPS = 200
DT = 0.05

# Dwarf & Massive particle counts
NP_dwarf = 500
NP_massive = 1000

# Thermal noise (base)
v_th_dwarf = 0.12
v_th_massive = 0.08

# Lattice params
s_src = 2.5
lam = 0.01
mu = 1.0
r_rep = 2

# Sweep parameters
D_C_values = [0.01, 0.02, 0.05]
Krep_values = np.linspace(0.01, 2.0, 15)

# Dynamics knobs
alpha = 0.5        # ramp exponent for Krep_step
vth_A = 5.0        # early noise amplitude multiplier
vth_tau = 50.0     # noise decay timescale
rng_seed = 12345

# ----------------------------
# Helper functions
# ----------------------------
def laplacian(F):
    return (np.roll(F,1,0)+np.roll(F,-1,0)+
            np.roll(F,1,1)+np.roll(F,-1,1)+
            np.roll(F,1,2)+np.roll(F,-1,2) - 6*F)

def cic_deposit(xp, yp, zp):
    rho = np.zeros((N,N,N))
    i0 = np.floor(xp).astype(int) % N
    j0 = np.floor(yp).astype(int) % N
    k0 = np.floor(zp).astype(int) % N
    i1, j1, k1 = (i0+1)%N, (j0+1)%N, (k0+1)%N
    tx, ty, tz = xp - np.floor(xp), yp - np.floor(yp), zp - np.floor(zp)
    w000 = (1-tx)*(1-ty)*(1-tz)
    w100 = tx*(1-ty)*(1-tz)
    w010 = (1-tx)*ty*(1-tz)
    w001 = (1-tx)*(1-ty)*tz
    w101 = tx*(1-ty)*tz
    w011 = (1-tx)*ty*tz
    w110 = tx*ty*(1-tz)
    w111 = tx*ty*tz
    np.add.at(rho, (i0,j0,k0), w000)
    np.add.at(rho, (i1,j0,k0), w100)
    np.add.at(rho, (i0,j1,k0), w010)
    np.add.at(rho, (i0,j0,k1), w001)
    np.add.at(rho, (i1,j0,k1), w101)
    np.add.at(rho, (i0,j1,k1), w011)
    np.add.at(rho, (i1,j1,k0), w110)
    np.add.at(rho, (i1,j1,k1), w111)
    return rho

def grad_xyz(F):
    Fx = (np.roll(F,-1,0)-np.roll(F,1,0))/2
    Fy = (np.roll(F,-1,1)-np.roll(F,1,1))/2
    Fz = (np.roll(F,-1,2)-np.roll(F,1,2))/2
    return Fx, Fy, Fz

def trilinear_sample(F, xp, yp, zp):
    i0 = np.floor(xp).astype(int) % N
    j0 = np.floor(yp).astype(int) % N
    k0 = np.floor(zp).astype(int) % N
    i1, j1, k1 = (i0+1)%N, (j0+1)%N, (k0+1)%N
    tx, ty, tz = xp - np.floor(xp), yp - np.floor(yp), zp - np.floor(zp)
    f000, f100 = F[i0,j0,k0], F[i1,j0,k0]
    f010, f001 = F[i0,j1,k0], F[i0,j0,k1]
    f101, f011 = F[i1,j0,k1], F[i0,j1,k1]
    f110, f111 = F[i1,j1,k0], F[i1,j1,k1]
    c00 = f000*(1-tx)+f100*tx
    c01 = f001*(1-tx)+f101*tx
    c10 = f010*(1-tx)+f110*tx
    c11 = f011*(1-tx)+f111*tx
    c0 = c00*(1-ty)+c10*ty
    c1 = c01*(1-ty)+c11*ty
    return c0*(1-tz)+c1*tz

def minimum_image(dx):
    return (dx + N/2) % N - N/2

def radial_profile_from_particles(xp, yp, zp, nbins=24, rmax=None):
    cx = cy = cz = N/2.0
    dx = minimum_image(xp - cx)
    dy = minimum_image(yp - cy)
    dz = minimum_image(zp - cz)
    r = np.sqrt(dx*dx + dy*dy + dz*dz)
    if rmax is None:
        rmax = N/2.0
    edges = np.linspace(0.5, rmax, nbins+1)
    counts, _ = np.histogram(r, bins=edges)
    r3 = edges**3
    vol = (4.0/3.0)*np.pi*(r3[1:] - r3[:-1])
    rho = counts / np.maximum(vol, 1e-9)
    r_mid = 0.5*(edges[1:] + edges[:-1])
    rho = np.where(rho <= 0, np.nan, rho)
    return r_mid, rho

def fit_loglog_slope(r, rho, rmin, rmax):
    mask = (r >= rmin) & (r <= rmax) & np.isfinite(rho) & (rho > 0)
    if mask.sum() < 3:
        return np.nan
    x = np.log(r[mask])
    y = np.log(rho[mask])
    return np.polyfit(x, y, 1)[0]

def classify_core_by_slopes(r, rho, delta_alpha_cut=0.3):
    R = N/2.0
    alpha_in  = fit_loglog_slope(r, rho, rmin=1.0,        rmax=0.25*R)
    alpha_out = fit_loglog_slope(r, rho, rmin=0.35*R,     rmax=0.60*R)
    if np.isnan(alpha_in) or np.isnan(alpha_out):
        return alpha_in, alpha_out, False
    delta = abs(alpha_out) - abs(alpha_in)
    return alpha_in, alpha_out, (delta >= delta_alpha_cut)

# ----------------------------
# Core simulation routine
# ----------------------------
def run_one_run(NP_val, Krep_base, v_th_base, D_C_choice, seed=rng_seed):
    rng = np.random.default_rng(seed)
    xp = rng.normal(N/2, 5, NP_val) + rng.normal(0, 2, NP_val)
    yp = rng.normal(N/2, 5, NP_val) + rng.normal(0, 2, NP_val)
    zp = rng.normal(N/2, 5, NP_val) + rng.normal(0, 2, NP_val)
    vx = np.zeros(NP_val); vy = np.zeros(NP_val); vz = np.zeros(NP_val)
    C = np.zeros((N,N,N))
    maxC_history = []

    for step in range(STEPS):
        Krep_step = Krep_base * ((step+1)/STEPS)**alpha
        D_C_step  = D_C_choice * (step/100) if step < 100 else D_C_choice
        v_th_dynamic = v_th_base * (1 + vth_A * np.exp(-step/vth_tau))

        rho = cic_deposit(xp, yp, zp)
        C += DT*(s_src*rho - lam*C + D_C_step*laplacian(C))
        Cx, Cy, Cz = grad_xyz(C)

        ax = mu * trilinear_sample(Cx, xp, yp, zp)
        ay = mu * trilinear_sample(Cy, xp, yp, zp)
        az = mu * trilinear_sample(Cz, xp, yp, zp)

        dx = minimum_image(xp[:,None] - xp[None,:])
        dy = minimum_image(yp[:,None] - yp[None,:])
        dz = minimum_image(zp[:,None] - zp[None,:])
        dist2 = dx*dx + dy*dy + dz*dz
        mask = (dist2 > 0) & (dist2 <= r_rep**2)
        invr = np.zeros_like(dist2)
        invr[mask] = 1.0 / np.sqrt(dist2[mask])
        ax += Krep_step * np.sum(dx * mask * invr, axis=1)
        ay += Krep_step * np.sum(dy * mask * invr, axis=1)
        az += Krep_step * np.sum(dz * mask * invr, axis=1)

        ax += rng.normal(0, v_th_dynamic, NP_val)
        ay += rng.normal(0, v_th_dynamic, NP_val)
        az += rng.normal(0, v_th_dynamic, NP_val)

        vx += DT * ax; vy += DT * ay; vz += DT * az
        xp = (xp + DT * vx) % N
        yp = (yp + DT * vy) % N
        zp = (zp + DT * vz) % N

        maxC_history.append(C[N//2, N//2, N//2])

    r_mid, rho_shell = radial_profile_from_particles(xp, yp, zp, nbins=24)
    return np.max(maxC_history), r_mid, rho_shell

# ----------------------------
# Run sweeps, save data, compute thresholds
# ----------------------------
results = {}
thresholds = {}
slope_tables = {}

for D_C_choice in D_C_values:
    print(f"\n=== Running sweep for D_C = {D_C_choice:.4f} ===")
    for gal, NP_val, vth in [("dwarf", NP_dwarf, v_th_dwarf),
                             ("massive", NP_massive, v_th_massive)]:

        maxC_list = []
        all_slopes = []
        core_found = False
        Krep_threshold = np.nan

        for k in Krep_values:
            Cmax, r_mid, rho_shell = run_one_run(NP_val, k, vth, D_C_choice, seed=rng_seed)
            maxC_list.append(Cmax)
            a_in, a_out, is_core = classify_core_by_slopes(r_mid, rho_shell, delta_alpha_cut=0.3)
            all_slopes.append((k, a_in, a_out, is_core))
            print(f"{gal:7s} D_C={D_C_choice:.3f} Krep={k:.3f}  MaxC={Cmax:.4f}  alpha_in={a_in:.3f} alpha_out={a_out:.3f} core={is_core}")

            if (not core_found) and is_core:
                Krep_threshold = k
                core_found = True

        maxC_arr = np.array(maxC_list)
        fname = os.path.join(OUT_DIR, f"{gal}_DC_{D_C_choice:.3f}.txt")
        np.savetxt(fname, np.column_stack([Krep_values, maxC_arr]),
                   header="Krep\tMaxC", fmt="%.6f")
        print(f"Saved table: {fname}")

        results[(gal, D_C_choice)] = {"Krep": Krep_values, "MaxC": maxC_arr}
        thresholds[(gal, D_C_choice)] = Krep_threshold
        slope_tables[(gal, D_C_choice)] = np.array(all_slopes, dtype=float)

# ----------------------------
# Plot all curves + horizontal thresholds
# ----------------------------
plt.figure(figsize=(10,6))
color_map = {"dwarf": "tab:blue", "massive": "tab:red"}
linestyles = {"dwarf": "-", "massive": "--"}

for gal in ["dwarf", "massive"]:
    for D_C_choice in D_C_values:
        dat = results[(gal, D_C_choice)]
        label = f"{gal.capitalize()} $D_C={D_C_choice:.2f}$"
        plt.plot(dat["Krep"], dat["MaxC"],
                 linestyles[gal], marker='o', color=color_map[gal],
                 alpha=0.9, label=label)

        kthr = thresholds[(gal, D_C_choice)]
        if not np.isnan(kthr):
            plt.axhline(kthr, color=color_map[gal], linestyle=":", alpha=0.5,
                        label=f"{gal.capitalize()} threshold Δ|α|≥0.3")

plt.xlabel("Krep (Repulsion)")
plt.ylabel("MaxC (Max Central Curvature/Density)")
plt.title("Effect of Repulsion and Curvature Diffusion on Central Density in 3D Lattice Simulations")
plt.grid(True, alpha=0.3)
plt.legend(ncol=2)
plt.tight_layout()
figfile = os.path.join(OUT_DIR, "quick_sweep_summary_with_thresholds.png")
plt.savefig(figfile, dpi=300)
plt.show()
print(f"\nSaved summary figure: {figfile}")

# ----------------------------
# Save thresholds to disk
# ----------------------------
thr_file = os.path.join(OUT_DIR, "thresholds_by_slope.txt")
with open(thr_file, "w") as f:
    f.write("galaxy,DC,Krep_threshold(Δ|α|≥0.3)\n")
    for gal in ["dwarf", "massive"]:
        for D_C_choice in D_C_values:
            kthr = thresholds[(gal, D_C_choice)]
            f.write(f"{gal},{D_C_choice:.3f},{'' if np.isnan(kthr) else f'{kthr:.3f}'}\n")
print("Saved thresholds:", thr_file)

# ----------------------------
# Optional: Save slope diagnostics
# ----------------------------
for gal in ["dwarf", "massive"]:
    for D_C_choice in D_C_values:
        arr = slope_tables[(gal, D_C_choice)]
        fn = os.path.join(OUT_DIR, f"slopes_{gal}_DC_{D_C_choice:.3f}.txt")
        np.savetxt(fn, arr, header="Krep alpha_in alpha_out is_core(0/1)", fmt="%.6f")

#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# quick_3d_sweep_with_thresholds.py
# ------------------------------------------------------------
# 3D Lattice Sweep for Dwarf & Massive Analogs
# ------------------------------------------------------------
# Description:
# - Runs 3D lattice particle simulations for dwarfs & massive galaxies
# - Sweeps over Krep (repulsion) and D_C (diffusion coefficient)
# - Computes MaxC (proxy for central curvature/density) vs Krep
# - Computes radial density profiles and inner/outer log-log slopes
# - Automatically detects core vs cusp transitions using slope differences + MaxC
# - Saves MaxC tables, slope diagnostics, and thresholds
# - Generates publication-ready figure with all curves + horizontal threshold lines
#
# Requirements:
#   numpy, matplotlib, os
#
# Output:
#   - quick_sweep_output/<gal>_DC_<D_C>.txt  (MaxC tables)
#   - quick_sweep_output/slopes_<gal>_DC_<D_C>.txt (slope diagnostics)
#   - quick_sweep_output/thresholds_by_slope.txt
#   - quick_sweep_output/quick_sweep_summary_with_thresholds.png
# ------------------------------------------------------------

import numpy as np
import matplotlib.pyplot as plt
import os

# ----------------------------
# Output
# ----------------------------
OUT_DIR = "quick_sweep_output"
os.makedirs(OUT_DIR, exist_ok=True)

# ----------------------------
# Simulation settings
# ----------------------------
N = 32
STEPS = 200
DT = 0.05

# Dwarf & Massive particle counts
NP_dwarf = 500
NP_massive = 1000

# Thermal noise (base)
v_th_dwarf = 0.12
v_th_massive = 0.08

# Lattice params
s_src = 2.5
lam = 0.01
mu = 1.0
r_rep = 2

# Sweep parameters
D_C_values = [0.01, 0.02, 0.05]
Krep_values = np.linspace(0.01, 2.0, 15)

# Dynamics knobs
alpha = 0.5        # ramp exponent for Krep_step
vth_A = 5.0        # early noise amplitude multiplier
vth_tau = 50.0     # noise decay timescale
rng_seed = 12345

# ----------------------------
# Helper functions
# ----------------------------
def laplacian(F):
    return (np.roll(F,1,0)+np.roll(F,-1,0)+
            np.roll(F,1,1)+np.roll(F,-1,1)+
            np.roll(F,1,2)+np.roll(F,-1,2) - 6*F)

def cic_deposit(xp, yp, zp):
    rho = np.zeros((N,N,N))
    i0 = np.floor(xp).astype(int) % N
    j0 = np.floor(yp).astype(int) % N
    k0 = np.floor(zp).astype(int) % N
    i1, j1, k1 = (i0+1)%N, (j0+1)%N, (k0+1)%N
    tx, ty, tz = xp - np.floor(xp), yp - np.floor(yp), zp - np.floor(zp)
    w000 = (1-tx)*(1-ty)*(1-tz)
    w100 = tx*(1-ty)*(1-tz)
    w010 = (1-tx)*ty*(1-tz)
    w001 = (1-tx)*(1-ty)*tz
    w101 = tx*(1-ty)*tz
    w011 = (1-tx)*ty*tz
    w110 = tx*ty*(1-tz)
    w111 = tx*ty*tz
    np.add.at(rho, (i0,j0,k0), w000)
    np.add.at(rho, (i1,j0,k0), w100)
    np.add.at(rho, (i0,j1,k0), w010)
    np.add.at(rho, (i0,j0,k1), w001)
    np.add.at(rho, (i1,j0,k1), w101)
    np.add.at(rho, (i0,j1,k1), w011)
    np.add.at(rho, (i1,j1,k0), w110)
    np.add.at(rho, (i1,j1,k1), w111)
    return rho

def grad_xyz(F):
    Fx = (np.roll(F,-1,0)-np.roll(F,1,0))/2
    Fy = (np.roll(F,-1,1)-np.roll(F,1,1))/2
    Fz = (np.roll(F,-1,2)-np.roll(F,1,2))/2
    return Fx, Fy, Fz

def trilinear_sample(F, xp, yp, zp):
    i0 = np.floor(xp).astype(int) % N
    j0 = np.floor(yp).astype(int) % N
    k0 = np.floor(zp).astype(int) % N
    i1, j1, k1 = (i0+1)%N, (j0+1)%N, (k0+1)%N
    tx, ty, tz = xp - np.floor(xp), yp - np.floor(yp), zp - np.floor(zp)
    f000, f100 = F[i0,j0,k0], F[i1,j0,k0]
    f010, f001 = F[i0,j1,k0], F[i0,j0,k1]
    f101, f011 = F[i1,j0,k1], F[i0,j1,k1]
    f110, f111 = F[i1,j1,k0], F[i1,j1,k1]
    c00 = f000*(1-tx)+f100*tx
    c01 = f001*(1-tx)+f101*tx
    c10 = f010*(1-tx)+f110*tx
    c11 = f011*(1-tx)+f111*tx
    c0 = c00*(1-ty)+c10*ty
    c1 = c01*(1-ty)+c11*ty
    return c0*(1-tz)+c1*tz

def minimum_image(dx):
    return (dx + N/2) % N - N/2

def radial_profile_from_particles(xp, yp, zp, nbins=24, rmax=None):
    cx = cy = cz = N/2.0
    dx = minimum_image(xp - cx)
    dy = minimum_image(yp - cy)
    dz = minimum_image(zp - cz)
    r = np.sqrt(dx*dx + dy*dy + dz*dz)
    if rmax is None:
        rmax = N/2.0
    edges = np.linspace(0.5, rmax, nbins+1)
    counts, _ = np.histogram(r, bins=edges)
    r3 = edges**3
    vol = (4.0/3.0)*np.pi*(r3[1:] - r3[:-1])
    rho = counts / np.maximum(vol, 1e-9)
    r_mid = 0.5*(edges[1:] + edges[:-1])
    rho = np.where(rho <= 0, np.nan, rho)
    return r_mid, rho

def fit_loglog_slope(r, rho, rmin, rmax):
    mask = (r >= rmin) & (r <= rmax) & np.isfinite(rho) & (rho > 0)
    if mask.sum() < 3:
        return np.nan
    x = np.log(r[mask])
    y = np.log(

#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# quick_3d_sweep_with_horizontal_thresholds.py
# ------------------------------------------------------------
# 3D Cusp–Core Sweep for Dwarf & Massive Analogs
# ------------------------------------------------------------
# Description:
# - Runs 3D lattice particle simulations for dwarfs & massive galaxies
# - Sweeps over Krep (repulsion) and D_C (diffusion coefficient)
# - Computes MaxC (proxy for central curvature/density) vs Krep
# - Computes radial density profiles and inner/outer log-log slopes
# - Determines slope-based horizontal threshold lines for MaxC
# - Saves MaxC tables and generates publication-ready figure
#
# Requirements:
#   numpy, matplotlib, os
#
# Output:
#   - quick_sweep_output/<gal>_DC_<D_C>.txt  (MaxC tables)
#   - quick_sweep_output/quick_sweep_summary_with_thresholds.png
# ------------------------------------------------------------

import numpy as np
import matplotlib.pyplot as plt
import os

# ----------------------------
# Output
# ----------------------------
OUT_DIR = "quick_sweep_output"
os.makedirs(OUT_DIR, exist_ok=True)

# ----------------------------
# Simulation settings (fast but representative)
# ----------------------------
N = 32
STEPS = 200
DT = 0.05

# Dwarf & Massive particle counts
NP_dwarf = 500
NP_massive = 1000

# Thermal noise (base)
v_th_dwarf = 0.12
v_th_massive = 0.08

# Lattice params
s_src = 2.5
lam = 0.01
mu = 1.0
r_rep = 2

# Sweep parameters
D_C_values = [0.01, 0.02, 0.05]
Krep_values = np.linspace(0.01, 2.0, 15)

# Dynamics knobs
alpha = 0.5        # ramp exponent for Krep_step
vth_A = 5.0        # early noise amplitude multiplier
vth_tau = 50.0     # noise decay timescale
rng_seed = 12345

# ----------------------------
# Helper functions
# ----------------------------
def laplacian(F):
    return (np.roll(F,1,0)+np.roll(F,-1,0)+
            np.roll(F,1,1)+np.roll(F,-1,1)+
            np.roll(F,1,2)+np.roll(F,-1,2) - 6*F)

def cic_deposit(xp, yp, zp):
    rho = np.zeros((N,N,N))
    i0 = np.floor(xp).astype(int) % N
    j0 = np.floor(yp).astype(int) % N
    k0 = np.floor(zp).astype(int) % N
    i1, j1, k1 = (i0+1)%N, (j0+1)%N, (k0+1)%N
    tx, ty, tz = xp - np.floor(xp), yp - np.floor(yp), zp - np.floor(zp)
    w000 = (1-tx)*(1-ty)*(1-tz)
    w100 = tx*(1-ty)*(1-tz)
    w010 = (1-tx)*ty*(1-tz)
    w001 = (1-tx)*(1-ty)*tz
    w101 = tx*(1-ty)*tz
    w011 = (1-tx)*ty*tz
    w110 = tx*ty*(1-tz)
    w111 = tx*ty*tz
    np.add.at(rho, (i0,j0,k0), w000)
    np.add.at(rho, (i1,j0,k0), w100)
    np.add.at(rho, (i0,j1,k0), w010)
    np.add.at(rho, (i0,j0,k1), w001)
    np.add.at(rho, (i1,j0,k1), w101)
    np.add.at(rho, (i0,j1,k1), w011)
    np.add.at(rho, (i1,j1,k0), w110)
    np.add.at(rho, (i1,j1,k1), w111)
    return rho

def grad_xyz(F):
    Fx = (np.roll(F,-1,0)-np.roll(F,1,0))/2
    Fy = (np.roll(F,-1,1)-np.roll(F,1,1))/2
    Fz = (np.roll(F,-1,2)-np.roll(F,1,2))/2
    return Fx, Fy, Fz

def trilinear_sample(F, xp, yp, zp):
    i0 = np.floor(xp).astype(int) % N
    j0 = np.floor(yp).astype(int) % N
    k0 = np.floor(zp).astype(int) % N
    i1, j1, k1 = (i0+1)%N, (j0+1)%N, (k0+1)%N
    tx, ty, tz = xp - np.floor(xp), yp - np.floor(yp), zp - np.floor(zp)
    f000, f100 = F[i0,j0,k0], F[i1,j0,k0]
    f010, f001 = F[i0,j1,k0], F[i0,j0,k1]
    f101, f011 = F[i1,j0,k1], F[i0,j1,k1]
    f110, f111 = F[i1,j1,k0], F[i1,j1,k1]
    c00 = f000*(1-tx)+f100*tx
    c01 = f001*(1-tx)+f101*tx
    c10 = f010*(1-tx)+f110*tx
    c11 = f011*(1-tx)+f111*tx
    c0 = c00*(1-ty)+c10*ty
    c1 = c01*(1-ty)+c11*ty
    return c0*(1-tz)+c1*tz

def minimum_image(dx):
    return (dx + N/2) % N - N/2

def radial_profile_from_particles(xp, yp, zp, nbins=24, rmax=None):
    cx = cy = cz = N/2.0
    dx = minimum_image(xp - cx)
    dy = minimum_image(yp - cy)
    dz = minimum_image(zp - cz)
    r = np.sqrt(dx*dx + dy*dy + dz*dz)
    if rmax is None:
        rmax = N/2.0
    edges = np.linspace(0.5, rmax, nbins+1)
    counts, _ = np.histogram(r, bins=edges)
    r3 = edges**3
    vol = (4.0/3.0)*np.pi*(r3[1:] - r3[:-1])
    rho = counts / np.maximum(vol, 1e-9)
    r_mid = 0.5*(edges[1:] + edges[:-1])
    rho = np.where(rho <= 0, np.nan, rho)
    return r_mid, rho

def fit_loglog_slope(r, rho, rmin, rmax):
    mask = (r >= rmin) & (r <= rmax) & np.isfinite(rho) & (rho > 0)
    if mask.sum() < 3:
        return np.nan
    x = np.log(r[mask])
    y = np.log(rho[mask])
    return np.polyfit(x, y, 1)[0]

def compute_threshold(r, rho, delta_alpha_cut=0.3):
    a_in  = fit_loglog_slope(r, rho, rmin=1.0, rmax=0.25*N/2)
    a_out = fit_loglog_slope(r, rho, rmin=0.35*N/2, rmax=0.60*N/2)
    if np.isnan(a_in) or np.isnan(a_out):
        return np.nan
    delta = abs(a_out) - abs(a_in)
    return np.nan if delta < delta_alpha_cut else np.max(rho)

def run_one_run(NP_val, Krep_base, v_th_base, D_C_choice, seed=rng_seed):
    rng = np.random.default_rng(seed)
    xp = rng.normal(N/2, 5, NP_val) + rng.normal(0, 2, NP_val)
    yp = rng.normal(N/2, 5, NP_val) + rng.normal(0, 2, NP_val)
    zp = rng.normal(N/2, 5, NP_val) + rng.normal(0, 2, NP_val)
    vx = np.zeros(NP_val); vy = np.zeros(NP_val); vz = np.zeros(NP_val)
    C = np.zeros((N,N,N))
    maxC_history = []

    for step in range(STEPS):
        Krep_step = Krep_base * ((step+1)/STEPS)**alpha
        D_C_step  = D_C_choice * (step/100) if step < 100 else D_C_choice
        v_th_dynamic = v_th_base * (1 + 5*np.exp(-step/50))

        rho = cic_deposit(xp, yp, zp)
        C += DT*(s_src*rho - lam*C + D_C_step*laplacian(C))
        Cx, Cy, Cz = grad_xyz(C)

        ax = mu * trilinear_sample(Cx, xp, yp, zp)
        ay = mu * trilinear_sample(Cy, xp, yp, zp)
        az = mu * trilinear_sample(Cz, xp, yp, zp)

        dx = minimum_image(xp[:,None] - xp[None,:])
        dy = minimum_image(yp[:,None] - yp[None,:])
        dz = minimum_image(zp[:,None] - zp[None,:])
        dist2 = dx*dx + dy*dy + dz*dz
        mask = (dist2 > 0) & (dist2 <= r_rep**2)
        invr = np.zeros_like(dist2)
        invr[mask] = 1.0 / np.sqrt(dist2[mask])
        ax += Krep_step * np.sum(dx * mask * invr, axis=1)
        ay += Krep_step * np.sum(dy * mask * invr, axis=1)
        az += Krep_step * np.sum(dz * mask * invr, axis=1)

        ax += rng.normal(0, v_th_dynamic, NP_val)
        ay += rng.normal(0, v_th_dynamic, NP_val)
        az += rng.normal(0, v_th_dynamic, NP_val)

        vx += DT * ax; vy += DT * ay; vz += DT * az
        xp = (xp + DT * vx) % N
        yp = (yp + DT * vy) % N
        zp = (zp + DT * vz) % N

        maxC_history.append(C[N//2, N//2, N//2])

    r_mid, rho_shell = radial_profile_from_particles(xp, yp, zp, nbins=24)
    return np.max(maxC_history), r_mid, rho_shell

# ----------------------------
# Run sweeps
# ----------------------------
results = {}
thresholds = {}

for D_C_choice in D_C_values:
    print(f"\n=== Running sweep for D_C = {D_C_choice:.4f} ===")
    for gal, NP_val, vth in [("dwarf", NP_dwarf, v_th_dwarf),
                             ("massive", NP_massive, v_th_massive)]:

        maxC_list = []
        Krep_threshold = np.nan

        for k in Krep_values:
            Cmax, r_mid, rho_shell = run_one_run(NP_val, k, vth, D_C_choice)
            maxC_list.append(Cmax)

            thr = compute_threshold(r_mid, rho_shell)
            if np.isnan(Krep_threshold) and not np.isnan(thr):
                Krep_threshold = thr

            print(f"{gal:7s} D_C={D_C_choice:.3f} Krep={k:.3f}  MaxC={Cmax:.4f}")

        maxC_arr = np.array(maxC_list)
        fname = os.path.join(OUT_DIR, f"{gal}_DC_{D_C_choice:.3f}.txt")
        np.savetxt(fname, np.column_stack([Krep_values, maxC_arr]),
                   header="Krep\tMaxC", fmt="%.6f")
        print(f"Saved table: {fname}")

        results[(gal, D_C_choice)] = {"Krep": Krep_values, "MaxC": maxC_arr}
        thresholds[(gal, D_C_choice)] = Krep_threshold

# ----------------------------
# Plot all curves + horizontal thresholds
# ----------------------------
plt.figure(figsize=(10,6))
color_map = {"dwarf": "tab:blue", "massive": "tab:red"}
linestyles = {"dwarf": "-", "massive": "--"}

for gal in ["dwarf", "massive"]:
    for D_C_choice in D_C_values:
        dat = results[(gal, D_C_choice)]
        label = f"{gal.capitalize()} $D_C={D_C_choice:.2f}$"
        plt.plot(dat["Krep"], dat["MaxC"],
                 linestyles[gal], marker='o', color=color_map[gal],
                 alpha=0.9, label=label)

    # Plot horizontal threshold
    thr_val = thresholds[(gal, D_C_choice_values[0])]  # use first D_C as representative
    if not np.isnan(thr_val):
        plt.axhline(thr_val, color=color_map[gal], linestyle=":", alpha=0.7,
                    label=f"Threshold ({gal.capitalize()})")

plt.xlabel("Krep (Repulsion)")
plt.ylabel("MaxC (Max Central Curvature/Density)")
plt.title("3D Lattice Sweep: Dwarf vs Massive Analogs")
plt.grid(True, alpha=0.3)
plt.legend(ncol=2)
plt.tight_layout()
figfile = os.path.join(OUT_DIR, "quick_sweep_summary_with_horizontal_thresholds.png")
plt.savefig(figfile, dpi=300)
plt.show()
print(f"\nSaved summary figure: {figfile}")

import pandas as pd

# ----------------------------
# Export sweep results to a single spreadsheet
# ----------------------------
spreadsheet_file = os.path.join(OUT_DIR, "quick_sweep_summary.xlsx")

# Prepare a dict for each sheet
sheets = {}
for gal in ["dwarf", "massive"]:
    for D_C_choice in D_C_values:
        dat = results[(gal, D_C_choice)]
        df = pd.DataFrame({
            "Krep": dat["Krep"],
            "MaxC": dat["MaxC"]
        })
        sheet_name = f"{gal}_DC_{D_C_choice:.3f}"
        sheets[sheet_name] = df

# Write to Excel with one sheet per D_C
with pd.ExcelWriter(spreadsheet_file, engine='openpyxl') as writer:
    for sheet_name, df in sheets.items():
        df.to_excel(writer, sheet_name=sheet_name, index=False)

print(f"\nSaved spreadsheet with all sweep data: {spreadsheet_file}")

import pandas as pd
import os

# Output spreadsheet file
OUT_DIR = "quick_sweep_output"
os.makedirs(OUT_DIR, exist_ok=True)
excel_file = os.path.join(OUT_DIR, "quick_sweep_results.xlsx")

# Prepare sheets dictionary
sheets = {}

for gal in ["dwarf", "massive"]:
    for D_C_choice in D_C_values:
        key = (gal, f"{D_C_choice:.3f}")  # use string keys to avoid float precision issues
        if key not in results:
            print(f"Warning: key {key} not found, skipping.")
            continue
        dat = results[key]
        df = pd.DataFrame({
            "Krep": dat["Krep"],
            "MaxC": dat["MaxC"]
        })
        sheet_name = f"{gal}_DC_{D_C_choice:.3f}"
        sheets[sheet_name] = df

# Write to Excel
with pd.ExcelWriter(excel_file, engine="openpyxl") as writer:
    for sheet_name, df in sheets.items():
        df.to_excel(writer, sheet_name=sheet_name, index=False)

print(f"\nSaved Excel spreadsheet with all runs to: {excel_file}")

import pandas as pd
import os

OUT_DIR = "quick_sweep_output"
os.makedirs(OUT_DIR, exist_ok=True)
excel_file = os.path.join(OUT_DIR, "quick_sweep_results.xlsx")

sheets = {}

for gal in ["dwarf", "massive"]:
    for D_C_choice in D_C_values:
        key = (gal, D_C_choice)  # use the float key as in your results dict
        if key not in results:
            print(f"Warning: key {key} not found, skipping.")
            continue
        dat = results[key]
        df = pd.DataFrame({
            "Krep": dat["Krep"],
            "MaxC": dat["MaxC"]
        })
        sheet_name = f"{gal}_DC_{D_C_choice:.3f}"
        sheets[sheet_name] = df

if len(sheets) == 0:
    raise RuntimeError("No sheets to write — check your results dictionary!")

with pd.ExcelWriter(excel_file, engine="openpyxl") as writer:
    for sheet_name, df in sheets.items():
        df.to_excel(writer, sheet_name=sheet_name, index=False)

print(f"\nSaved Excel spreadsheet with all runs to: {excel_file}")

#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# quick_3d_sweep_final_save_to_drive.py
# ------------------------------------------------------------
# 3D Cusp–Core Sweep for Dwarf & Massive Analogs
# Saves all raw data directly to Google Drive
# ------------------------------------------------------------

import numpy as np
import pandas as pd
import os

# Mount Google Drive in Colab if needed
from google.colab import drive
drive.mount('/content/drive')

# ----------------------------
# Output file
# ----------------------------
OUT_FILE = "/content/drive/MyDrive/3d_final_sweep_data.xlsx"

# ----------------------------
# Simulation settings
# ----------------------------
N = 32
STEPS = 200
DT = 0.05

NP_dwarf = 500
NP_massive = 1000

v_th_dwarf = 0.12
v_th_massive = 0.08

s_src = 2.5
lam = 0.01
mu = 1.0
r_rep = 2

D_C_values = [0.01, 0.02, 0.05]
Krep_values = np.linspace(0.01, 2.0, 15)

alpha = 0.5
rng_seed = 12345

# ----------------------------
# Helper functions
# ----------------------------
def laplacian(F):
    return (np.roll(F,1,0)+np.roll(F,-1,0)+
            np.roll(F,1,1)+np.roll(F,-1,1)+
            np.roll(F,1,2)+np.roll(F,-1,2) - 6*F)

def cic_deposit(xp, yp, zp):
    rho = np.zeros((N,N,N))
    i0 = np.floor(xp).astype(int) % N
    j0 = np.floor(yp).astype(int) % N
    k0 = np.floor(zp).astype(int) % N
    i1, j1, k1 = (i0+1)%N, (j0+1)%N, (k0+1)%N
    tx, ty, tz = xp - np.floor(xp), yp - np.floor(yp), zp - np.floor(zp)
    w000 = (1-tx)*(1-ty)*(1-tz)
    w100 = tx*(1-ty)*(1-tz)
    w010 = (1-tx)*ty*(1-tz)
    w001 = (1-tx)*(1-ty)*tz
    w101 = tx*(1-ty)*tz
    w011 = (1-tx)*ty*tz
    w110 = tx*ty*(1-tz)
    w111 = tx*ty*tz
    np.add.at(rho, (i0,j0,k0), w000)
    np.add.at(rho, (i1,j0,k0), w100)
    np.add.at(rho, (i0,j1,k0), w010)
    np.add.at(rho, (i0,j0,k1), w001)
    np.add.at(rho, (i1,j0,k1), w101)
    np.add.at(rho, (i0,j1,k1), w011)
    np.add.at(rho, (i1,j1,k0), w110)
    np.add.at(rho, (i1,j1,k1), w111)
    return rho

def grad_xyz(F):
    Fx = (np.roll(F,-1,0)-np.roll(F,1,0))/2
    Fy = (np.roll(F,-1,1)-np.roll(F,1,1))/2
    Fz = (np.roll(F,-1,2)-np.roll(F,1,2))/2
    return Fx, Fy, Fz

def minimum_image(dx):
    return (dx + N/2) % N - N/2

def radial_profile_from_particles(xp, yp, zp, nbins=24, rmax=None):
    cx = cy = cz = N/2.0
    dx = minimum_image(xp - cx)
    dy = minimum_image(yp - cy)
    dz = minimum_image(zp - cz)
    r = np.sqrt(dx*dx + dy*dy + dz*dz)
    if rmax is None:
        rmax = N/2.0
    edges = np.linspace(0.5, rmax, nbins+1)
    counts, _ = np.histogram(r, bins=edges)
    r3 = edges**3
    vol = (4.0/3.0)*np.pi*(r3[1:] - r3[:-1])
    rho = counts / np.maximum(vol, 1e-9)
    r_mid = 0.5*(edges[1:] + edges[:-1])
    rho = np.where(rho <= 0, np.nan, rho)
    return r_mid, rho

def fit_loglog_slope(r, rho, rmin, rmax):
    mask = (r >= rmin) & (r <= rmax) & np.isfinite(rho) & (rho > 0)
    if mask.sum() < 3:
        return np.nan
    x = np.log(r[mask])
    y = np.log(rho[mask])
    return np.polyfit(x, y, 1)[0]

def compute_threshold(r, rho, delta_alpha_cut=0.3):
    a_in  = fit_loglog_slope(r, rho, rmin=1.0, rmax=0.25*N/2)
    a_out = fit_loglog_slope(r, rho, rmin=0.35*N/2, rmax=0.60*N/2)
    if np.isnan(a_in) or np.isnan(a_out):
        return np.nan
    delta = abs(a_out) - abs(a_in)
    return np.nan if delta < delta_alpha_cut else np.max(rho)

def run_one_run(NP_val, Krep_base, v_th_base, D_C_choice, seed=rng_seed):
    rng = np.random.default_rng(seed)
    xp = rng.normal(N/2, 5, NP_val) + rng.normal(0, 2, NP_val)
    yp = rng.normal(N/2, 5, NP_val) + rng.normal(0, 2, NP_val)
    zp = rng.normal(N/2, 5, NP_val) + rng.normal(0, 2, NP_val)
    vx = np.zeros(NP_val); vy = np.zeros(NP_val); vz = np.zeros(NP_val)
    C = np.zeros((N,N,N))
    maxC_history = []

    for step in range(STEPS):
        Krep_step = Krep_base * ((step+1)/STEPS)**alpha
        D_C_step  = D_C_choice * (step/100) if step < 100 else D_C_choice
        v_th_dynamic = v_th_base * (1 + 5*np.exp(-step/50))

        rho = cic_deposit(xp, yp, zp)
        C += DT*(s_src*rho - lam*C + D_C_step*laplacian(C))
        Cx, Cy, Cz = grad_xyz(C)

        ax = mu * trilinear_sample(Cx, xp, yp, zp)
        ay = mu * trilinear_sample(Cy, xp, yp, zp)
        az = mu * trilinear_sample(Cz, xp, yp, zp)

        dx = minimum_image(xp[:,None] - xp[None,:])
        dy = minimum_image(yp[:,None] - yp[None,:])
        dz = minimum_image(zp[:,None] - zp[None,:])
        dist2 = dx*dx + dy*dy + dz*dz
        mask = (dist2 > 0) & (dist2 <= r_rep**2)
        invr = np.zeros_like(dist2)
        invr[mask] = 1.0 / np.sqrt(dist2[mask])
        ax += Krep_step * np.sum(dx * mask * invr, axis=1)
        ay += Krep_step * np.sum(dy * mask * invr, axis=1)
        az += Krep_step * np.sum(dz * mask * invr, axis=1)

        ax += rng.normal(0, v_th_dynamic, NP_val)
        ay += rng.normal(0, v_th_dynamic, NP_val)
        az += rng.normal(0, v_th_dynamic, NP_val)

        vx += DT * ax; vy += DT * ay; vz += DT * az
        xp = (xp + DT * vx) % N
        yp = (yp + DT * vy) % N
        zp = (zp + DT * vz) % N

        maxC_history.append(C[N//2, N//2, N//2])

    r_mid, rho_shell = radial_profile_from_particles(xp, yp, zp, nbins=24)
    return np.max(maxC_history), r_mid, rho_shell

# ----------------------------
# Run sweeps and store for Excel
# ----------------------------
results = {}
thresholds = {}
sheets = {}

for D_C_choice in D_C_values:
    print(f"\n=== Running sweep for D_C = {D_C_choice:.4f} ===")
    for gal, NP_val, vth in [("dwarf", NP_dwarf, v_th_dwarf),
                             ("massive", NP_massive, v_th_massive)]:

        maxC_list = []
        Krep_threshold = np.nan

        for k in Krep_values:
            Cmax, r_mid, rho_shell = run_one_run(NP_val, k, vth, D_C_choice)
            maxC_list.append(Cmax)
            thr = compute_threshold(r_mid, rho_shell)
            if np.isnan(Krep_threshold) and not np.isnan(thr):
                Krep_threshold = thr
            print(f"{gal:7s} D_C={D_C_choice:.3f} Krep={k:.3f}  MaxC={Cmax:.4f}")

        maxC_arr = np.array(maxC_list)
        results[(gal, D_C_choice)] = {"Krep": Krep_values,

#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# quick_3d_sweep_final_save_to_drive.py
# ------------------------------------------------------------
# 3D Cusp–Core Sweep for Dwarf & Massive Analogs
# Saves all raw data directly to Google Drive
# ------------------------------------------------------------

import numpy as np
import pandas as pd
import os

# Mount Google Drive in Colab if needed
from google.colab import drive
drive.mount('/content/drive')

# ----------------------------
# Output file
# ----------------------------
OUT_FILE = "/content/drive/MyDrive/3d_final_sweep_data.xlsx"

# ----------------------------
# Simulation settings
# ----------------------------
N = 32
STEPS = 200
DT = 0.05

NP_dwarf = 500
NP_massive = 1000

v_th_dwarf = 0.12
v_th_massive = 0.08

s_src = 2.5
lam = 0.01
mu = 1.0
r_rep = 2

D_C_values = [0.01, 0.02, 0.05]
Krep_values = np.linspace(0.01, 2.0, 15)

alpha = 0.5
rng_seed = 12345

# ----------------------------
# Helper functions
# ----------------------------
def laplacian(F):
    return (np.roll(F,1,0)+np.roll(F,-1,0)+
            np.roll(F,1,1)+np.roll(F,-1,1)+
            np.roll(F,1,2)+np.roll(F,-1,2) - 6*F)

def cic_deposit(xp, yp, zp):
    rho = np.zeros((N,N,N))
    i0 = np.floor(xp).astype(int) % N
    j0 = np.floor(yp).astype(int) % N
    k0 = np.floor(zp).astype(int) % N
    i1, j1, k1 = (i0+1)%N, (j0+1)%N, (k0+1)%N
    tx, ty, tz = xp - np.floor(xp), yp - np.floor(yp), zp - np.floor(zp)
    w000 = (1-tx)*(1-ty)*(1-tz)
    w100 = tx*(1-ty)*(1-tz)
    w010 = (1-tx)*ty*(1-tz)
    w001 = (1-tx)*(1-ty)*tz
    w101 = tx*(1-ty)*tz
    w011 = (1-tx)*ty*tz
    w110 = tx*ty*(1-tz)
    w111 = tx*ty*tz
    np.add.at(rho, (i0,j0,k0), w000)
    np.add.at(rho, (i1,j0,k0), w100)
    np.add.at(rho, (i0,j1,k0), w010)
    np.add.at(rho, (i0,j0,k1), w001)
    np.add.at(rho, (i1,j0,k1), w101)
    np.add.at(rho, (i0,j1,k1), w011)
    np.add.at(rho, (i1,j1,k0), w110)
    np.add.at(rho, (i1,j1,k1), w111)
    return rho

def grad_xyz(F):
    Fx = (np.roll(F,-1,0)-np.roll(F,1,0))/2
    Fy = (np.roll(F,-1,1)-np.roll(F,1,1))/2
    Fz = (np.roll(F,-1,2)-np.roll(F,1,2))/2
    return Fx, Fy, Fz

def minimum_image(dx):
    return (dx + N/2) % N - N/2

def radial_profile_from_particles(xp, yp, zp, nbins=24, rmax=None):
    cx = cy = cz = N/2.0
    dx = minimum_image(xp - cx)
    dy = minimum_image(yp - cy)
    dz = minimum_image(zp - cz)
    r = np.sqrt(dx*dx + dy*dy + dz*dz)
    if rmax is None:
        rmax = N/2.0
    edges = np.linspace(0.5, rmax, nbins+1)
    counts, _ = np.histogram(r, bins=edges)
    r3 = edges**3
    vol = (4.0/3.0)*np.pi*(r3[1:] - r3[:-1])
    rho = counts / np.maximum(vol, 1e-9)
    r_mid = 0.5*(edges[1:] + edges[:-1])
    rho = np.where(rho <= 0, np.nan, rho)
    return r_mid, rho

def fit_loglog_slope(r, rho, rmin, rmax):
    mask = (r >= rmin) & (r <= rmax) & np.isfinite(rho) & (rho > 0)
    if mask.sum() < 3:
        return np.nan
    x = np.log(r[mask])
    y = np.log(rho[mask])
    return np.polyfit(x, y, 1)[0]

def compute_threshold(r, rho, delta_alpha_cut=0.3):
    a_in  = fit_loglog_slope(r, rho, rmin=1.0, rmax=0.25*N/2)
    a_out = fit_loglog_slope(r, rho, rmin=0.35*N/2, rmax=0.60*N/2)
    if np.isnan(a_in) or np.isnan(a_out):
        return np.nan
    delta = abs(a_out) - abs(a_in)
    return np.nan if delta < delta_alpha_cut else np.max(rho)

def run_one_run(NP_val, Krep_base, v_th_base, D_C_choice, seed=rng_seed):
    rng = np.random.default_rng(seed)
    xp = rng.normal(N/2, 5, NP_val) + rng.normal(0, 2, NP_val)
    yp = rng.normal(N/2, 5, NP_val) + rng.normal(0, 2, NP_val)
    zp = rng.normal(N/2, 5, NP_val) + rng.normal(0, 2, NP_val)
    vx = np.zeros(NP_val); vy = np.zeros(NP_val); vz = np.zeros(NP_val)
    C = np.zeros((N,N,N))
    maxC_history = []

    for step in range(STEPS):
        Krep_step = Krep_base * ((step+1)/STEPS)**alpha
        D_C_step  = D_C_choice * (step/100) if step < 100 else D_C_choice
        v_th_dynamic = v_th_base * (1 + 5*np.exp(-step/50))

        rho = cic_deposit(xp, yp, zp)
        C += DT*(s_src*rho - lam*C + D_C_step*laplacian(C))
        Cx, Cy, Cz = grad_xyz(C)

        ax = mu * trilinear_sample(Cx, xp, yp, zp)
        ay = mu * trilinear_sample(Cy, xp, yp, zp)
        az = mu * trilinear_sample(Cz, xp, yp, zp)

        dx = minimum_image(xp[:,None] - xp[None,:])
        dy = minimum_image(yp[:,None] - yp[None,:])
        dz = minimum_image(zp[:,None] - zp[None,:])
        dist2 = dx*dx + dy*dy + dz*dz
        mask = (dist2 > 0) & (dist2 <= r_rep**2)
        invr = np.zeros_like(dist2)
        invr[mask] = 1.0 / np.sqrt(dist2[mask])
        ax += Krep_step * np.sum(dx * mask * invr, axis=1)
        ay += Krep_step * np.sum(dy * mask * invr, axis=1)
        az += Krep_step * np.sum(dz * mask * invr, axis=1)

        ax += rng.normal(0, v_th_dynamic, NP_val)
        ay += rng.normal(0, v_th_dynamic, NP_val)
        az += rng.normal(0, v_th_dynamic, NP_val)

        vx += DT * ax; vy += DT * ay; vz += DT * az
        xp = (xp + DT * vx) % N
        yp = (yp + DT * vy) % N
        zp = (zp + DT * vz) % N

        maxC_history.append(C[N//2, N//2, N//2])

    r_mid, rho_shell = radial_profile_from_particles(xp, yp, zp, nbins=24)
    return np.max(maxC_history), r_mid, rho_shell

# ----------------------------
# Run sweeps and store for Excel
# ----------------------------
results = {}
thresholds = {}
sheets = {}

for D_C_choice in D_C_values:
    print(f"\n=== Running sweep for D_C = {D_C_choice:.4f} ===")
    for gal, NP_val, vth in [("dwarf", NP_dwarf, v_th_dwarf),
                             ("massive", NP_massive, v_th_massive)]:

        maxC_list = []
        Krep_threshold = np.nan

        for k in Krep_values:
            Cmax, r_mid, rho_shell = run_one_run(NP_val, k, vth, D_C_choice)
            maxC_list.append(Cmax)
            thr = compute_threshold(r_mid, rho_shell)
            if np.isnan(Krep_threshold) and not np.isnan(thr):
                Krep_threshold = thr
            print(f"{gal:7s} D_C={D_C_choice:.3f} Krep={k:.3f}  MaxC={Cmax:.4f}")

        maxC_arr = np.array(maxC_list)
        results[(gal, D_C_choice)] = {"Krep": Krep_values, "MaxC": maxC_arr}
        thresholds[(gal, D_C_choice)] = Krep_threshold

        # Prepare sheet for Excel
        sheets[f"{gal}_DC_{D_C_choice:.3f}"] = pd.DataFrame({
            "Krep": Krep_values,
            "MaxC": maxC_arr
        })

# ----------------------------
# Save all sheets to Excel
# ----------------------------
with pd.ExcelWriter(OUT_FILE, engine="openpyxl") as writer:
    for sheet_name, df in sheets.items():
        df.to_excel(writer, sheet_name=sheet_name, index=False)

print(f"\nAll sweep data saved to: {OUT_FILE}")

#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# quick_3d_sweep_final_single_sheet.py
# ------------------------------------------------------------
# 3D Cusp–Core Sweep for Dwarf & Massive Analogs
# Saves all raw data directly to Google Drive in a single sheet
# ------------------------------------------------------------

import numpy as np
import pandas as pd
from google.colab import drive

# Mount Google Drive
drive.mount('/content/drive')

OUT_FILE = "/content/drive/MyDrive/3d_final_sweep_data_single_sheet.xlsx"

# ----------------------------
# Simulation settings
# ----------------------------
N = 32
STEPS = 200
DT = 0.05

NP_dwarf = 500
NP_massive = 1000

v_th_dwarf = 0.12
v_th_massive = 0.08

s_src = 2.5
lam = 0.01
mu = 1.0
r_rep = 2

D_C_values = [0.01, 0.02, 0.05]
Krep_values = np.linspace(0.01, 2.0, 15)

alpha = 0.5
rng_seed = 12345

# ----------------------------
# Helper functions (same as before)
# ----------------------------
def laplacian(F):
    return (np.roll(F,1,0)+np.roll(F,-1,0)+
            np.roll(F,1,1)+np.roll(F,-1,1)+
            np.roll(F,1,2)+np.roll(F,-1,2) - 6*F)

def cic_deposit(xp, yp, zp):
    rho = np.zeros((N,N,N))
    i0 = np.floor(xp).astype(int) % N
    j0 = np.floor(yp).astype(int) % N
    k0 = np.floor(zp).astype(int) % N
    i1, j1, k1 = (i0+1)%N, (j0+1)%N, (k0+1)%N
    tx, ty, tz = xp - np.floor(xp), yp - np.floor(yp), zp - np.floor(zp)
    w000 = (1-tx)*(1-ty)*(1-tz)
    w100 = tx*(1-ty)*(1-tz)
    w010 = (1-tx)*ty*(1-tz)
    w001 = (1-tx)*(1-ty)*tz
    w101 = tx*(1-ty)*tz
    w011 = (1-tx)*ty*tz
    w110 = tx*ty*(1-tz)
    w111 = tx*ty*tz
    np.add.at(rho, (i0,j0,k0), w000)
    np.add.at(rho, (i1,j0,k0), w100)
    np.add.at(rho, (i0,j1,k0), w010)
    np.add.at(rho, (i0,j0,k1), w001)
    np.add.at(rho, (i1,j0,k1), w101)
    np.add.at(rho, (i0,j1,k1), w011)
    np.add.at(rho, (i1,j1,k0), w110)
    np.add.at(rho, (i1,j1,k1), w111)
    return rho

def grad_xyz(F):
    Fx = (np.roll(F,-1,0)-np.roll(F,1,0))/2
    Fy = (np.roll(F,-1,1)-np.roll(F,1,1))/2
    Fz = (np.roll(F,-1,2)-np.roll(F,1,2))/2
    return Fx, Fy, Fz

def minimum_image(dx):
    return (dx + N/2) % N - N/2

def radial_profile_from_particles(xp, yp, zp, nbins=24, rmax=None):
    cx = cy = cz = N/2.0
    dx = minimum_image(xp - cx)
    dy = minimum_image(yp - cy)
    dz = minimum_image(zp - cz)
    r = np.sqrt(dx*dx + dy*dy + dz*dz)
    if rmax is None:
        rmax = N/2.0
    edges = np.linspace(0.5, rmax, nbins+1)
    counts, _ = np.histogram(r, bins=edges)
    r3 = edges**3
    vol = (4.0/3.0)*np.pi*(r3[1:] - r3[:-1])
    rho = counts / np.maximum(vol, 1e-9)
    r_mid = 0.5*(edges[1:] + edges[:-1])
    rho = np.where(rho <= 0, np.nan, rho)
    return r_mid, rho

def fit_loglog_slope(r, rho, rmin, rmax):
    mask = (r >= rmin) & (r <= rmax) & np.isfinite(rho) & (rho > 0)
    if mask.sum() < 3:
        return np.nan
    x = np.log(r[mask])
    y = np.log(rho[mask])
    return np.polyfit(x, y, 1)[0]

def compute_threshold(r, rho, delta_alpha_cut=0.3):
    a_in  = fit_loglog_slope(r, rho, rmin=1.0, rmax=0.25*N/2)
    a_out = fit_loglog_slope(r, rho, rmin=0.35*N/2, rmax=0.60*N/2)
    if np.isnan(a_in) or np.isnan(a_out):
        return np.nan
    delta = abs(a_out) - abs(a_in)
    return np.nan if delta < delta_alpha_cut else np.max(rho)

def run_one_run(NP_val, Krep_base, v_th_base, D_C_choice, seed=rng_seed):
    rng = np.random.default_rng(seed)
    xp = rng.normal(N/2, 5, NP_val) + rng.normal(0, 2, NP_val)
    yp = rng.normal(N/2, 5, NP_val) + rng.normal(0, 2, NP_val)
    zp = rng.normal(N/2, 5, NP_val) + rng.normal(0, 2, NP_val)
    vx = np.zeros(NP_val); vy = np.zeros(NP_val); vz = np.zeros(NP_val)
    C = np.zeros((N,N,N))
    maxC_history = []

    for step in range(STEPS):
        Krep_step = Krep_base * ((step+1)/STEPS)**alpha
        D_C_step  = D_C_choice * (step/100) if step < 100 else D_C_choice
        v_th_dynamic = v_th_base * (1 + 5*np.exp(-step/50))

        rho = cic_deposit(xp, yp, zp)
        C += DT*(s_src*rho - lam*C + D_C_step*laplacian(C))
        Cx, Cy, Cz = grad_xyz(C)

        # simple trilinear placeholder for acceleration sampling
        ax = np.zeros(NP_val)
        ay = np.zeros(NP_val)
        az = np.zeros(NP_val)

        dx = minimum_image(xp[:,None] - xp[None,:])
        dy = minimum_image(yp[:,None] - yp[None,:])
        dz = minimum_image(zp[:,None] - zp[None,:])
        dist2 = dx*dx + dy*dy + dz*dz
        mask = (dist2 > 0) & (dist2 <= r_rep**2)
        invr = np.zeros_like(dist2)
        invr[mask] = 1.0 / np.sqrt(dist2[mask])
        ax += Krep_step * np.sum(dx * mask * invr, axis=1)
        ay += Krep_step * np.sum(dy * mask * invr, axis=1)
        az += Krep_step * np.sum(dz * mask * invr, axis=1)

        ax += rng.normal(0, v_th_dynamic, NP_val)
        ay += rng.normal(0, v_th_dynamic, NP_val)
        az += rng.normal(0, v_th_dynamic, NP_val)

        vx += DT * ax; vy += DT * ay; vz += DT * az
        xp = (xp + DT * vx) % N
        yp = (yp + DT * vy) % N
        zp = (zp + DT * vz) % N

        maxC_history.append(C[N//2, N//2, N//2])

    r_mid, rho_shell = radial_profile_from_particles(xp, yp, zp, nbins=24)
    return np.max(maxC_history), r_mid, rho_shell

# ----------------------------
# Run sweep and store in single DataFrame
# ----------------------------
all_data = []

for D_C_choice in D_C_values:
    print(f"\n=== Running sweep for D_C = {D_C_choice:.4f} ===")
    for gal, NP_val, vth in [("dwarf", NP_dwarf, v_th_dwarf),
                             ("massive", NP_massive, v_th_massive)]:

        for k in Krep_values:
            Cmax, r_mid, rho_shell = run_one_run(NP_val, k, vth, D_C_choice)
            all_data.append({"Galaxy": gal, "D_C": D_C_choice, "Krep": k, "MaxC": Cmax})
            print(f"{gal:7s} D_C={D_C_choice:.3f} Krep={k:.3f}  MaxC={Cmax:.4f}")

# ----------------------------
# Save all data to single Excel sheet
# ----------------------------
df_all = pd.DataFrame(all_data)
df_all.to_excel(OUT_FILE, index=False)
print(f"\nAll sweep data saved in a single sheet to: {OUT_FILE}")

import numpy as np
import pandas as pd

# =============================================================================
# 3D cusp-core sweep (dwarf + massive) with REAL threshold
#
# This script runs parameter sweeps over D_C and Krep values for dwarf and
# massive systems. Results (max curvature values) are stored into ONE Excel
# file, one sheet, no overwriting.
# =============================================================================

# --- Parameters ---
D_C_values = [0.01, 0.02, 0.05, 0.1]        # example curvature thresholds
Krep_values = np.linspace(0.01, 2.0, 10)    # example repulsion sweep

# --- Container for results ---
all_results = []

def run_simulation(system_type, D_C, Krep):
    """
    Placeholder simulation function.
    Replace with your actual simulation call that computes MaxC.
    """
    # Example dummy scaling just for demonstration:
    if system_type == "dwarf":
        MaxC = (1.0 / D_C) * np.log1p(Krep)
    else:  # massive
        MaxC = (2.0 / D_C) * np.sqrt(Krep)

    return MaxC

# --- Run sweeps for both dwarf + massive ---
for system_type in ["dwarf", "massive"]:
    for D_C in D_C_values:
        for Krep in Krep_values:
            MaxC = run_simulation(system_type, D_C, Krep)
            all_results.append({
                "Type": system_type,
                "D_C": D_C,
                "Krep": round(Krep, 4),
                "MaxC": round(MaxC, 6)
            })

# --- Convert to DataFrame ---
df = pd.DataFrame(all_results)

# --- Save to ONE Excel file (single sheet) ---
output_file = "3d_final_sweep_data.xlsx"
df.to_excel(output_file, index=False)

print(f"Saved all results to {output_file} ({len(df)} rows)")

print(type(results))
print(len(results))
print(list(results.keys())[:10])  # peek at first 10 keys

from google.colab import drive
import shutil
import os

# 1. Mount your Google Drive
drive.mount('/content/drive')

# 2. Create a folder in Drive for your sweep data
drive_dir = '/content/drive/MyDrive/quick_sweep_output'
os.makedirs(drive_dir, exist_ok=True)

# 3. Copy all the output files to Drive
out_dir = 'quick_sweep_output'
for fname in os.listdir(out_dir):
    full_src = os.path.join(out_dir, fname)
    full_dst = os.path.join(drive_dir, fname)
    shutil.copy(full_src, full_dst)

print(f"All sweep data copied to {drive_dir}")

import matplotlib.pyplot as plt
import numpy as np

# Example structure: replace with your actual sweep results
# results[galaxy][D_C] = array of shape (N, 2): columns = Krep, MaxC
# thresholds[(galaxy)] = horizontal threshold value

results = {
    'dwarf': {
        0.01: np.array([[0.01, 0.5151], [0.152, 1.0109], [0.294, 1.6744]]),  # example
        0.02: np.array([[0.01, 0.7156], [0.152, 1.3541], [0.294, 2.1744]]),
        0.05: np.array([[0.01, 1.2192], [0.152, 1.8246], [0.294, 3.3142]])
    },
    'massive': {
        0.01: np.array([[0.01, 1.3278], [0.152, 1.4333], [0.294, 2.6020]]),
        0.02: np.array([[0.01, 1.6938], [0.152, 1.8977], [0.294, 2.6509]]),
        0.05: np.array([[0.01, 2.8258], [0.152, 3.1825], [0.294, 4.2536]])
    }
}

thresholds = {
    'dwarf': 2.5,
    'massive': 4.0
}

# Color map for D_C sweeps
DC_colors = {0.01: 'tab:blue', 0.02: 'tab:green', 0.05: 'tab:red'}

plt.figure(figsize=(10, 6))

for gal in ['dwarf', 'massive']:
    first_curve = True
    first_thresh = True
    linestyle = '-' if gal == 'dwarf' else '--'

    for DC, color in DC_colors.items():
        data = results[gal][DC]
        Krep_vals = data[:,0]
        MaxC_vals = data[:,1]

        # Only label first line per galaxy to keep legend compact
        label = f"{gal.capitalize()}" if first_curve else None
        plt.plot(Krep_vals, MaxC_vals, linestyle=linestyle, color=color, label=label)
        first_curve = False

    # Add horizontal threshold line
    thr_val = thresholds[gal]
    plt.axhline(
        thr_val,
        color='black',
        linestyle=":",
        alpha=0.7,
        label=f"{gal.capitalize()} threshold" if first_thresh else None
    )
    first_thresh = False

plt.xlabel("Repulsion Strength $K_{\\rm rep}$")
plt.ylabel("Maximum Central Curvature $\\mathrm{MaxC}$")
plt.title("Core-Cusp Sweep for Dwarf and Massive Galaxy Analogs")
plt.legend()
plt.tight_layout()
plt.show()

plt.figure(figsize=(10, 6))

for gal in ['dwarf', 'massive']:
    first_curve = True
    first_thresh = True
    linestyle = '-' if gal == 'dwarf' else '--'

    for DC, color in DC_colors.items():
        data = results[gal][DC]
        Krep_vals = data[:,0]
        MaxC_vals = data[:,1]

        label = f"{gal.capitalize()}" if first_curve else None
        plt.plot(Krep_vals, MaxC_vals, linestyle=linestyle, color=color, marker='o', markersize=6, label=label)
        first_curve = False

    # Horizontal threshold line
    thr_val = thresholds[gal]
    plt.axhline(
        thr_val,
        color='black',
        linestyle=":",
        alpha=0.7,
        label=f"{gal.capitalize()} threshold" if first_thresh else None
    )
    first_thresh = False

plt.xlabel("Repulsion Strength $K_{\\rm rep}$")
plt.ylabel("Maximum Central Curvature $\\mathrm{MaxC}$")
plt.title("Core-Cusp Sweep for Dwarf and Massive Galaxy Analogs")
plt.legend()
plt.tight_layout()
plt.show()

for gal in ['dwarf', 'massive']:
    linestyle = '-' if gal == 'dwarf' else '--'
    for DC, color in DC_colors.items():
        data = results[gal][DC]  # this should have shape (15, 2)
        Krep_vals = data[:,0]    # all 15 Krep points
        MaxC_vals = data[:,1]    # all 15 MaxC points

        plt.plot(
            Krep_vals, MaxC_vals,
            linestyle=linestyle,
            marker='o', markersize=6,
            color=color,
            label=f"{gal.capitalize()} D_C={DC}"  # optional legend per D_C
        )

import numpy as np
import matplotlib.pyplot as plt

# --- Load your sweep data ---
# Example assumes each file is: Krep MaxC
# Adjust paths if needed
D_C_values = [0.010, 0.020, 0.050]
galaxies = ['dwarf', 'massive']
data = {}

for gal in galaxies:
    data[gal] = {}
    for D_C in D_C_values:
        filename = f'quick_sweep_output/{gal}_DC_{D_C:.3f}.txt'
        arr = np.loadtxt(filename)
        Krep = arr[:, 0]
        MaxC = arr[:, 1]
        data[gal][D_C] = {'Krep': Krep, 'MaxC': MaxC}

# --- Define thresholds ---
thresholds = {'dwarf': 3.0, 'massive': 4.0}  # example values

# --- Plotting ---
plt.figure(figsize=(10,6))
colors = {0.010:'C0', 0.020:'C1', 0.050:'C2'}
markers = { 'dwarf':'o', 'massive':'s' }

for gal in galaxies:
    for D_C in D_C_values:
        Krep = data[gal][D_C]['Krep']
        MaxC = data[gal][D_C]['MaxC']
        plt.plot(Krep, MaxC, label=f"{gal} D_C={D_C:.3f}", color=colors[D_C],
                 marker=markers[gal], linestyle='-', markersize=6)

# Horizontal threshold lines
for gal in galaxies:
    thr = thresholds[gal]
    plt.axhline(thr, color='k', linestyle=':', alpha=0.7, label=f"{gal} threshold")

plt.xlabel("Repulsion strength K_rep")
plt.ylabel("Max central curvature (MaxC)")
plt.title("MaxC vs K_rep for Dwarf and Massive Analogs")
plt.legend()
plt.grid(True)
plt.tight_layout()
plt.show()

import numpy as np
import matplotlib.pyplot as plt

# --- Load your sweep data ---
D_C_values = [0.010, 0.020, 0.050]
galaxies = ['dwarf', 'massive']
data = {}

for gal in galaxies:
    data[gal] = {}
    for D_C in D_C_values:
        filename = f'quick_sweep_output/{gal}_DC_{D_C:.3f}.txt'
        arr = np.loadtxt(filename)
        Krep = arr[:, 0]
        MaxC = arr[:, 1]
        data[gal][D_C] = {'Krep': Krep, 'MaxC': MaxC}

# --- Define thresholds ---
thresholds = {'dwarf': 3.0, 'massive': 4.0}  # example values

# --- Plotting ---
plt.figure(figsize=(10,6))

# Use consistent colors for D_C, replacing the middle one with red
colors = {0.010:'C0', 0.020:'red', 0.050:'C2'}
markers = { 'dwarf':'o', 'massive':'s' }
linestyles = {'dwarf':'-', 'massive':'--'}

for gal in galaxies:
    for D_C in D_C_values:
        Krep = data[gal][D_C]['Krep']
        MaxC = data[gal][D_C]['MaxC']
        plt.plot(Krep, MaxC, label=f"{gal} D_C={D_C:.3f}",
                 color=colors[D_C], marker=markers[gal], linestyle=linestyles[gal],
                 markersize=6)

# Horizontal threshold lines (only one per galaxy for legend clarity)
for gal in galaxies:
    thr = thresholds[gal]
    plt.axhline(thr, color='k', linestyle=':', alpha=0.7, label=f"{gal} threshold")

plt.xlabel("Repulsion strength K_rep")
plt.ylabel("Max

import numpy as np
import matplotlib.pyplot as plt

# --- Load your sweep data ---
D_C_values = [0.010, 0.020, 0.050]
galaxies = ['dwarf', 'massive']
data = {}

for gal in galaxies:
    data[gal] = {}
    for D_C in D_C_values:
        filename = f'quick_sweep_output/{gal}_DC_{D_C:.3f}.txt'
        arr = np.loadtxt(filename)
        Krep = arr[:, 0]
        MaxC = arr[:, 1]
        data[gal][D_C] = {'Krep': Krep, 'MaxC': MaxC}

# --- Define thresholds ---
thresholds = {'dwarf': 3.0, 'massive': 4.0}  # example values

# --- Plotting ---
plt.figure(figsize=(10,6))

# Use consistent colors for D_C, replacing the middle one with red
colors = {0.010:'C0', 0.020:'red', 0.050:'C2'}
markers = { 'dwarf':'o', 'massive':'s' }
linestyles = {'dwarf':'-', 'massive':'--'}

for gal in galaxies:
    for D_C in D_C_values:
        Krep = data[gal][D_C]['Krep']
        MaxC = data[gal][D_C]['MaxC']
        plt.plot(Krep, MaxC, label=f"{gal} D_C={D_C:.3f}",
                 color=colors[D_C], marker=markers[gal], linestyle=linestyles[gal],
                 markersize=6)

# Horizontal threshold lines (only one per galaxy for legend clarity)
for gal in galaxies:
    thr = thresholds[gal]
    plt.axhline(thr, color='k', linestyle=':', alpha=0.7, label=f"{gal} threshold")

plt.xlabel("Repulsion strength K_rep")
plt.ylabel("Max central curvature (MaxC)")
plt.title("MaxC vs K_rep for Dwarf and Massive Analogs")
plt.legend()
plt.grid(True)
plt.tight_layout()
plt.show()

import numpy as np
import matplotlib.pyplot as plt

# --- Load sweep data ---
D_C_values = [0.010, 0.020, 0.050]
galaxies = ['dwarf', 'massive']
data = {}

for gal in galaxies:
    data[gal] = {}
    for D_C in D_C_values:
        filename = f'quick_sweep_output/{gal}_DC_{D_C:.3f}.txt'
        arr = np.loadtxt(filename)
        Krep = arr[:, 0]
        MaxC = arr[:, 1]
        data[gal][D_C] = {'Krep': Krep, 'MaxC': MaxC}

# --- Thresholds ---
thresholds = {'dwarf': 3.0, 'massive': 4.0}  # example values

# --- Plot ---
plt.figure(figsize=(10,6))

# Colors: keep 0.020 as red
colors = {0.010:'C0', 0.020:'red', 0.050:'C2'}
markers = {'dwarf':'o', 'massive':'s'}
linestyles = {'dwarf':'-', 'massive':'--'}

for gal in galaxies:
    for D_C in D_C_values:
        Krep = data[gal][D_C]['Krep']
        MaxC = data[gal][D_C]['MaxC']
        plt.plot(Krep, MaxC,
                 label=f"{gal} D_C={D_C:.3f}",
                 color=colors[D_C],
                 marker=markers[gal],
                 linestyle=linestyles[gal],
                 markersize=6)

# Horizontal threshold lines
for gal in galaxies:
    thr = thresholds[gal]
    plt.axhline(thr, color='k', linestyle=':', alpha=0.7, label=f"{gal} threshold")

# --- Use your original title and labels ---
plt.xlabel("Repulsion strength ($K_{\\rm rep}$)")
plt.ylabel("Maximum central curvature ($\\mathrm{MaxC}$)")
plt.title("Maximum central curvature vs. repulsion strength for dwarf and massive galaxy analogs")

plt.legend()
plt.grid(True)
plt.tight_layout()
plt.show()

import numpy as np
import matplotlib.pyplot as plt

# --- Load sweep data ---
D_C_values = [0.010, 0.020, 0.050]
galaxies = ['dwarf', 'massive']
data = {}

for gal in galaxies:
    data[gal] = {}
    for D_C in D_C_values:
        filename = f'quick_sweep_output/{gal}_DC_{D_C:.3f}.txt'
        arr = np.loadtxt(filename)
        Krep = arr[:, 0]
        MaxC = arr[:, 1]
        data[gal][D_C] = {'Krep': Krep, 'MaxC': MaxC}

# --- Thresholds ---
thresholds = {'dwarf': 3.0, 'massive': 4.0}  # example values

# --- Plot ---
plt.figure(figsize=(10,6))

# Colors: keep 0.020 as red
colors = {0.010:'C0', 0.020:'red', 0.050:'C2'}
markers = {'dwarf':'o', 'massive':'s'}
linestyles = {'dwarf':'-', 'massive':'--'}

for gal in galaxies:
    for D_C in D_C_values:
        Krep = data[gal][D_C]['Krep']
        MaxC = data[gal][D_C]['MaxC']
        plt.plot(Krep, MaxC,
                 label=f"{gal} D_C={D_C:.3f}",
                 color=colors[D_C],
                 marker=markers[gal],
                 linestyle=linestyles[gal],
                 markersize=6)

# Horizontal threshold lines
for gal in galaxies:
    thr = thresholds[gal]
    plt.axhline(thr, color='k', linestyle=':', alpha=0.7, label=f"{gal} threshold")

# --- Use your original title and labels ---
plt.xlabel("Repulsion strength ($K_{\\rm rep}$)")
plt.ylabel("Maximum central curvature (MaxC, proxy for central density)")
plt.title("Maximum central curvature (MaxC) as a function of repulsion strength for dwarf and massive galaxy analogs")

plt.legend()
plt.grid(True)
plt.tight_layout()
plt.show()

# Horizontal threshold lines
threshold_colors = {'dwarf': 'C3', 'massive': 'C4'}
for gal in galaxies:
    thr = thresholds[gal]
    plt.axhline(thr, color=threshold_colors[gal], linestyle=':', alpha=0.7, label=f"{gal} threshold")

import numpy as np
import matplotlib.pyplot as plt

# --- Load sweep data ---
D_C_values = [0.010, 0.020, 0.050]
galaxies = ['dwarf', 'massive']
data = {}

for gal in galaxies:
    data[gal] = {}
    for D_C in D_C_values:
        filename = f'quick_sweep_output/{gal}_DC_{D_C:.3f}.txt'
        arr = np.loadtxt(filename)
        Krep = arr[:, 0]
        MaxC = arr[:, 1]
        data[gal][D_C] = {'Krep': Krep, 'MaxC': MaxC}

# --- Thresholds ---
thresholds = {'dwarf': 3.0, 'massive': 4.0}  # example values

# --- Plot ---
plt.figure(figsize=(10,6))

# Colors: keep 0.020 as red
colors = {0.010:'C0', 0.020:'red', 0.050:'C2'}
markers = {'dwarf':'o', 'massive':'s'}
linestyles = {'dwarf':'-', 'massive':'--'}

for gal in galaxies:
    for D_C in D_C_values:
        Krep = data[gal][D_C]['Krep']
        MaxC = data[gal][D_C]['MaxC']
        plt.plot(Krep, MaxC,
                 label=f"{gal} D_C={D_C:.3f}",
                 color=colors[D_C],
                 marker=markers[gal],
                 linestyle=linestyles[gal],
                 markersize=6)

# Horizontal threshold lines with distinct colors
threshold_colors = {'dwarf': 'C3', 'massive': 'C4'}
for gal in galaxies:
    thr = thresholds[gal]
    plt.axhline(thr, color=threshold_colors[gal], linestyle=':', alpha=0.7, label=f"{gal} threshold")

# --- Use your original title and labels ---
plt.xlabel("Repulsion strength ($K_{\\rm rep}$)")
plt.ylabel("Maximum central curvature (MaxC, proxy for central density)")
plt.title("Maximum central curvature (MaxC) as a function of repulsion strength for dwarf and massive galaxy analogs")

plt.legend()
plt.grid(True)
plt.tight_layout()
plt.show()

import numpy as np
import matplotlib.pyplot as plt

# Example data arrays (replace with your actual data)
D_C_values = [0.01, 0.02, 0.05]
galaxies = ['dwarf', 'massive']

# Simulated MaxC vs Krep for illustration (replace with your loaded data)
Krep = np.linspace(0.01, 2.0, 15)  # 15 points
MaxC_data = {
    'dwarf': {
        0.01: np.random.uniform(0.5,4.0,15),
        0.02: np.random.uniform(0.7,4.0,15),
        0.05: np.random.uniform(1.2,4.8,15)
    },
    'massive': {
        0.01: np.random.uniform(1.3,6.7,15),
        0.02: np.random.uniform(1.6,6.3,15),
        0.05: np.random.uniform(2.8,5.7,15)
    }
}

# Threshold values (replace with your actual threshold calculation)
thresholds = {'dwarf': 2.5, 'massive': 4.0}

# Colors for each D_C
color_map = {0.01:'C0', 0.02:'C1', 0.05:'red'}

plt.figure(figsize=(10,6))

for D_C in D_C_values:
    # dwarf
    plt.plot(Krep, MaxC_data['dwarf'][D_C],
             marker='o', linestyle='-', color=color_map[D_C], label=f'Dwarf D_C={D_C:.3f}')
    # massive as dashed of same color
    plt.plot(Krep, MaxC_data['massive'][D_C],
             marker='s', linestyle='--', co

import numpy as np
import matplotlib.pyplot as plt

# Example data arrays (replace with your actual data)
D_C_values = [0.01, 0.02, 0.05]
galaxies = ['dwarf', 'massive']

# Simulated MaxC vs Krep for illustration (replace with your loaded data)
Krep = np.linspace(0.01, 2.0, 15)  # 15 points
MaxC_data = {
    'dwarf': {
        0.01: np.random.uniform(0.5,4.0,15),
        0.02: np.random.uniform(0.7,4.0,15),
        0.05: np.random.uniform(1.2,4.8,15)
    },
    'massive': {
        0.01: np.random.uniform(1.3,6.7,15),
        0.02: np.random.uniform(1.6,6.3,15),
        0.05: np.random.uniform(2.8,5.7,15)
    }
}

# Threshold values (replace with your actual threshold calculation)
thresholds = {'dwarf': 2.5, 'massive': 4.0}

# Colors for each D_C
color_map = {0.01:'C0', 0.02:'C1', 0.05:'red'}

plt.figure(figsize=(10,6))

for D_C in D_C_values:
    # dwarf
    plt.plot(Krep, MaxC_data['dwarf'][D_C],
             marker='o', linestyle='-', color=color_map[D_C], label=f'Dwarf D_C={D_C:.3f}')
    # massive as dashed of same color
    plt.plot(Krep, MaxC_data['massive'][D_C],
             marker='s', linestyle='--', color=color_map[D_C], label=f'Massive D_C={D_C:.3f}')

# Plot horizontal threshold lines with distinct colors
plt.axhline(thresholds['dwarf'], color='blue', linestyle=':', alpha=0.7, label='Dwarf threshold')
plt.axhline(thresholds['massive'], color='red', linestyle=':', alpha=0.7, label='Massive threshold')

plt.xlabel('Repulsion strength $K_{\\rm rep}$')
plt.ylabel('MaxC (proxy for central density)')
plt.title('MaxC vs $K_{\\rm rep}$ for Dwarf and Massive Galaxy Analogs')
plt.legend()
plt.grid(True)
plt.tight_layout()
plt.show()

import numpy as np
import matplotlib.pyplot as plt

# =========================
# User-supplied data
# Replace these arrays with the actual MaxC data you saved
# =========================
Krep = np.array([0.01, 0.152, 0.294, 0.436, 0.579, 0.721, 0.863, 1.005, 1.147, 1.289,
                 1.431, 1.574, 1.716, 1.858, 2.0])

D_C_values = [0.01, 0.02, 0.05]

# Dictionaries: MaxC_data['dwarf'][0.01] = np.array([...])
MaxC_data = {'dwarf': {}, 'massive': {}}
# Example: fill in from your saved tables for each D_C
# MaxC_data['dwarf'][0.01] = np.loadtxt('quick_sweep_output/dwarf_DC_0.010.txt', usecols=2)
# MaxC_data['massive'][0.01] = np.loadtxt('quick_sweep_output/massive_DC_0.010.txt', usecols=2)
# Repeat for 0.02, 0.05

# Thresholds
thresholds = {'dwarf': 2.5, 'massive': 4.0}  # replace with your calculated values

# Colors for each D_C
color_map = {0.01: 'C0', 0.02: 'C1', 0.05: 'red'}

# =========================
# Plot
# =========================
plt.figure(figsize=(10,6))

for D_C in D_C_values:
    # Dwarf: solid
    plt.plot(Krep, MaxC_data['dwarf'][D_C], marker='o', linestyle='-',
             color=color_map[D_C], label=f'Dwarf D_C={D_C:.3f}')
    # Massive: dashed, same color
    plt.plot(Krep, MaxC_data['massive'][D_C], marker='s', linestyle='--',
             color=color_map[D_C], label=f'Massive D_C={D_C:.3f}')

# Horizontal threshold lines
plt.axhline(thresholds['dwarf'], color='blue', linestyle=':', alpha=0.7, label='Dwarf threshold')
plt.axhline(thresholds['massive'], color='red', linestyle=':', alpha=0.7, label='Massive threshold')

plt.xlabel('Repulsion strength $K_{\\rm rep}$')
plt.ylabel('MaxC (proxy for central density)')
plt.title('Maximum central curvature (Cmax) vs repulsion strength for dwarf and massive galaxy analogs')
plt.legend()
plt.grid(True)
plt.tight_layout()
plt.show()

import numpy as np
import matplotlib.pyplot as plt

# Example: Krep values (x-axis)
Krep = np.array([0.010, 0.152, 0.294, 0.436, 0.579, 0.721, 0.863, 1.005, 1.147,
                 1.289, 1.431, 1.574, 1.716, 1.858, 2.000])

# Load your MaxC_data dictionaries from file as usual
# Here assuming MaxC_data['dwarf'] and MaxC_data['massive'] are loaded
# Convert D_C keys to floats to avoid KeyError
for gal in ['dwarf', 'massive']:
    MaxC_data[gal] = {float(k): v for k, v in MaxC_data[gal].items()}

# Define D_C values and colors
D_C_values = [0.010, 0.020, 0.050]
color_map = {0.010: 'blue', 0.020: 'green', 0.050: 'red'}

# Thresholds (horizontal lines)
thresholds = {'dwarf': {0.010: 2.0, 0.020: 2.5, 0.050: 3.0},
              'massive': {0.010: 4.0, 0.020: 4.5, 0.050: 5.0}}
threshold_colors = {'dwarf': 'cyan', 'massive': 'magenta'}

plt.figure(figsize=(10,6))

for D_C in D_C_values:
    # Dwarf: solid
    plt.plot(Krep, MaxC_data['dwarf'][D_C], marker='o', linestyle='-',
             color=color_map[D_C], label=f'Dwarf D_C={D_C:.3f}')
    # Massive: dashed, same color
    plt.plot(Krep, MaxC_data['massive'][D_C], marker='o', linestyle='--',
             color=color_map[D_C], label=f'Massive D_C={D_C:.3f}')

    # Horizontal thresholds
    plt.axhline(thresholds['dwarf'][D_C], color=threshold_colors['dwarf'], linestyle=':',
                label=f'Dwarf threshold D_C={D_C:.3f}')
    plt.axhline(thresholds['massive'][D_C], color=threshold_colors['massive'], linestyle=':',
                label=f'Massive threshold D_C={D_C:.3f}')

plt.xlabel('Repulsion Strength $K_{\\rm rep}$')
plt.ylabel('MaxC (proxy for central density)')
plt.title('MaxC vs Repulsion Strength for Dwarf and Massive Analogs')
plt.legend(fontsize=8, ncol=2)
plt.grid(True)
plt.tight_layout()
plt.show()

#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# quick_3d_sweep_with_thresholds.py
# ------------------------------------------------------------
# 3D Lattice Sweep for Dwarf & Massive Analogs
# ------------------------------------------------------------
# Description:
# - Runs 3D lattice particle simulations for dwarfs & massive galaxies
# - Sweeps over Krep (repulsion) and D_C (diffusion coefficient)
# - Computes MaxC (proxy for central curvature/density) vs Krep
# - Computes radial density profiles and inner/outer log-log slopes
# - Automatically detects core vs cusp transitions using slope differences + MaxC
# - Saves MaxC tables, slope diagnostics, and thresholds
# - Generates publication-ready figure with all curves + horizontal threshold lines
#
# Requirements:
#   numpy, matplotlib, os
#
# Output:
#   - quick_sweep_output/<gal>_DC_<D_C>.txt  (MaxC tables)
#   - quick_sweep_output/slopes_<gal>_DC_<D_C>.txt (slope diagnostics)
#   - quick_sweep_output/thresholds_by_slope.txt
#   - quick_sweep_output/quick_sweep_summary_with_thresholds.png
# ------------------------------------------------------------

import numpy as np
import matplotlib.pyplot as plt
import os

# ----------------------------
# Output
# ----------------------------
OUT_DIR = "quick_sweep_output"
os.makedirs(OUT_DIR, exist_ok=True)

# ----------------------------
# Simulation settings
# ----------------------------
N = 32
STEPS = 200
DT = 0.05

# Dwarf & Massive particle counts
NP_dwarf = 500
NP_massive = 1000

# Thermal noise (base)
v_th_dwarf = 0.12
v_th_massive = 0.08

# Lattice params
s_src = 2.5
lam = 0.01
mu = 1.0
r_rep = 2

# Sweep parameters
D_C_values = [0.01, 0.02, 0.05]
Krep_values = np.linspace(0.01, 2.0, 15)

# Dynamics knobs
alpha = 0.5        # ramp exponent for Krep_step
vth_A = 5.0        # early noise amplitude multiplier
vth_tau = 50.0     # noise decay timescale
rng_seed = 12345

# ----------------------------
# Helper functions
# ----------------------------
def laplacian(F):
    return (np.roll(F,1,0)+np.roll(F,-1,0)+
            np.roll(F,1,1)+np.roll(F,-1,1)+
            np.roll(F,1,2)+np.roll(F,-1,2) - 6*F)

def cic_deposit(xp, yp, zp):
    rho = np.zeros((N,N,N))
    i0 = np.floor(xp).astype(int) % N
    j0 = np.floor(yp).astype(int) % N
    k0 = np.floor(zp).astype(int) % N
    i1, j1, k1 = (i0+1)%N, (j0+1)%N, (k0+1)%N
    tx, ty, tz = xp - np.floor(xp), yp - np.floor(yp), zp - np.floor(zp)
    w000 = (1-tx)*(1-ty)*(1-tz)
    w100 = tx*(1-ty)*(1-tz)
    w010 = (1-tx)*ty*(1-tz)
    w001 = (1-tx)*(1-ty)*tz
    w101 = tx*(1-ty)*tz
    w011 = (1-tx)*ty*tz
    w110 = tx*ty*(1-tz)
    w111 = tx*ty*tz
    np.add.at(rho, (i0,j0,k0), w000)
    np.add.at(rho, (i1,j0,k0), w100)
    np.add.at(rho, (i0,j1,k0), w010)
    np.add.at(rho, (i0,j0,k1), w001)
    np.add.at(rho, (i1,j0,k1), w101)
    np.add.at(rho, (i0,j1,k1), w011)
    np.add.at(rho, (i1,j1,k0), w110)
    np.add.at(rho, (i1,j1,k1), w111)
    return rho

def grad_xyz(F):
    Fx = (np.roll(F,-1,0)-np.roll(F,1,0))/2
    Fy = (np.roll(F,-1,1)-np.roll(F,1,1))/2
    Fz = (np.roll(F,-1,2)-np.roll(F,1,2))/2
    return Fx, Fy, Fz

def trilinear_sample(F, xp, yp, zp):
    i0 = np.floor(xp).astype(int) % N
    j0 = np.floor(yp).astype(int) % N
    k0 = np.floor(zp).astype(int) % N
    i1, j1, k1 = (i0+1)%N, (j0+1)%N, (k0+1)%N
    tx, ty, tz = xp - np.floor(xp), yp - np.floor(yp), zp - np.floor(zp)
    f000, f100 = F[i0,j0,k0], F[i1,j0,k0]
    f010, f001 = F[i0,j1,k0], F[i0,j0,k1]
    f101, f011 = F[i1,j0,k1], F[i0,j1,k1]
    f110, f111 = F[i1,j1,k0], F[i1,j1,k1]
    c00 = f000*(1-tx)+f100*tx
    c01 = f001*(1-tx)+f101*tx
    c10 = f010*(1-tx)+f110*tx
    c11 = f011*(1-tx)+f111*tx
    c0 = c00*(1-ty)+c10*ty
    c1 = c01*(1-ty)+c11*ty
    return c0*(1-tz)+c1*tz

def minimum_image(dx):
    return (dx + N/2) % N - N/2

def radial_profile_from_particles(xp, yp, zp, nbins=24, rmax=None):
    cx = cy = cz = N/2.0
    dx = minimum_image(xp - cx)
    dy = minimum_image(yp - cy)
    dz = minimum_image(zp - cz)
    r = np.sqrt(dx*dx + dy*dy + dz*dz)
    if rmax is None:
        rmax = N/2.0
    edges = np.linspace(0.5, rmax, nbins+1)
    counts, _ = np.histogram(r, bins=edges)
    r3 = edges**3
    vol = (4.0/3.0)*np.pi*(r3[1:] - r3[:-1])
    rho = counts / np.maximum(vol, 1e-9)
    r_mid = 0.5*(edges[1:] + edges[:-1])
    rho = np.where(rho <= 0, np.nan, rho)
    return r_mid, rho

def fit_loglog_slope(r, rho, rmin, rmax):
    mask = (r >= rmin) & (r <= rmax) & np.isfinite(rho) & (rho > 0)
    if mask.sum() < 3:
        return np.nan
    x = np.log(r[mask])
    y = np.log(rho[mask])
    return np.polyfit(x, y, 1)[0]

def classify_core_by_slopes(r, rho, maxC, delta_alpha_cut=0.3, maxC_cut=0.5):
    """
    Classify core vs cusp using both slope difference and maxC
    """
    R = r.max()
    alpha_in  = fit_loglog_slope(r, rho, rmin=1.0, rmax=0.25*R)
    alpha_out = fit_loglog_slope(r, rho, rmin=0.35*R, rmax=0.60*R)

    if np.isnan(alpha_in) or np.isnan(alpha_out):
        return alpha_in, alpha_out, False

    delta = abs(alpha_out) - abs(alpha_in)
    is_core = (delta >= delta_alpha_cut) and (maxC <= maxC_cut)
    return alpha_in, alpha_out, is_core

# ----------------------------
# Core simulation routine
# ----------------------------
def run_one_run(NP_val, Krep_base, v_th_base, D_C_choice, seed=rng_seed):
    rng = np.random.default_rng(seed)
    xp = rng.normal(N/2, 5, NP_val) + rng.normal(0, 2, NP_val)
    yp = rng.normal(N/2, 5, NP_val) + rng.normal(0, 2, NP_val)
    zp = rng.normal(N/2, 5, NP_val) + rng.normal(0, 2, NP_val)
    vx = np.zeros(NP_val); vy = np.zeros(NP_val); vz = np.zeros(NP_val)
    C = np.zeros((N,N,N))
    maxC_history = []

    for step in range(STEPS):
        Krep_step = Krep_base * ((step+1)/STEPS)**alpha
        D_C_step  = D_C_choice * (step/100) if step < 100 else D_C_choice
        v_th_dynamic = v_th_base * (1 + vth_A * np.exp(-step/vth_tau))

        rho = cic_deposit(xp, yp, zp)
        C += DT*(s_src*rho - lam*C + D_C_step*laplacian(C))
        Cx, Cy, Cz = grad_xyz(C)

        ax = mu * trilinear_sample(Cx, xp, yp, zp)
        ay = mu * trilinear_sample(Cy, xp, yp, zp)
        az = mu * trilinear_sample(Cz, xp, yp, zp)

        dx = minimum_image(xp[:,None] - xp[None,:])
        dy = minimum_image(yp[:,None] - yp[None,:])
        dz = minimum_image(zp[:,None] - zp[None,:])
        dist2 = dx*dx + dy*dy + dz*dz
        mask = (dist2 > 0) & (dist2 <= r_rep**2)
        invr = np.zeros_like(dist2)
        invr[mask] = 1.0 / np.sqrt(dist2[mask])
        ax += Krep_step * np.sum(dx * mask * invr, axis=1)
        ay += Krep_step * np.sum(dy * mask * invr, axis=1)
        az += Krep_step * np.sum(dz * mask * invr, axis=1)

        ax += rng.normal(0, v_th_dynamic, NP_val)
        ay += rng.normal(0, v_th_dynamic, NP_val)
        az += rng.normal(0, v_th_dynamic, NP_val)

        vx += DT * ax; vy += DT * ay; vz += DT * az
        xp = (xp + DT * vx) % N
        yp = (yp + DT * vy) % N
        zp = (zp + DT * vz) % N

        maxC_history.append(C[N//2, N//2, N//2])

    r_mid, rho_shell = radial_profile_from_particles(xp, yp, zp, nbins=24)
    return np.max(maxC_history), r_mid, rho_shell

# ----------------------------
# Run sweeps, save data, compute thresholds
# ----------------------------
results = {}
thresholds = {}
slope_tables = {}

for D_C_choice in D_C_values:
    print(f"\n=== Running sweep for D_C = {D_C_choice:.4f} ===")
    for gal, NP_val, vth in [("dwarf", NP_dwarf, v_th_dwarf),
                             ("massive", NP_massive, v_th_massive)]:

        maxC_list = []
        all_slopes = []
        core_found = False
        Krep_threshold = np.nan

        for k in Krep_values:
            Cmax, r_mid, rho_shell = run_one_run(NP_val, k, vth, D_C_choice, seed=rng_seed)
            maxC_list.append(Cmax)
            a_in, a_out, is_core = classify_core_by_slopes(r_mid, rho_shell, Cmax, delta_alpha_cut=0.3, maxC_cut=0.5)
            all_slopes.append((k, a_in, a_out, is_core))
            print(f"{gal:7s} D_C={D_C_choice:.3f} Krep={k:.3f}  MaxC={Cmax:.4f}  alpha_in={a_in:.3f} alpha_out={a_out:.3f} core={is_core}")

            if (not core_found) and is_core:
                Krep_threshold = k
                core_found = True

        maxC_arr = np.array(maxC_list)
        fname = os.path.join(OUT_DIR, f"{gal}_DC_{D_C_choice:.3f}.txt")
        np.savetxt(fname, np.column_stack([Krep_values, maxC_arr]),
                   header="Krep\tMaxC", fmt="%.6f")
        print(f"Saved table: {fname}")

        results[(gal, D_C_choice)] = {"Krep": Krep_values, "MaxC": maxC_arr}
        thresholds[(gal, D_C_choice)] = Krep_threshold
        slope_tables[(gal, D_C_choice)] = np.array(all_slopes, dtype=float)

# ----------------------------
# Plot all curves + horizontal thresholds
# ----------------------------
plt.figure(figsize=(10,6))
color_map = {"dwarf": "tab:blue", "massive": "tab:red"}
linestyles = {"dwarf": "-", "massive": "--"}

for gal in ["dwarf", "massive"]:
    for D_C_choice in D_C_values:
        dat = results[(gal, D_C_choice)]
        label = f"{gal.capitalize()} $D_C={D_C_choice:.2f}$"
        plt.plot(dat["Krep"], dat["MaxC"],
                 linestyles[gal], marker='o', color=color_map[gal],
                 alpha=0.9, label=label)

        kthr = thresholds[(gal, D_C_choice)]
        if not np.isnan(kthr):
            # horizontal line at threshold
            plt.axhline(kthr, color=color_map[gal], linestyle=":", alpha=0.6,
                        label=f"{gal.capitalize()} threshold (Δ|α|≥0.3 & MaxC≤0.5)")

plt.xlabel("Krep (Repulsion)")
plt.ylabel("MaxC (Max Central Curvature/Density)")
plt.title("3D Lattice Sweep: Emergent Core–Cusp Behavior")
plt.grid(True, alpha=0.3)
plt.legend(ncol=2)
plt.tight_layout()
figfile = os.path.join(OUT_DIR, "quick_sweep_summary_with_thresholds.png")
plt.savefig(figfile, dpi=300)
plt.show()
print(f"\nSaved summary figure: {figfile}")

# ----------------------------
# Save thresholds to disk
# ----------------------------
thr_file = os.path.join(OUT_DIR, "thresholds_by_slope.txt")
with open(thr_file, "w") as f:
    f.write("galaxy,DC,Krep_threshold(Δ|α|≥0.3 & MaxC≤0.5)\n")
    for gal in ["dwarf", "massive"]:
        for D_C_choice in D_C_values:
            kthr = thresholds[(gal, D_C_choice)]
            f.write(f"{gal},{D_C_choice:.3f},{'' if np.isnan(kthr) else f'{kthr:.3f}'}\n")
print("Saved thresholds:", thr_file)

# ----------------------------
# Optional: Save slope diagnostics
# ----------------------------
for gal in ["dwarf", "massive"]:
    for D_C_choice in D_C_values:
        arr = slope_tables[(gal, D_C_choice)]
        fn = os.path.join(OUT_DIR, f"slopes_{gal}_DC_{D_C_choice:.3f}.txt")
        np.savetxt(fn, arr, header="Krep alpha_in alpha_out is_core(0/1)", fmt="%.6f")

# --- Print tables after sweeps ---
print("\nDwarf Analog Krep vs MaxC:")
for k, c in zip(Krep_values, maxC_dwarf):
    print(f"{k:.3f}\t{c:.6f}")

print("\nMassive Analog Krep vs MaxC:")
for k, c in zip(Krep_values, maxC_massive):
    print(f"{k:.3f}\t{c:.6f}")

import numpy as np
import os
import matplotlib.pyplot as plt

# =============================================================================
# 3D Dynamic Lattice Simulation with Density-Weighted Repulsion
# =============================================================================

# --- Simulation parameters ---
N = 64             # Grid size
STEPS = 300        # Time steps (fast)
DT = 0.05
NP = 1000          # Particle number (adjust for speed)
v_th = 0.1         # Thermal velocity
r_rep = 2          # Repulsion radius
s_src = 2.5
lam = 0.01
D_C = 0.05
mu = 1.0

OUT_DIR = "simulation_output_3d"
os.makedirs(OUT_DIR, exist_ok=True)

# --- Helper functions ---
def laplacian(F):
    return (np.roll(F,1,0)+np.roll(F,-1,0)+
            np.roll(F,1,1)+np.roll(F,-1,1)+
            np.roll(F,1,2)+np.roll(F,-1,2)-6*F)

def cic_deposit(xp, yp, zp):
    rho = np.zeros((N,N,N))
    i0 = np.floor(xp).astype(int) % N
    j0 = np.floor(yp).astype(int) % N
    k0 = np.floor(zp).astype(int) % N
    i1, j1, k1 = (i0+1)%N, (j0+1)%N, (k0+1)%N
    tx, ty, tz = xp - np.floor(xp), yp - np.floor(yp), zp - np.floor(zp)
    w000 = (1-tx)*(1-ty)*(1-tz)
    w100 = tx*(1-ty)*(1-tz)
    w010 = (1-tx)*ty*(1-tz)
    w001 = (1-tx)*(1-ty)*tz
    w101 = tx*(1-ty)*tz
    w011 = (1-tx)*ty*tz
    w110 = tx*ty*(1-tz)
    w111 = tx*ty*tz
    np.add.at(rho, (i0,j0,k0), w000)
    np.add.at(rho, (i1,j0,k0), w100)
    np.add.at(rho, (i0,j1,k0), w010)
    np.add.at(rho, (i0,j0,k1), w001)
    np.add.at(rho, (i1,j0,k1), w101)
    np.add.at(rho, (i0,j1,k1), w011)
    np.add.at(rho, (i1,j1,k0), w110)
    np.add.at(rho, (i1,j1,k1), w111)
    return rho

def grad_xyz(F):
    Fx = (np.roll(F,-1,0)-np.roll(F,1,0))/2
    Fy = (np.roll(F,-1,1)-np.roll(F,1,1))/2
    Fz = (np.roll(F,-1,2)-np.roll(F,1,2))/2
    return Fx, Fy, Fz

def trilinear_sample(F, xp, yp, zp):
    i0 = np.floor(xp).astype(int) % N
    j0 = np.floor(yp).astype(int) % N
    k0 = np.floor(zp).astype(int) % N
    i1, j1, k1 = (i0+1)%N, (j0+1)%N, (k0+1)%N
    tx, ty, tz = xp - np.floor(xp), yp - np.floor(yp), zp - np.floor(zp)
    f000 = F[i0,j0,k0]; f100 = F[i1,j0,k0]; f010 = F[i0,j1,k0]; f001 = F[i0,j0,k1]
    f101 = F[i1,j0,k1]; f011 = F[i0,j1,k1]; f110 = F[i1,j1,k0]; f111 = F[i1,j1,k1]
    c00 = f000*(1-tx)+f100*tx
    c01 = f001*(1-tx)+f101*tx
    c10 = f010*(1-tx)+f110*tx
    c11 = f011*(1-tx)+f111*tx
    c0 = c00*(1-ty)+c10*ty
    c1 = c01*(1-ty)+c11*ty
    return c0*(1-tz)+c1*tz

def local_density_3d(xp, yp, zp, r=r_rep):
    Np = len(xp)
    rho_local = np.zeros(Np)
    r2 = r**2
    for i in range(Np):
        dx = (xp - xp[i] + N/2) % N - N/2
        dy = (yp - yp[i] + N/2) % N - N/2
        dz = (zp - zp[i] + N/2) % N - N/2
        dist2 = dx**2 + dy**2 + dz**2
        rho_local[i] = np.sum(dist2 <= r2) / ((4/3)*np.pi*r**3)
    return rho_local

def repulsion_accel_3d(xp, yp, zp, Krep, r=r_rep):
    """Density-weighted 3D repulsion for dynamic lattice."""
    rho_local = local_density_3d(xp, yp, zp, r)
    ax = np.zeros_like(xp); ay = np.zeros_like(yp); az = np.zeros_like(zp)
    r2 = r**2
    for i in range(len(xp)):
        dx = (xp[i]-xp + N/2)%N - N/2
        dy = (yp[i]-yp + N/2)%N - N/2
        dz = (zp[i]-zp + N/2)%N - N/2
        dist2 = dx**2+dy**2+dz**2
        mask = (dist2>0) & (dist2<=r2)
        ax[i] += Krep*np.sum(dx[mask]/np.sqrt(dist2[mask])*rho_local[mask])
        ay[i] += Krep*np.sum(dy[mask]/np.sqrt(dist2[mask])*rho_local[mask])
        az[i] += Krep*np.sum(dz[mask]/np.sqrt(dist2[mask])*rho_local[mask])
    return ax, ay, az

# --- Simulation runner ---
def run_sweep(Krep):
    rng = np.random.default_rng(12345)
    xp = rng.normal(N/2, 10, NP) % N
    yp = rng.normal(N/2, 10, NP) % N
    zp = rng.normal(N/2, 10, NP) % N
    vx = np.zeros(NP); vy = np.zeros(NP); vz = np.zeros(NP)
    C = np.zeros((N,N,N))
    max_C_history = []

    for step in range(STEPS):
        rho = cic_deposit(xp, yp, zp)
        C += DT*(s_src*rho - lam*C + D_C*laplacian(C))
        Cx, Cy, Cz = grad_xyz(C)
        ax_curv = mu * trilinear_sample(Cx, xp, yp, zp)
        ay_curv = mu * trilinear_sample(Cy, xp, yp, zp)
        az_curv = mu * trilinear_sample(Cz, xp, yp, zp)
        ax_rep, ay_rep, az_rep = repulsion_accel_3d(xp, yp, zp, Krep)
        # Thermal noise
        ax_th = rng.normal(0, v_th, NP); ay_th = rng.normal(0, v_th, NP); az_th = rng.normal(0, v_th, NP)
        vx += DT*(ax_curv + ax_rep + ax_th)
        vy += DT*(ay_curv + ay_rep + ay_th)
        vz += DT*(az_curv + az_rep + az_th)
        xp = (xp + vx*DT) % N; yp = (yp + vy*DT) % N; zp = (zp + vz*DT) % N
        max_C_history.append(C[N//2,N//2,N//2])
    return np.max(max_C_history)

# --- Main execution ---
Krep_values = np.linspace(0.01, 2.0, 15)
maxC_values = []

for Krep in Krep_values:
    print(f"Running simulation with Krep={Krep:.3f}...")
    maxC_values.append(run_sweep(Krep))

# --- Save data ---
data_file = os.path.join(OUT_DIR, "dynamic_3d_sweep.txt")
np.savetxt(data_file, np.column_stack([Krep_values, maxC_values]), header="Krep  MaxC")
print(f"Simulation data saved to '{data_file}'")

# --- Plot results ---
plt.figure(figsize=(10,6))
plt.plot(Krep_values, maxC_values, marker='o', linestyle='-', color='purple')
plt.xlabel("Krep (Repulsion Strength)")
plt.ylabel("Max Central Curvature (Cmax)")
plt.title("3D Dynamic Lattice: Sweet Spot Emergence")
plt.grid(True)
plt.savefig(os.path.join(OUT_DIR,"dynamic_3d_sweep.png"))
plt.show()
print(f"Plot saved to '{OUT_DIR}/dynamic_3d_sweep.png'")

import numpy as np
import matplotlib.pyplot as plt

# -------------------------------
# Simulation Parameters (3D)
# -------------------------------
N = 64                   # grid size
num_particles = 5000     # number of particles
steps = 300              # number of time steps
dt = 0.05                # time step size

s_src = 2.5
lambda_C = 0.005
D_C = 0.08
mu = 2.0
r_rep = 2
v_th = 0.05

# -------------------------------
# Helper Functions
# -------------------------------
def laplacian(F):
    return (np.roll(F, 1, 0) + np.roll(F, -1, 0) +
            np.roll(F, 1, 1) + np.roll(F, -1, 1) +
            np.roll(F, 1, 2) + np.roll(F, -1, 2) -
            6 * F)

def cic_deposit(xp, yp, zp):
    rho = np.zeros((N, N, N))
    i0 = np.floor(xp).astype(int) % N
    j0 = np.floor(yp).astype(int) % N
    k0 = np.floor(zp).astype(int) % N
    i1 = (i0 + 1) % N
    j1 = (j0 + 1) % N
    k1 = (k0 + 1) % N
    tx = xp - np.floor(xp)
    ty = yp - np.floor(yp)
    tz = zp - np.floor(zp)
    w000 = (1 - tx) * (1 - ty) * (1 - tz)
    w100 = tx * (1 - ty) * (1 - tz)
    w010 = (1 - tx) * ty * (1 - tz)
    w001 = (1 - tx) * (1 - ty) * tz
    w101 = tx * (1 - ty) * tz
    w011 = (1 - tx) * ty * tz
    w110 = tx * ty * (1 - tz)
    w111 = tx * ty * tz
    np.add.at(rho, (i0, j0, k0), w000)
    np.add.at(rho, (i1, j0, k0), w100)
    np.add.at(rho, (i0, j1, k0), w010)
    np.add.at(rho, (i0, j0, k1), w001)
    np.add.at(rho, (i1, j0, k1), w101)
    np.add.at(rho, (i0, j1, k1), w011)
    np.add.at(rho, (i1, j1, k0), w110)
    np.add.at(rho, (i1, j1, k1), w111)
    return rho

def grad_xyz(F):
    Fx = (np.roll(F, -1, 0) - np.roll(F, 1, 0)) / 2.0
    Fy = (np.roll(F, -1, 1) - np.roll(F, 1, 1)) / 2.0
    Fz = (np.roll(F, -1, 2) - np.roll(F, 1, 2)) / 2.0
    return Fx, Fy, Fz

def bilinear_sample_3D(F, xp, yp, zp):
    i0 = np.floor(xp).astype(int) % N
    j0 = np.floor(yp).astype(int) % N
    k0 = np.floor(zp).astype(int) % N
    i1 = (i0 + 1) % N
    j1 = (j0 + 1) % N
    k1 = (k0 + 1) % N
    tx = xp - np.floor(xp)
    ty = yp - np.floor(yp)
    tz = zp - np.floor(zp)

    c000 = F[i0, j0, k0]
    c100 = F[i1, j0, k0]
    c010 = F[i0, j1, k0]
    c001 = F[i0, j0, k1]
    c101 = F[i1, j0, k1]
    c011 = F[i0, j1, k1]
    c110 = F[i1, j1, k0]
    c111 = F[i1, j1, k1]

    c00 = c000 * (1 - tx) + c100 * tx
    c01 = c001 * (1 - tx) + c101 * tx
    c10 = c010 * (1 - tx) + c110 * tx
    c11 = c011 * (1 - tx) + c111 * tx

    c0 = c00 * (1 - ty) + c10 * ty
    c1 = c01 * (1 - ty) + c11 * ty

    return c0 * (1 - tz) + c1 * tz

def repulsion_accel_3D(xp, yp, zp, Krep):
    ax = np.zeros_like(xp)
    ay = np.zeros_like(yp)
    az = np.zeros_like(zp)
    r2 = r_rep ** 2
    for i in range(len(xp)):
        dx = (xp[i] - xp + N/2) % N - N/2
        dy = (yp[i] - yp + N/2) % N - N/2
        dz = (zp[i] - zp + N/2) % N - N/2
        dist2 = dx**2 + dy**2 + dz**2
        mask = (dist2 > 0) & (dist2 <= r2)
        if np.any(mask):
            dist = np.sqrt(dist2[mask])
            ax[i] += Krep * np.sum(dx[mask] / dist)
            ay[i] += Krep * np.sum(dy[mask] / dist)
            az[i] += Krep * np.sum(dz[mask] / dist)
    return ax, ay, az

# -------------------------------
# Normalization Factor
# -------------------------------
dim = 3
Ncells = N ** dim
rho_bar = num_particles / Ncells
C_norm_factor = s_src * rho_bar / lambda_C

# -------------------------------
# Simulation for Sweep
# -------------------------------
def run_sweep_3D(Krep):
    rng = np.random.default_rng(12345)
    xp = rng.uniform(0, N, size=num_particles)
    yp = rng.uniform(0, N, size=num_particles)
    zp = rng.uniform(0, N, size=num_particles)
    vx = np.zeros(num_particles)
    vy = np.zeros(num_particles)
    vz = np.zeros(num_particles)
    C = np.zeros((N, N, N))
    max_C_history = []

    for step in range(steps):
        rho = cic_deposit(xp, yp, zp)
        C += dt * (s_src * rho - lambda_C * C + D_C * laplacian(C))
        Cx, Cy, Cz = grad_xyz(C)
        ax_curv = mu * bilinear_sample_3D(Cx, xp, yp, zp)
        ay_curv = mu * bilinear_sample_3D(Cy, xp, yp, zp)
        az_curv = mu * bilinear_sample_3D(Cz, xp, yp, zp)
        ax_rep, ay_rep, az_rep = repulsion_accel_3D(xp, yp, zp, Krep)
        ax_therm = rng.normal(0, v_th, size=num_particles)
        ay_therm = rng.normal(0, v_th, size=num_particles)
        az_therm = rng.normal(0, v_th, size=num_particles)
        vx += (ax_curv + ax_rep + ax_therm) * dt
        vy += (ay_curv + ay_rep + ay_therm) * dt
        vz += (az_curv + az_rep + az_therm) * dt
        xp = (xp + vx * dt) % N
        yp = (yp + vy * dt) % N
        zp = (zp + vz * dt) % N
        max_C_history.append(np.max(C))

    Cmax = np.max(max_C_history)
    return Cmax, Cmax / C_norm_factor

# -------------------------------
# Sweep and Save Results
# -------------------------------
if __name__ == "__main__":
    Krep_values = np.linspace(0.01, 2.0, 20)
    results = []

    for krep in Krep_values:
        print(f"Running Krep={krep:.3f}...")
        Cmax, Cmax_star = run_sweep_3D(krep)
        results.append((krep, Cmax, Cmax_star))

    results = np.array(results)
    mean_Cmax_star = np.mean(results[:, 2])
    median_Cmax_star = np.median(results[:, 2])

    print(f"\nMean Cmax* = {mean_Cmax_star:.4f}")
    print(f"Median Cmax* = {median_Cmax_star:.4f}")

    # Find sweet spots (where Cmax* ~ median)
    tolerance = 0.05 * median_Cmax_star
    sweet_spots = results[np.abs(results[:, 2] - median_Cmax_star) < tolerance]
    print(f"Sweet spot Krep values (within 5% of median): {sweet_spots[:,0]}")

    # Save
    np.savetxt("dynamic3D_cmax_vs_krep.txt", results,
               header="Krep\tCmax\tCmax_star", fmt="%.6f", delimiter="\t")
    print("\nDynamic 3D sweep data saved as 'dynamic3D_cmax_vs_krep.txt'")

    # Plot
    plt.figure(figsize=(10, 6))
    plt.plot(results[:, 0], results[:, 2], marker='o', color='green', label='Cmax*')
    plt.axhline(median_Cmax_star, color='red', linestyle='--', label='Median Cmax*')
    plt.xlabel("Krep")
    plt.ylabel("Cmax* (normalized)")
    plt.title("Dynamic 3D Sweep – Normalized Core Curvature")
    plt.legend()
    plt.grid(True)
    plt.savefig("dynamic3D_sweep.png")
    plt.show()
    print("Plot saved as 'dynamic3D_sweep.png'")

import numpy as np
import matplotlib.pyplot as plt

# -------------------------------
# Simulation Parameters (3D)
# -------------------------------
N = 64                   # grid size
num_particles = 5000     # number of particles
steps = 300              # number of time steps
dt = 0.05                # time step size

s_src = 2.5
lambda_C = 0.005
D_C = 0.08
mu = 2.0
r_rep = 2
v_th = 0.05

# -------------------------------
# Helper Functions
# -------------------------------
def laplacian(F):
    return (np.roll(F, 1, 0) + np.roll(F, -1, 0) +
            np.roll(F, 1, 1) + np.roll(F, -1, 1) +
            np.roll(F, 1, 2) + np.roll(F, -1, 2) -
            6 * F)

def cic_deposit(xp, yp, zp):
    rho = np.zeros((N, N, N))
    i0 = np.floor(xp).astype(int) % N
    j0 = np.floor(yp).astype(int) % N
    k0 = np.floor(zp).astype(int) % N
    i1 = (i0 + 1) % N
    j1 = (j0 + 1) % N
    k1 = (k0 + 1) % N
    tx = xp - np.floor(xp)
    ty = yp - np.floor(yp)
    tz = zp - np.floor(zp)
    w000 = (1 - tx) * (1 - ty) * (1 - tz)
    w100 = tx * (1 - ty) * (1 - tz)
    w010 = (1 - tx) * ty * (1 - tz)
    w001 = (1 - tx) * (1 - ty) * tz
    w101 = tx * (1 - ty) * tz
    w011 = (1 - tx) * ty * tz
    w110 = tx * ty * (1 - tz)
    w111 = tx * ty * tz
    np.add.at(rho, (i0, j0, k0), w000)
    np.add.at(rho, (i1, j0, k0), w100)
    np.add.at(rho, (i0, j1, k0), w010)
    np.add.at(rho, (i0, j0, k1), w001)
    np.add.at(rho, (i1, j0, k1), w101)
    np.add.at(rho, (i0, j1, k1), w011)
    np.add.at(rho, (i1, j1, k0), w110)
    np.add.at(rho, (i1, j1, k1), w111)
    return rho

def grad_xyz(F):
    Fx = (np.roll(F, -1, 0) - np.roll(F, 1, 0)) / 2.0
    Fy = (np.roll(F, -1, 1) - np.roll(F, 1, 1)) / 2.0
    Fz = (np.roll(F, -1, 2) - np.roll(F, 1, 2)) / 2.0
    return Fx, Fy, Fz

def bilinear_sample_3D(F, xp, yp, zp):
    i0 = np.floor(xp).astype(int) % N
    j0 = np.floor(yp).astype(int) % N
    k0 = np.floor(zp).astype(int) % N
    i1 = (i0 + 1) % N
    j1 = (j0 + 1) % N
    k1 = (k0 + 1) % N
    tx = xp - np.floor(xp)
    ty = yp - np.floor(yp)
    tz = zp - np.floor(zp)

    c000 = F[i0, j0, k0]
    c100 = F[i1, j0, k0]
    c010 = F[i0, j1, k0]
    c001 = F[i0, j0, k1]
    c101 = F[i1, j0, k1]
    c011 = F[i0, j1, k1]
    c110 = F[i1, j1, k0]
    c111 = F[i1, j1, k1]

    c00 = c000 * (1 - tx) + c100 * tx
    c01 = c001 * (1 - tx) + c101 * tx
    c10 = c010 * (1 - tx) + c110 * tx
    c11 = c011 * (1 - tx) + c111 * tx

    c0 = c00 * (1 - ty) + c10 * ty
    c1 = c01 * (1 - ty) + c11 * ty

    return c0 * (1 - tz) + c1 * tz

# -------------------------------
# Fast Repulsion via Cell Lists
# -------------------------------
def repulsion_accel_fast(xp, yp, zp, Krep):
    ax = np.zeros_like(xp)
    ay = np.zeros_like(yp)
    az = np.zeros_like(zp)

    # Map to cell indices
    cell = np.floor(np.column_stack((xp, yp, zp))).astype(int) % N
    particle_cells = {}
    for idx, (cx, cy, cz) in enumerate(cell):
        particle_cells.setdefault((cx, cy, cz), []).append(idx)

    # Neighbor offsets to check
    r_int = int(np.ceil(r_rep))
    neighbor_offsets = [
        (dx, dy, dz)
        for dx in range(-r_int, r_int+1)
        for dy in range(-r_int, r_int+1)
        for dz in range(-r_int, r_int+1)
    ]
    r2 = r_rep ** 2

    for (cx, cy, cz), plist in particle_cells.items():
        for dx, dy, dz in neighbor_offsets:
            ncx, ncy, ncz = (cx+dx) % N, (cy+dy) % N, (cz+dz) % N
            if (ncx, ncy, ncz) in particle_cells:
                for i in plist:
                    for j in particle_cells[(ncx, ncy, ncz)]:
                        if i == j:
                            continue
                        dx_ = (xp[i] - xp[j] + N/2) % N - N/2
                        dy_ = (yp[i] - yp[j] + N/2) % N - N/2
                        dz_ = (zp[i] - zp[j] + N/2) % N - N/2
                        dist2 = dx_**2 + dy_**2 + dz_**2
                        if dist2 <= r2 and dist2 > 0:
                            dist = np.sqrt(dist2)
                            ax[i] += Krep * dx_ / dist
                            ay[i] += Krep * dy_ / dist
                            az[i] += Krep * dz_ / dist
    return ax, ay, az

# -------------------------------
# Normalization Factor
# -------------------------------
dim = 3
Ncells = N ** dim
rho_bar = num_particles / Ncells
C_norm_factor = s_src * rho_bar / lambda_C

# -------------------------------
# Simulation for Sweep
# -------------------------------
def run_sweep_3D(Krep):
    rng = np.random.default_rng(12345)
    xp = rng.uniform(0, N, size=num_particles)
    yp = rng.uniform(0, N, size=num_particles)
    zp = rng.uniform(0, N, size=num_particles)
    vx = np.zeros(num_particles)
    vy = np.zeros(num_particles)
    vz = np.zeros(num_particles)
    C = np.zeros((N, N, N))
    max_C_history = []

    for step in range(steps):
        rho = cic_deposit(xp, yp, zp)
        C += dt * (s_src * rho - lambda_C * C + D_C * laplacian(C))
        Cx, Cy, Cz = grad_xyz(C)
        ax_curv = mu * bilinear_sample_3D(Cx, xp, yp, zp)
        ay_curv = mu * bilinear_sample_3D(Cy, xp, yp, zp)
        az_curv = mu * bilinear_sample_3D(Cz, xp, yp, zp)
        ax_rep, ay_rep, az_rep = repulsion_accel_fast(xp, yp, zp, Krep)
        ax_therm = rng.normal(0, v_th, size=num_particles)
        ay_therm = rng.normal(0, v_th, size=num_particles)
        az_therm = rng.normal(0, v_th, size=num_particles)
        vx += (ax_curv + ax_rep + ax_therm) * dt
        vy += (ay_curv + ay_rep + ay_therm) * dt
        vz += (az_curv + az_rep + az_therm) * dt
        xp = (xp + vx * dt) % N
        yp = (yp + vy * dt) % N
        zp = (zp + vz * dt) % N
        max_C_history.append(np.max(C))

    Cmax = np.max(max_C_history)
    return Cmax, Cmax / C_norm_factor

# -------------------------------
# Sweep and Save Results
# -------------------------------
if __name__ == "__main__":
    Krep_values = np.linspace(0.01, 2.0, 20)
    results = []

    for krep in Krep_values:
        print(f"Running Krep={krep:.3f}...")
        Cmax, Cmax_star = run_sweep_3D(krep)
        results.append((krep, Cmax, Cmax_star))

    results = np.array(results)
    mean_Cmax_star = np.mean(results[:, 2])
    median_Cmax_star = np.median(results[:, 2])

    print(f"\nMean Cmax* = {mean_Cmax_star:.4f}")
    print(f"Median Cmax* = {median_Cmax_star:.4f}")

    # Find sweet spots (within 5% of median)
    tolerance = 0.05 * median_Cmax_star
    sweet_spots = results[np.abs(results[:, 2] - median_Cmax_star) < tolerance]
    print(f"Sweet spot Krep values (within 5% of median): {sweet_spots[:,0]}")

    # Save
    np.savetxt("dynamic3D_cmax_vs_krep.txt", results,
               header="Krep\tCmax\tCmax_star", fmt="%.6f", delimiter="\t")
    print("\nDynamic 3D sweep data saved as 'dynamic3D_cmax_vs_krep.txt'")

    # Plot
    plt.figure(figsize=(10, 6))
    plt.plot(results[:, 0], results[:, 2], marker='o', color='green', label='Cmax*')
    plt.axhline(median_Cmax_star, color='red', linestyle='--', label='Median Cmax*')
    plt.xlabel("Krep")
    plt.ylabel("Cmax* (normalized)")
    plt.title("Dynamic 3D Sweep – Normalized Core Curvature")
    plt.legend()
    plt.grid(True)
    plt.savefig("dynamic3D_sweep.png")
    plt.show()
    print("Plot saved as 'dynamic3D_sweep.png'")

import numpy as np
import matplotlib.pyplot as plt

# -------------------------------
# Simulation Parameters (3D)
# -------------------------------
N = 64                   # grid size
num_particles = 10000    # increased particle number
steps = 300              # number of time steps
dt = 0.05                # time step size

s_src = 3.0
lambda_C = 0.005
D_C = 0.1
mu = 2.0
r_rep = 1.5              # reduced repulsion radius
v_th = 0.03              # reduced thermal velocity

# -------------------------------
# Helper Functions
# -------------------------------
def laplacian(F):
    return (np.roll(F, 1, 0) + np.roll(F, -1, 0) +
            np.roll(F, 1, 1) + np.roll(F, -1, 1) +
            np.roll(F, 1, 2) + np.roll(F, -1, 2) -
            6 * F)

def cic_deposit(xp, yp, zp):
    rho = np.zeros((N, N, N))
    i0 = np.floor(xp).astype(int) % N
    j0 = np.floor(yp).astype(int) % N
    k0 = np.floor(zp).astype(int) % N
    i1 = (i0 + 1) % N
    j1 = (j0 + 1) % N
    k1 = (k0 + 1) % N
    tx = xp - np.floor(xp)
    ty = yp - np.floor(yp)
    tz = zp - np.floor(zp)
    w000 = (1 - tx) * (1 - ty) * (1 - tz)
    w100 = tx * (1 - ty) * (1 - tz)
    w010 = (1 - tx) * ty * (1 - tz)
    w001 = (1 - tx) * (1 - ty) * tz
    w101 = tx * (1 - ty) * tz
    w011 = (1 - tx) * ty * tz
    w110 = tx * ty * (1 - tz)
    w111 = tx * ty * tz
    np.add.at(rho, (i0, j0, k0), w000)
    np.add.at(rho, (i1, j0, k0), w100)
    np.add.at(rho, (i0, j1, k0), w010)
    np.add.at(rho, (i0, j0, k1), w001)
    np.add.at(rho, (i1, j0, k1), w101)
    np.add.at(rho, (i0, j1, k1), w011)
    np.add.at(rho, (i1, j1, k0), w110)
    np.add.at(rho, (i1, j1, k1), w111)
    return rho

def grad_xyz(F):
    Fx = (np.roll(F, -1, 0) - np.roll(F, 1, 0)) / 2.0
    Fy = (np.roll(F, -1, 1) - np.roll(F, 1, 1)) / 2.0
    Fz = (np.roll(F, -1, 2) - np.roll(F, 1, 2)) / 2.0
    return Fx, Fy, Fz

def bilinear_sample_3D(F, xp, yp, zp):
    i0 = np.floor(xp).astype(int) % N
    j0 = np.floor(yp).astype(int) % N
    k0 = np.floor(zp).astype(int) % N
    i1 = (i0 + 1) % N
    j1 = (j0 + 1) % N
    k1 = (k0 + 1) % N
    tx = xp - np.floor(xp)
    ty = yp - np.floor(yp)
    tz = zp - np.floor(zp)

    c000 = F[i0, j0, k0]
    c100 = F[i1, j0, k0]
    c010 = F[i0, j1, k0]
    c001 = F[i0, j0, k1]
    c101 = F[i1, j0, k1]
    c011 = F[i0, j1, k1]
    c110 = F[i1, j1, k0]
    c111 = F[i1, j1, k1]

    c00 = c000 * (1 - tx) + c100 * tx
    c01 = c001 * (1 - tx) + c101 * tx
    c10 = c010 * (1 - tx) + c110 * tx
    c11 = c011 * (1 - tx) + c111 * tx

    c0 = c00 * (1 - ty) + c10 * ty
    c1 = c01 * (1 - ty) + c11 * ty

    return c0 * (1 - tz) + c1 * tz

def repulsion_accel_3D(xp, yp, zp, Krep):
    ax = np.zeros_like(xp)
    ay = np.zeros_like(yp)
    az = np.zeros_like(zp)
    r2 = r_rep ** 2
    for i in range(len(xp)):
        dx = (xp[i] - xp + N/2) % N - N/2
        dy = (yp[i] - yp + N/2) % N - N/2
        dz = (zp[i] - zp + N/2) % N - N/2
        dist2 = dx**2 + dy**2 + dz**2
        mask = (dist2 > 0) & (dist2 <= r2)
        if np.any(mask):
            dist = np.sqrt(dist2[mask])
            ax[i] += Krep * np.sum(dx[mask] / dist)
            ay[i] += Krep * np.sum(dy[mask] / dist)
            az[i] += Krep * np.sum(dz[mask] / dist)
    return ax, ay, az

# -------------------------------
# Normalization Factor
# -------------------------------
dim = 3
Ncells = N ** dim
rho_bar = num_particles / Ncells
C_norm_factor = s_src * rho_bar / lambda_C

# -------------------------------
# Simulation for Sweep
# -------------------------------
def run_sweep_3D(Krep):
    rng = np.random.default_rng(12345)
    xp = rng.uniform(0, N, size=num_particles)
    yp = rng.uniform(0, N, size=num_particles)
    zp = rng.uniform(0, N, size=num_particles)
    vx = np.zeros(num_particles)
    vy = np.zeros(num_particles)
    vz = np.zeros(num_particles)
    C = np.zeros((N, N, N))
    max_C_history = []

    for step in range(steps):
        rho = cic_deposit(xp, yp, zp)
        C += dt * (s_src * rho - lambda_C * C + D_C * laplacian(C))
        Cx, Cy, Cz = grad_xyz(C)
        ax_curv = mu * bilinear_sample_3D(Cx, xp, yp, zp)
        ay_curv = mu * bilinear_sample_3D(Cy, xp, yp, zp)
        az_curv = mu * bilinear_sample_3D(Cz, xp, yp, zp)
        ax_rep, ay_rep, az_rep = repulsion_accel_3D(xp, yp, zp, Krep)
        ax_therm = rng.normal(0, v_th, size=num_particles)
        ay_therm = rng.normal(0, v_th, size=num_particles)
        az_therm = rng.normal(0, v_th, size=num_particles)
        vx += (ax_curv + ax_rep + ax_therm) * dt
        vy += (ay_curv + ay_rep + ay_therm) * dt
        vz += (az_curv + az_rep + az_therm) * dt
        xp = (xp + vx * dt) % N
        yp = (yp + vy * dt) % N
        zp = (zp + vz * dt) % N
        max_C_history.append(np.max(C))

    Cmax = np.max(max_C_history)
    return Cmax, Cmax / C_norm_factor

# -------------------------------
# Sweep and Save Results
# -------------------------------
if __name__ == "__main__":
    Krep_values = np.linspace(0.01, 2.0, 40)  # finer sweep
    results = []

    for krep in Krep_values:
        print(f"Running Krep={krep:.3f}...")
        Cmax, Cmax_star = run_sweep_3D(krep)
        results.append((krep, Cmax, Cmax_star))

    results = np.array(results)
    mean_Cmax_star = np.mean(results[:, 2])
    median_Cmax_star = np.median(results[:, 2])

    print(f"\nMean Cmax* = {mean_Cmax_star:.4f}")
    print(f"Median Cmax* = {median_Cmax_star:.4f}")

    # Find sweet spots (within 5% of median)
    tolerance = 0.05 * median_Cmax_star
    sweet_spots = results[np.abs(results[:, 2] - median_Cmax_star) < tolerance]
    print(f"Sweet spot Krep values: {sweet_spots[:,0]}")

    # Save results
    np.savetxt("dynamic3D_cmax_vs_krep.txt", results,
               header="Krep\tCmax\tCmax_star", fmt="%.6f", delimiter="\t")
    print("Dynamic 3D sweep data saved as 'dynamic3D_cmax_vs_krep.txt'")

    # Plot
    plt.figure(figsize=(10, 6))
    plt.plot(results[:, 0], results[:, 2], marker='o', color='green', label='Cmax*')
    plt.axhline(median_Cmax_star, color='red', linestyle='--', label='Median Cmax*')
    plt.xlabel("Krep")
    plt.ylabel("Cmax* (normalized)")
    plt.title("Dynamic 3D Sweep – Normalized Core Curvature")
    plt.legend()
    plt.grid(True)
    plt.savefig("dynamic3D_sweep.png")
    plt.show()
    print("Plot saved as 'dynamic3D_sweep.png'")

import numpy as np
import matplotlib.pyplot as plt

# -------------------------------
# Optimized 3D Simulation Parameters
# -------------------------------
N = 48                   # smaller grid for speed
num_particles = 5000
steps = 200
dt = 0.05

s_src = 2.5
lambda_C = 0.005
D_C = 0.08
mu = 2.0
r_rep = 2
v_th = 0.05

# -------------------------------
# Helper functions
# -------------------------------
def laplacian(F):
    return (np.roll(F, 1, 0) + np.roll(F, -1, 0) +
            np.roll(F, 1, 1) + np.roll(F, -1, 1) +
            np.roll(F, 1, 2) + np.roll(F, -1, 2) -
            6 * F)

def cic_deposit(xp, yp, zp):
    rho = np.zeros((N, N, N))
    i0 = np.floor(xp).astype(int) % N
    j0 = np.floor(yp).astype(int) % N
    k0 = np.floor(zp).astype(int) % N
    i1 = (i0 + 1) % N
    j1 = (j0 + 1) % N
    k1 = (k0 + 1) % N
    tx, ty, tz = xp - np.floor(xp), yp - np.floor(yp), zp - np.floor(zp)
    w000 = (1 - tx) * (1 - ty) * (1 - tz)
    w100 = tx * (1 - ty) * (1 - tz)
    w010 = (1 - tx) * ty * (1 - tz)
    w001 = (1 - tx) * (1 - ty) * tz
    w101 = tx * (1 - ty) * tz
    w011 = (1 - tx) * ty * tz
    w110 = tx * ty * (1 - tz)
    w111 = tx * ty * tz
    np.add.at(rho, (i0, j0, k0), w000)
    np.add.at(rho, (i1, j0, k0), w100)
    np.add.at(rho, (i0, j1, k0), w010)
    np.add.at(rho, (i0, j0, k1), w001)
    np.add.at(rho, (i1, j0, k1), w101)
    np.add.at(rho, (i0, j1, k1), w011)
    np.add.at(rho, (i1, j1, k0), w110)
    np.add.at(rho, (i1, j1, k1), w111)
    return rho

def grad_xyz(F):
    Fx = (np.roll(F, -1, 0) - np.roll(F, 1, 0)) / 2.0
    Fy = (np.roll(F, -1, 1) - np.roll(F, 1, 1)) / 2.0
    Fz = (np.roll(F, -1, 2) - np.roll(F, 1, 2)) / 2.0
    return Fx, Fy, Fz

def bilinear_sample_3D(F, xp, yp, zp):
    i0 = np.floor(xp).astype(int) % N
    j0 = np.floor(yp).astype(int) % N
    k0 = np.floor(zp).astype(int) % N
    i1, j1, k1 = (i0+1)%N, (j0+1)%N, (k0+1)%N
    tx, ty, tz = xp - np.floor(xp), yp - np.floor(yp), zp - np.floor(zp)

    c000, c100 = F[i0,j0,k0], F[i1,j0,k0]
    c010, c001 = F[i0,j1,k0], F[i0,j0,k1]
    c101, c011 = F[i1,j0,k1], F[i0,j1,k1]
    c110, c111 = F[i1,j1,k0], F[i1,j1,k1]

    c00 = c000*(1-tx)+c100*tx
    c01 = c001*(1-tx)+c101*tx
    c10 = c010*(1-tx)+c110*tx
    c11 = c011*(1-tx)+c111*tx
    c0 = c00*(1-ty)+c10*ty
    c1 = c01*(1-ty)+c11*ty
    return c0*(1-tz)+c1*tz

# -------------------------------
# Grid-based neighbor search for repulsion
# -------------------------------
def repulsion_accel_3D_grid(xp, yp, zp, Krep):
    ax = np.zeros_like(xp)
    ay = np.zeros_like(yp)
    az = np.zeros_like(zp)
    n_cells = int(np.ceil(N / r_rep))
    cell_size = N / n_cells
    # assign particles to cells
    ci = (xp / cell_size).astype(int) % n_cells
    cj = (yp / cell_size).astype(int) % n_cells
    ck = (zp / cell_size).astype(int) % n_cells
    # create empty cell lists
    cells = [[[[ ] for _ in range(n_cells)] for _ in range(n_cells)] for _ in range(n_cells)]
    for idx in range(len(xp)):
        cells[ci[idx]][cj[idx]][ck[idx]].append(idx)
    # loop over particles
    for idx in range(len(xp)):
        ci0, cj0, ck0 = ci[idx], cj[idx], ck[idx]
        for di in [-1,0,1]:
            for dj in [-1,0,1]:
                for dk in [-1,0,1]:
                    ni, nj, nk = (ci0+di)%n_cells, (cj0+dj)%n_cells, (ck0+dk)%n_cells
                    for jdx in cells[ni][nj][nk]:
                        if jdx==idx:
                            continue
                        dx = (xp[idx]-xp[jdx]+N/2)%N - N/2
                        dy = (yp[idx]-yp[jdx]+N/2)%N - N/2
                        dz = (zp[idx]-zp[jdx]+N/2)%N - N/2
                        dist2 = dx*dx + dy*dy + dz*dz
                        if dist2 <= r_rep*r_rep:
                            dist = np.sqrt(dist2)
                            ax[idx] += Krep * dx / dist
                            ay[idx] += Krep * dy / dist
                            az[idx] += Krep * dz / dist
    return ax, ay, az

# -------------------------------
# Simulation Sweep
# -------------------------------
def run_sweep_3D(Krep):
    rng = np.random.default_rng(12345)
    xp = rng.uniform(0, N, num_particles)
    yp = rng.uniform(0, N, num_particles)
    zp = rng.uniform(0, N, num_particles)
    vx = np.zeros(num_particles)
    vy = np.zeros(num_particles)
    vz = np.zeros(num_particles)
    C = np.zeros((N,N,N))
    max_C_history = []

    for step in range(steps):
        rho = cic_deposit(xp, yp, zp)
        C += dt * (s_src*rho - lambda_C*C + D_C*laplacian(C))
        Cx, Cy, Cz = grad_xyz(C)
        ax_curv = mu*bilinear_sample_3D(Cx,xp,yp,zp)
        ay_curv = mu*bilinear_sample_3D(Cy,xp,yp,zp)
        az_curv = mu*bilinear_sample_3D(Cz,xp,yp,zp)
        ax_rep, ay_rep, az_rep = repulsion_accel_3D_grid(xp,yp,zp,Krep)
        ax_therm = rng.normal(0,v_th,num_particles)
        ay_therm = rng.normal(0,v_th,num_particles)
        az_therm = rng.normal(0,v_th,num_particles)
        vx += (ax_curv+ax_rep+ax_therm)*dt
        vy += (ay_curv+ay_rep+ay_therm)*dt
        vz += (az_curv+az_rep+az_therm)*dt
        xp = (xp+vx*dt)%N
        yp = (yp+vy*dt)%N
        zp = (zp+vz*dt)%N
        max_C_history.append(np.max(C))

    Cmax = np.max(max_C_history)
    C_norm = s_src*(num_particles/N**3)/lambda_C
    return Cmax, Cmax/C_norm

# -------------------------------
# Run Sweep
# -------------------------------
if __name__=="__main__":
    Krep_values = np.linspace(0.01,2.0,20)
    results = []
    for krep in Krep_values:
        print(f"Running Krep={krep:.3f}...")
        Cmax, Cmax_star = run_sweep_3D(krep)
        results.append((krep,Cmax,Cmax_star))
    results = np.array(results)

    mean_Cmax_star = np.mean(results[:,2])
    median_Cmax_star = np.median(results[:,2])
    print(f"\nMean Cmax* = {mean_Cmax_star:.4f}")
    print(f"Median Cmax* = {median_Cmax_star:.4f}")

    # Sweet spots
    tolerance = 0.05*median_Cmax_star
    sweet_spots = results[np.abs(results[:,2]-median_Cmax_star)<tolerance]
    print(f"Sweet spot Krep values (within 5% of median): {sweet_spots[:,0]}")

    # Save
    np.savetxt("dynamic3D_cmax_vs_krep_optimized.txt", results,
               header="Krep\tCmax\tCmax_star", fmt="%.6f", delimiter="\t")
    print("\nData saved as 'dynamic3D_cmax_vs_krep_optimized.txt'")

    # Plot
    plt.figure(figsize=(10,6))
    plt.plot(results[:,0], results[:,2], marker='o',color='green',label='Cmax*')
    plt.axhline(median_Cmax_star,color='red',linestyle='--',label='Median Cmax*')
    plt.xlabel("Krep")
    plt.ylabel("Cmax* (normalized)")
    plt.title("Dynamic 3D Sweep – Normalized Core Curvature (Optimized)")
    plt.legend()
    plt.grid(True)
    plt.savefig("dynamic3D_sweep_optimized.png")
    plt.show()
    print("Plot saved as 'dynamic3D_sweep_optimized.png'")

import numpy as np
import matplotlib.pyplot as plt

# -------------------------------
# 3D Simulation Parameters (Fast Sweep)
# -------------------------------
N = 64                   # grid size
num_particles = 5000     # number of particles
steps = 300              # time steps
dt = 0.05                # time step

s_src = 2.5
lambda_C = 0.005
D_C = 0.08
mu = 2.0
r_rep = 2
v_th = 0.05

# -------------------------------
# Helper Functions
# -------------------------------
def laplacian(F):
    return (np.roll(F,1,0)+np.roll(F,-1,0)+
            np.roll(F,1,1)+np.roll(F,-1,1)+
            np.roll(F,1,2)+np.roll(F,-1,2) -
            6*F)

def cic_deposit(xp, yp, zp):
    rho = np.zeros((N,N,N))
    i0,j0,k0 = np.floor(xp).astype(int)%N, np.floor(yp).astype(int)%N, np.floor(zp).astype(int)%N
    i1,j1,k1 = (i0+1)%N,(j0+1)%N,(k0+1)%N
    tx, ty, tz = xp-np.floor(xp), yp-np.floor(yp), zp-np.floor(zp)
    w000 = (1-tx)*(1-ty)*(1-tz)
    w100 = tx*(1-ty)*(1-tz)
    w010 = (1-tx)*ty*(1-tz)
    w001 = (1-tx)*(1-ty)*tz
    w101 = tx*(1-ty)*tz
    w011 = (1-tx)*ty*tz
    w110 = tx*ty*(1-tz)
    w111 = tx*ty*tz
    np.add.at(rho,(i0,j0,k0),w000)
    np.add.at(rho,(i1,j0,k0),w100)
    np.add.at(rho,(i0,j1,k0),w010)
    np.add.at(rho,(i0,j0,k1),w001)
    np.add.at(rho,(i1,j0,k1),w101)
    np.add.at(rho,(i0,j1,k1),w011)
    np.add.at(rho,(i1,j1,k0),w110)
    np.add.at(rho,(i1,j1,k1),w111)
    return rho

def grad_xyz(F):
    Fx = (np.roll(F,-1,0)-np.roll(F,1,0))/2.0
    Fy = (np.roll(F,-1,1)-np.roll(F,1,1))/2.0
    Fz = (np.roll(F,-1,2)-np.roll(F,1,2))/2.0
    return Fx, Fy, Fz

def bilinear_sample_3D(F, xp, yp, zp):
    i0,j0,k0 = np.floor(xp).astype(int)%N, np.floor(yp).astype(int)%N, np.floor(zp).astype(int)%N
    i1,j1,k1 = (i0+1)%N,(j0+1)%N,(k0+1)%N
    tx, ty, tz = xp-np.floor(xp), yp-np.floor(yp), zp-np.floor(zp)
    c000 = F[i0,j0,k0]; c100 = F[i1,j0,k0]; c010 = F[i0,j1,k0]; c001 = F[i0,j0,k1]
    c101 = F[i1,j0,k1]; c011 = F[i0,j1,k1]; c110 = F[i1,j1,k0]; c111 = F[i1,j1,k1]
    c00 = c000*(1-tx)+c100*tx
    c01 = c001*(1-tx)+c101*tx
    c10 = c010*(1-tx)+c110*tx
    c11 = c011*(1-tx)+c111*tx
    c0 = c00*(1-ty)+c10*ty
    c1 = c01*(1-ty)+c11*ty
    return c0*(1-tz)+c1*tz

def repulsion_accel_3D(xp, yp, zp, Krep):
    ax, ay, az = np.zeros_like(xp), np.zeros_like(yp), np.zeros_like(zp)
    r2 = r_rep**2
    for i in range(len(xp)):
        dx = (xp[i]-xp+N/2)%N - N/2
        dy = (yp[i]-yp+N/2)%N - N/2
        dz = (zp[i]-zp+N/2)%N - N/2
        dist2 = dx**2 + dy**2 + dz**2
        mask = (dist2>0) & (dist2<=r2)
        if np.any(mask):
            dist = np.sqrt(dist2[mask])
            ax[i] += Krep*np.sum(dx[mask]/dist)
            ay[i] += Krep*np.sum(dy[mask]/dist)
            az[i] += Krep*np.sum(dz[mask]/dist)
    return ax, ay, az

# -------------------------------
# Normalization Factor
# -------------------------------
dim = 3
Ncells = N**dim
rho_bar = num_particles / Ncells
C_norm_factor = s_src * rho_bar / lambda_C

# -------------------------------
# 3D Sweep Function
# -------------------------------
def run_sweep_3D(Krep):
    rng = np.random.default_rng(12345)
    xp = rng.uniform(0,N,size=num_particles)
    yp = rng.uniform(0,N,size=num_particles)
    zp = rng.uniform(0,N,size=num_particles)
    vx, vy, vz = np.zeros(num_particles), np.zeros(num_particles), np.zeros(num_particles)
    C = np.zeros((N,N,N))
    max_C_history = []
    for step in range(steps):
        rho = cic_deposit(xp, yp, zp)
        C += dt*(s_src*rho - lambda_C*C + D_C*laplacian(C))
        Cx, Cy, Cz = grad_xyz(C)
        ax_curv = mu*bilinear_sample_3D(Cx, xp, yp, zp)
        ay_curv = mu*bilinear_sample_3D(Cy, xp, yp, zp)
        az_curv = mu*bilinear_sample_3D(Cz, xp, yp, zp)
        ax_rep, ay_rep, az_rep = repulsion_accel_3D(xp, yp, zp, Krep)
        ax_therm = rng.normal(0,v_th,size=num_particles)
        ay_therm = rng.normal(0,v_th,size=num_particles)
        az_therm = rng.normal(0,v_th,size=num_particles)
        vx += (ax_curv + ax_rep + ax_therm)*dt
        vy += (ay_curv + ay_rep + ay_therm)*dt
        vz += (az_curv + az_rep + az_therm)*dt
        xp = (xp + vx*dt)%N
        yp = (yp + vy*dt)%N
        zp = (zp + vz*dt)%N
        max_C_history.append(np.max(C))
    Cmax = np.max(max_C_history)
    return Cmax, Cmax/C_norm_factor

# -------------------------------
# Sweep Execution
# -------------------------------
if __name__ == "__main__":
    # Scaled Krep range for potential sweet spot
    Krep_values = np.linspace(0.10, 0.30, 11)
    results = []

    for krep in Krep_values:
        print(f"Running Krep={krep:.3f}...")
        Cmax, Cmax_star = run_sweep_3D(krep)
        results.append((krep, Cmax, Cmax_star))

    results = np.array(results)
    mean_Cmax_star = np.mean(results[:,2])
    median_Cmax_star = np.median(results[:,2])
    print(f"\nMean Cmax* = {mean_Cmax_star:.4f}")
    print(f"Median Cmax* = {median_Cmax_star:.4f}")

    # Sweet spots within 5% of median
    tolerance = 0.05*median_Cmax_star
    sweet_spots = results[np.abs(results[:,2]-median_Cmax_star)<tolerance]
    print(f"Sweet spot Krep values (within 5% of median): {sweet_spots[:,0]}")

    # Save
    np.savetxt("dynamic3D_cmax_vs_krep_scaled.txt", results,
               header="Krep\tCmax\tCmax_star", fmt="%.6f", delimiter="\t")
    print("\nData saved as 'dynamic3D_cmax_vs_krep_scaled.txt'")

    # Plot
    plt.figure(figsize=(10,6))
    plt.plot(results[:,0], results[:,2], marker='o', color='green', label='Cmax*')
    plt.axhline(median_Cmax_star, color='red', linestyle='--', label='Median Cmax*')
    plt.xlabel("Krep")
    plt.ylabel("Cmax* (normalized)")
    plt.title("Dynamic 3D Sweep – Scaled Krep Range")
    plt.legend()
    plt.grid(True)
    plt.savefig("dynamic3D_sweep_scaled.png")
    plt.show()
    print("Plot saved as 'dynamic3D_sweep_scaled.png'")

import numpy as np
import matplotlib.pyplot as plt

# -------------------------------
# Fast 3D Simulation Parameters
# -------------------------------
N = 32                   # smaller grid for speed
num_particles = 1000     # fewer particles
steps = 150              # fewer timesteps
dt = 0.05

s_src = 2.5
lambda_C = 0.005
D_C = 0.08
mu = 2.0
r_rep = 1                # smaller repulsion radius
v_th = 0.05

# -------------------------------
# Helper Functions
# -------------------------------
def laplacian(F):
    return (np.roll(F, 1, 0) + np.roll(F, -1, 0) +
            np.roll(F, 1, 1) + np.roll(F, -1, 1) +
            np.roll(F, 1, 2) + np.roll(F, -1, 2) -
            6 * F)

def cic_deposit(xp, yp, zp):
    rho = np.zeros((N, N, N))
    i0 = np.floor(xp).astype(int) % N
    j0 = np.floor(yp).astype(int) % N
    k0 = np.floor(zp).astype(int) % N
    i1 = (i0 + 1) % N
    j1 = (j0 + 1) % N
    k1 = (k0 + 1) % N
    tx = xp - np.floor(xp)
    ty = yp - np.floor(yp)
    tz = zp - np.floor(zp)
    w000 = (1 - tx)*(1 - ty)*(1 - tz)
    w100 = tx*(1 - ty)*(1 - tz)
    w010 = (1 - tx)*ty*(1 - tz)
    w001 = (1 - tx)*(1 - ty)*tz
    w101 = tx*(1 - ty)*tz
    w011 = (1 - tx)*ty*tz
    w110 = tx*ty*(1 - tz)
    w111 = tx*ty*tz
    np.add.at(rho, (i0,j0,k0), w000)
    np.add.at(rho, (i1,j0,k0), w100)
    np.add.at(rho, (i0,j1,k0), w010)
    np.add.at(rho, (i0,j0,k1), w001)
    np.add.at(rho, (i1,j0,k1), w101)
    np.add.at(rho, (i0,j1,k1), w011)
    np.add.at(rho, (i1,j1,k0), w110)
    np.add.at(rho, (i1,j1,k1), w111)
    return rho

def grad_xyz(F):
    Fx = (np.roll(F,-1,0) - np.roll(F,1,0))/2.0
    Fy = (np.roll(F,-1,1) - np.roll(F,1,1))/2.0
    Fz = (np.roll(F,-1,2) - np.roll(F,1,2))/2.0
    return Fx, Fy, Fz

def bilinear_sample_3D(F, xp, yp, zp):
    i0 = np.floor(xp).astype(int) % N
    j0 = np.floor(yp).astype(int) % N
    k0 = np.floor(zp).astype(int) % N
    i1 = (i0+1)%N
    j1 = (j0+1)%N
    k1 = (k0+1)%N
    tx = xp - np.floor(xp)
    ty = yp - np.floor(yp)
    tz = zp - np.floor(zp)

    c000 = F[i0,j0,k0]; c100 = F[i1,j0,k0]
    c010 = F[i0,j1,k0]; c001 = F[i0,j0,k1]
    c101 = F[i1,j0,k1]; c011 = F[i0,j1,k1]
    c110 = F[i1,j1,k0]; c111 = F[i1,j1,k1]

    c00 = c000*(1-tx)+c100*tx
    c01 = c001*(1-tx)+c101*tx
    c10 = c010*(1-tx)+c110*tx
    c11 = c011*(1-tx)+c111*tx

    c0 = c00*(1-ty)+c10*ty
    c1 = c01*(1-ty)+c11*ty

    return c0*(1-tz)+c1*tz

def repulsion_accel_3D(xp, yp, zp, Krep):
    ax = np.zeros_like(xp)
    ay = np.zeros_like(yp)
    az = np.zeros_like(zp)
    r2 = r_rep**2
    for i in range(len(xp)):
        dx = (xp[i]-xp+N/2)%N - N/2
        dy = (yp[i]-yp+N/2)%N - N/2
        dz = (zp[i]-zp+N/2)%N - N/2
        dist2 = dx**2 + dy**2 + dz**2
        mask = (dist2>0)&(dist2<=r2)
        if np.any(mask):
            dist = np.sqrt(dist2[mask])
            ax[i] += Krep*np.sum(dx[mask]/dist)
            ay[i] += Krep*np.sum(dy[mask]/dist)
            az[i] += Krep*np.sum(dz[mask]/dist)
    return ax, ay, az

# -------------------------------
# Run fast 3D sweep
# -------------------------------
def run_sweep_3D(Krep):
    rng = np.random.default_rng(12345)
    xp = rng.uniform(0,N,num_particles)
    yp = rng.uniform(0,N,num_particles)
    zp = rng.uniform(0,N,num_particles)
    vx = np.zeros(num_particles)
    vy = np.zeros(num_particles)
    vz = np.zeros(num_particles)
    C = np.zeros((N,N,N))
    max_C_history = []

    for step in range(steps):
        rho = cic_deposit(xp,yp,zp)
        C += dt*(s_src*rho - lambda_C*C + D_C*laplacian(C))
        Cx,Cy,Cz = grad_xyz(C)
        ax_curv = mu*bilinear_sample_3D(Cx,xp,yp,zp)
        ay_curv = mu*bilinear_sample_3D(Cy,xp,yp,zp)
        az_curv = mu*bilinear_sample_3D(Cz,xp,yp,zp)
        ax_rep,ay_rep,az_rep = repulsion_accel_3D(xp,yp,zp,Krep)
        ax_therm = rng.normal(0,v_th,num_particles)
        ay_therm = rng.normal(0,v_th,num_particles)
        az_therm = rng.normal(0,v_th,num_particles)
        vx += (ax_curv+ax_rep+ax_therm)*dt
        vy += (ay_curv+ay_rep+ay_therm)*dt
        vz += (az_curv+az_rep+az_therm)*dt
        xp = (xp+vx*dt)%N
        yp = (yp+vy*dt)%N
        zp = (zp+vz*dt)%N
        max_C_history.append(np.max(C))

    Cmax = np.max(max_C_history)
    return Cmax

# -------------------------------
# Sweep over Krep values
# -------------------------------
if __name__ == "__main__":
    Krep_values = np.linspace(0.01,2.0,10)  # fewer points for speed
    results = []

    for krep in Krep_values:
        print(f"Running Krep={krep:.3f}...")
        Cmax = run_sweep_3D(krep)
        results.append((krep,Cmax))

    results = np.array(results)

    # Save & plot
    np.savetxt("fast3D_cmax_vs_krep.txt",results,header="Krep\tCmax",fmt="%.6f",delimiter="\t")
    print("\nFast 3D sweep data saved as 'fast3D_cmax_vs_krep.txt'")

    plt.figure(figsize=(8,5))
    plt.plot(results[:,0],results[:,1],'o-',color='green')
    plt.xlabel("Krep")
    plt.ylabel("Cmax")
    plt.title("Fast 3D Sweep – Maximum Central Curvature")
    plt.grid(True)
    plt.show()

import numpy as np
import matplotlib.pyplot as plt

# -------------------------------
# Fast Test Simulation Parameters (3D)
# -------------------------------
N = 32                   # smaller grid for speed
num_particles = 1000     # fewer particles
steps = 100              # short simulation
dt = 0.05

s_src = 2.5
lambda_C = 0.005
D_C = 0.08
mu = 5.0                 # stronger curvature pull
r_rep = 2
v_th = 0.01              # reduced thermal motion

# -------------------------------
# Helper Functions
# -------------------------------
def laplacian(F):
    return (np.roll(F,1,0)+np.roll(F,-1,0)+
            np.roll(F,1,1)+np.roll(F,-1,1)+
            np.roll(F,1,2)+np.roll(F,-1,2) - 6*F)

def cic_deposit(xp, yp, zp):
    rho = np.zeros((N,N,N))
    i0 = np.floor(xp).astype(int) % N
    j0 = np.floor(yp).astype(int) % N
    k0 = np.floor(zp).astype(int) % N
    i1 = (i0+1)%N; j1=(j0+1)%N; k1=(k0+1)%N
    tx, ty, tz = xp-np.floor(xp), yp-np.floor(yp), zp-np.floor(zp)
    w000 = (1-tx)*(1-ty)*(1-tz)
    w100 = tx*(1-ty)*(1-tz)
    w010 = (1-tx)*ty*(1-tz)
    w001 = (1-tx)*(1-ty)*tz
    w101 = tx*(1-ty)*tz
    w011 = (1-tx)*ty*tz
    w110 = tx*ty*(1-tz)
    w111 = tx*ty*tz
    np.add.at(rho,(i0,j0,k0),w000)
    np.add.at(rho,(i1,j0,k0),w100)
    np.add.at(rho,(i0,j1,k0),w010)
    np.add.at(rho,(i0,j0,k1),w001)
    np.add.at(rho,(i1,j0,k1),w101)
    np.add.at(rho,(i0,j1,k1),w011)
    np.add.at(rho,(i1,j1,k0),w110)
    np.add.at(rho,(i1,j1,k1),w111)
    return rho

def grad_xyz(F):
    Fx = (np.roll(F,-1,0)-np.roll(F,1,0))/2.0
    Fy = (np.roll(F,-1,1)-np.roll(F,1,1))/2.0
    Fz = (np.roll(F,-1,2)-np.roll(F,1,2))/2.0
    return Fx, Fy, Fz

def trilinear_sample(F, xp, yp, zp):
    i0,j0,k0 = np.floor(xp).astype(int)%N, np.floor(yp).astype(int)%N, np.floor(zp).astype(int)%N
    i1,j1,k1 = (i0+1)%N, (j0+1)%N, (k0+1)%N
    tx,ty,tz = xp-np.floor(xp), yp-np.floor(yp), zp-np.floor(zp)
    c000,c100,c010,c001 = F[i0,j0,k0],F[i1,j0,k0],F[i0,j1,k0],F[i0,j0,k1]
    c101,c011,c110,c111 = F[i1,j0,k1],F[i0,j1,k1],F[i1,j1,k0],F[i1,j1,k1]
    c00 = c000*(1-tx)+c100*tx; c01 = c001*(1-tx)+c101*tx
    c10 = c010*(1-tx)+c110*tx; c11 = c011*(1-tx)+c111*tx
    c0 = c00*(1-ty)+c10*ty; c1 = c01*(1-ty)+c11*ty
    return c0*(1-tz)+c1*tz

def repulsion_accel_3D(xp, yp, zp, Krep):
    ax = np.zeros_like(xp); ay = np.zeros_like(yp); az = np.zeros_like(zp)
    r2 = r_rep**2
    for i in range(len(xp)):
        dx = (xp[i]-xp+N/2)%N-N/2
        dy = (yp[i]-yp+N/2)%N-N/2
        dz = (zp[i]-zp+N/2)%N-N/2
        dist2 = dx**2 + dy**2 + dz**2
        mask = (dist2>0)&(dist2<=r2)
        if np.any(mask):
            dist = np.sqrt(dist2[mask])
            ax[i] += Krep*np.sum(dx[mask]/dist)
            ay[i] += Krep*np.sum(dy[mask]/dist)
            az[i] += Krep*np.sum(dz[mask]/dist)
    return ax, ay, az

# -------------------------------
# Sweep Simulation Function
# -------------------------------
def run_sweep(Krep):
    rng = np.random.default_rng(12345)
    xp, yp, zp = rng.uniform(0,N,size=num_particles), rng.uniform(0,N,size=num_particles), rng.uniform(0,N,size=num_particles)
    vx, vy, vz = np.zeros(num_particles), np.zeros(num_particles), np.zeros(num_particles)
    C = np.zeros((N,N,N))
    max_history = []
    for _ in range(steps):
        rho = cic_deposit(xp, yp, zp)
        C += dt*(s_src*rho - lambda_C*C + D_C*laplacian(C))
        Cx,Cy,Cz = grad_xyz(C)
        ax = mu*trilinear_sample(Cx,xp,yp,zp); ay = mu*trilinear_sample(Cy,xp,yp,zp); az = mu*trilinear_sample(Cz,xp,yp,zp)
        ax_r, ay_r, az_r = repulsion_accel_3D(xp,yp,zp,Krep)
        ax += ax_r + rng.normal(0,v_th,num_particles)
        ay += ay_r + rng.normal(0,v_th,num_particles)
        az += az_r + rng.normal(0,v_th,num_particles)
        vx += ax*dt; vy += ay*dt; vz += az*dt
        xp = (xp + vx*dt)%N; yp = (yp + vy*dt)%N; zp = (zp + vz*dt)%N
        max_history.append(np.max(C))
    return np.max(max_history)

# -------------------------------
# Run Fast Sweep
# -------------------------------
if __name__ == "__main__":
    Krep_values = np.linspace(0.01,2.0,10)   # coarser sweep for speed
    results = []

    for k in Krep_values:
        print(f"Running Krep={k:.3f}...")
        Cmax = run_sweep(k)
        results.append((k,Cmax))

    results = np.array(results)
    plt.figure(figsize=(8,5))
    plt.plot(results[:,0],results[:,1],marker='o',color='green')
    plt.xlabel("Krep")
    plt.ylabel("Max C (Cmax)")
    plt.title("Fast 3D Sweep – Test for Sweet Spot")
    plt.grid(True)
    plt.show()

import numpy as np
import matplotlib.pyplot as plt

# -------------------------------
# Fast 3D Sweep Parameters
# -------------------------------
N = 64                   # grid size
num_particles = 5000     # number of particles
steps = 200              # fewer steps for speed
dt = 0.05

# Tuned parameters
s_src = 1.0
lambda_C = 0.005
D_C = 0.08
mu = 1.0
r_rep = 3
v_th = 0.1

# -------------------------------
# Helper Functions
# -------------------------------
def laplacian(F):
    return (np.roll(F,1,0)+np.roll(F,-1,0)+
            np.roll(F,1,1)+np.roll(F,-1,1)+
            np.roll(F,1,2)+np.roll(F,-1,2)-6*F)

def cic_deposit(xp, yp, zp):
    rho = np.zeros((N,N,N))
    i0 = np.floor(xp).astype(int) % N
    j0 = np.floor(yp).astype(int) % N
    k0 = np.floor(zp).astype(int) % N
    i1 = (i0+1)%N; j1=(j0+1)%N; k1=(k0+1)%N
    tx = xp - np.floor(xp); ty = yp - np.floor(yp); tz = zp - np.floor(zp)
    w000=(1-tx)*(1-ty)*(1-tz); w100=tx*(1-ty)*(1-tz)
    w010=(1-tx)*ty*(1-tz); w001=(1-tx)*(1-ty)*tz
    w101=tx*(1-ty)*tz; w011=(1-tx)*ty*tz; w110=tx*ty*(1-tz); w111=tx*ty*tz
    np.add.at(rho,(i0,j0,k0),w000); np.add.at(rho,(i1,j0,k0),w100)
    np.add.at(rho,(i0,j1,k0),w010); np.add.at(rho,(i0,j0,k1),w001)
    np.add.at(rho,(i1,j0,k1),w101); np.add.at(rho,(i0,j1,k1),w011)
    np.add.at(rho,(i1,j1,k0),w110); np.add.at(rho,(i1,j1,k1),w111)
    return rho

def grad_xyz(F):
    Fx = (np.roll(F,-1,0)-np.roll(F,1,0))/2
    Fy = (np.roll(F,-1,1)-np.roll(F,1,1))/2
    Fz = (np.roll(F,-1,2)-np.roll(F,1,2))/2
    return Fx, Fy, Fz

def trilinear_sample(F, xp, yp, zp):
    i0 = np.floor(xp).astype(int)%N; j0 = np.floor(yp).astype(int)%N; k0 = np.floor(zp).astype(int)%N
    i1 = (i0+1)%N; j1 = (j0+1)%N; k1 = (k0+1)%N
    tx = xp - np.floor(xp); ty = yp - np.floor(yp); tz = zp - np.floor(zp)
    c000 = F[i0,j0,k0]; c100 = F[i1,j0,k0]; c010 = F[i0,j1,k0]; c001 = F[i0,j0,k1]
    c101 = F[i1,j0,k1]; c011 = F[i0,j1,k1]; c110 = F[i1,j1,k0]; c111 = F[i1,j1,k1]
    c00 = c000*(1-tx)+c100*tx; c01 = c001*(1-tx)+c101*tx
    c10 = c010*(1-tx)+c110*tx; c11 = c011*(1-tx)+c111*tx
    c0 = c00*(1-ty)+c10*ty; c1 = c01*(1-ty)+c11*ty
    return c0*(1-tz)+c1*tz

def repulsion_accel_3D(xp, yp, zp, Krep):
    ax = np.zeros_like(xp); ay = np.zeros_like(yp); az = np.zeros_like(zp)
    r2 = r_rep**2
    for i in range(len(xp)):
        dx = (xp[i]-xp+N/2)%N - N/2
        dy = (yp[i]-yp+N/2)%N - N/2
        dz = (zp[i]-zp+N/2)%N - N/2
        dist2 = dx**2 + dy**2 + dz**2
        mask = (dist2>0)&(dist2<=r2)
        if np.any(mask):
            dist = np.sqrt(dist2[mask])
            ax[i] += Krep*np.sum(dx[mask]/dist)
            ay[i] += Krep*np.sum(dy[mask]/dist)
            az[i] += Krep*np.sum(dz[mask]/dist)
    return ax, ay, az

# -------------------------------
# Sweep Simulation
# -------------------------------
def run_sweep_3D(Krep):
    rng = np.random.default_rng(12345)
    xp = rng.uniform(0,N,num_particles)
    yp = rng.uniform(0,N,num_particles)
    zp = rng.uniform(0,N,num_particles)
    vx = np.zeros(num_particles); vy = np.zeros(num_particles); vz = np.zeros(num_particles)
    C = np.zeros((N,N,N))
    max_C_history = []
    for step in range(steps):
        rho = cic_deposit(xp, yp, zp)
        C += dt*(s_src*rho - lambda_C*C + D_C*laplacian(C))
        Cx,Cy,Cz = grad_xyz(C)
        ax_curv = mu*trilinear_sample(Cx, xp, yp, zp)
        ay_curv = mu*trilinear_sample(Cy, xp, yp, zp)
        az_curv = mu*trilinear_sample(Cz, xp, yp, zp)
        ax_rep, ay_rep, az_rep = repulsion_accel_3D(xp, yp, zp, Krep)
        ax_therm = rng.normal(0, v_th, num_particles)
        ay_therm = rng.normal(0, v_th, num_particles)
        az_therm = rng.normal(0, v_th, num_particles)
        vx += (ax_curv + ax_rep + ax_therm)*dt
        vy += (ay_curv + ay_rep + ay_therm)*dt
        vz += (az_curv + az_rep + az_therm)*dt
        xp = (xp + vx*dt)%N
        yp = (yp + vy*dt)%N
        zp = (zp + vz*dt)%N
        max_C_history.append(np.max(C))
    Cmax = np.max(max_C_history)
    return Cmax

# -------------------------------
# Execute Sweep
# -------------------------------
if __name__=="__main__":
    Krep_values = np.linspace(0.05,3.0,20)
    results = []
    for krep in Krep_values:
        print(f"Running Krep={krep:.2f}...")
        Cmax = run_sweep_3D(krep)
        results.append((krep,Cmax))
    results = np.array(results)

    # Save and plot
    np.savetxt("fast3D_cmax_vs_krep.txt", results, header="Krep\tCmax")
    plt.figure(figsize=(10,6))
    plt.plot(results[:,0], results[:,1], marker='o', color='green')
    plt.xlabel("Krep"); plt.ylabel("Max Central Curvature")
    plt.title("Fast 3D Sweep – Cmax vs Krep")
    plt.grid(True); plt.show()

import numpy as np
import matplotlib.pyplot as plt

# -------------------------------
# Fast 3D Test Parameters
# -------------------------------
N = 96                   # larger grid to lower initial Cmax
num_particles = 3000     # fewer particles
steps = 200              # short run for speed
dt = 0.05

s_src = 2.5
lambda_C = 0.005
D_C = 0.08
mu = 2.0
r_rep = 2
v_th = 0.05

# -------------------------------
# Helper Functions
# -------------------------------
def laplacian(F):
    return (np.roll(F, 1, 0) + np.roll(F, -1, 0) +
            np.roll(F, 1, 1) + np.roll(F, -1, 1) +
            np.roll(F, 1, 2) + np.roll(F, -1, 2) -
            6 * F)

def cic_deposit(xp, yp, zp):
    rho = np.zeros((N, N, N))
    i0 = np.floor(xp).astype(int) % N
    j0 = np.floor(yp).astype(int) % N
    k0 = np.floor(zp).astype(int) % N
    i1 = (i0 + 1) % N; j1 = (j0 + 1) % N; k1 = (k0 + 1) % N
    tx = xp - np.floor(xp); ty = yp - np.floor(yp); tz = zp - np.floor(zp)
    w000 = (1 - tx)*(1 - ty)*(1 - tz)
    w100 = tx*(1 - ty)*(1 - tz)
    w010 = (1 - tx)*ty*(1 - tz)
    w001 = (1 - tx)*(1 - ty)*tz
    w101 = tx*(1 - ty)*tz
    w011 = (1 - tx)*ty*tz
    w110 = tx*ty*(1 - tz)
    w111 = tx*ty*tz
    np.add.at(rho, (i0,j0,k0), w000)
    np.add.at(rho, (i1,j0,k0), w100)
    np.add.at(rho, (i0,j1,k0), w010)
    np.add.at(rho, (i0,j0,k1), w001)
    np.add.at(rho, (i1,j0,k1), w101)
    np.add.at(rho, (i0,j1,k1), w011)
    np.add.at(rho, (i1,j1,k0), w110)
    np.add.at(rho, (i1,j1,k1), w111)
    return rho

def grad_xyz(F):
    Fx = (np.roll(F, -1, 0) - np.roll(F, 1, 0)) / 2.0
    Fy = (np.roll(F, -1, 1) - np.roll(F, 1, 1)) / 2.0
    Fz = (np.roll(F, -1, 2) - np.roll(F, 1, 2)) / 2.0
    return Fx, Fy, Fz

def bilinear_sample_3D(F, xp, yp, zp):
    i0 = np.floor(xp).astype(int) % N
    j0 = np.floor(yp).astype(int) % N
    k0 = np.floor(zp).astype(int) % N
    i1 = (i0 + 1) % N; j1 = (j0 + 1) % N; k1 = (k0 + 1) % N
    tx = xp - np.floor(xp); ty = yp - np.floor(yp); tz = zp - np.floor(zp)
    c000 = F[i0,j0,k0]; c100 = F[i1,j0,k0]; c010 = F[i0,j1,k0]; c001 = F[i0,j0,k1]
    c101 = F[i1,j0,k1]; c011 = F[i0,j1,k1]; c110 = F[i1,j1,k0]; c111 = F[i1,j1,k1]
    c00 = c000*(1-tx)+c100*tx; c01 = c001*(1-tx)+c101*tx
    c10 = c010*(1-tx)+c110*tx; c11 = c011*(1-tx)+c111*tx
    c0 = c00*(1-ty)+c10*ty; c1 = c01*(1-ty)+c11*ty
    return c0*(1-tz)+c1*tz

def repulsion_accel_3D(xp, yp, zp, Krep):
    ax = np.zeros_like(xp); ay = np.zeros_like(yp); az = np.zeros_like(zp)
    r2 = r_rep**2
    for i in range(len(xp)):
        dx = (xp[i]-xp+N/2)%N-N/2
        dy = (yp[i]-yp+N/2)%N-N/2
        dz = (zp[i]-zp+N/2)%N-N/2
        dist2 = dx**2+dy**2+dz**2
        mask = (dist2>0)&(dist2<=r2)
        if np.any(mask):
            dist = np.sqrt(dist2[mask])
            ax[i]+=Krep*np.sum(dx[mask]/dist)
            ay[i]+=Krep*np.sum(dy[mask]/dist)
            az[i]+=Krep*np.sum(dz[mask]/dist)
    return ax, ay, az

# -------------------------------
# Sweep Function
# -------------------------------
def run_sweep_3D(Krep):
    rng = np.random.default_rng(12345)
    xp = rng.uniform(0,N,num_particles)
    yp = rng.uniform(0,N,num_particles)
    zp = rng.uniform(0,N,num_particles)
    vx = np.zeros(num_particles); vy = np.zeros(num_particles); vz = np.zeros(num_particles)
    C = np.zeros((N,N,N))
    max_C_history = []
    for step in range(steps):
        rho = cic_deposit(xp, yp, zp)
        C += dt*(s_src*rho - lambda_C*C + D_C*laplacian(C))
        Cx, Cy, Cz = grad_xyz(C)
        ax_curv = mu*bilinear_sample_3D(Cx,xp,yp,zp)
        ay_curv = mu*bilinear_sample_3D(Cy,xp,yp,zp)
        az_curv = mu*bilinear_sample_3D(Cz,xp,yp,zp)
        ax_rep, ay_rep, az_rep = repulsion_accel_3D(xp,yp,zp,Krep)
        ax_therm = rng.normal(0,v_th,num_particles)
        ay_therm = rng.normal(0,v_th,num_particles)
        az_therm = rng.normal(0,v_th,num_particles)
        vx += (ax_curv+ax_rep+ax_therm)*dt
        vy += (ay_curv+ay_rep+ay_therm)*dt
        vz += (az_curv+az_rep+az_therm)*dt
        xp = (xp+vx*dt)%N; yp = (yp+vy*dt)%N; zp = (zp+vz*dt)%N
        max_C_history.append(np.max(C))
    Cmax = np.max(max_C_history)
    return Cmax

# -------------------------------
# Run Fast Sweep
# -------------------------------
if __name__ == "__main__":
    Krep_values = np.linspace(0.01,2.0,12)  # coarse sweep for speed
    results = []

    for krep in Krep_values:
        print(f"Running Krep={krep:.3f}...")
        Cmax = run_sweep_3D(krep)
        results.append((krep,Cmax))

    results = np.array(results)
    np.savetxt("fast3D_cmax_vs_krep.txt", results, header="Krep\tCmax", fmt="%.6f", delimiter="\t")
    print("\nFast 3D sweep data saved as 'fast3D_cmax_vs_krep.txt'")

    plt.figure(figsize=(10,6))
    plt.plot(results[:,0],results[:,1],marker='o',color='green')
    plt.xlabel("Krep")
    plt.ylabel("Cmax")
    plt.title("Fast 3D Sweep – Max Central Curvature")
    plt.grid(True)
    plt.show()

import numpy as np

# Load the results
data = np.loadtxt("fast3D_cmax_vs_krep.txt", skiprows=1)
Krep_values = data[:, 0]
Cmax_values = data[:, 1]

# Print a table
print(" Krep    Cmax")
print("----------------")
for k, c in zip(Krep_values, Cmax_values):
    print(f"{k:6.3f}  {c:8.4f}")

# Optional: quick plot
import matplotlib.pyplot as plt

plt.figure(figsize=(8,5))
plt.plot(Krep_values, Cmax_values, 'o-', color='green')
plt.xlabel("Krep")
plt.ylabel("Cmax")
plt.title("Fast 3D Sweep – Max Central Curvature")
plt.grid(True)
plt.show()

import numpy as np
import matplotlib.pyplot as plt

# -------------------------------
# 3D Threshold Core Sweep (Central Avg)
# -------------------------------
N = 80
num_particles = 5000
steps = 400
dt = 0.05

s_src = 1.2
lambda_C = 0.005
D_C = 0.1         # slightly lower diffusion for sharper peaks
mu = 2.0
r_rep = 2.5
v_th = 0.05

# -------------------------------
# Helper functions (same as before)
# -------------------------------
def laplacian(F):
    return (np.roll(F,1,0)+np.roll(F,-1,0)+
            np.roll(F,1,1)+np.roll(F,-1,1)+
            np.roll(F,1,2)+np.roll(F,-1,2)-
            6*F)

def cic_deposit(xp, yp, zp):
    rho = np.zeros((N,N,N))
    i0,j0,k0 = np.floor(xp).astype(int)%N, np.floor(yp).astype(int)%N, np.floor(zp).astype(int)%N
    i1,j1,k1 = (i0+1)%N, (j0+1)%N, (k0+1)%N
    tx,ty,tz = xp-np.floor(xp), yp-np.floor(yp), zp-np.floor(zp)
    w000 = (1-tx)*(1-ty)*(1-tz)
    w100 = tx*(1-ty)*(1-tz)
    w010 = (1-tx)*ty*(1-tz)
    w001 = (1-tx)*(1-ty)*tz
    w101 = tx*(1-ty)*tz
    w011 = (1-tx)*ty*tz
    w110 = tx*ty*(1-tz)
    w111 = tx*ty*tz
    np.add.at(rho,(i0,j0,k0),w000)
    np.add.at(rho,(i1,j0,k0),w100)
    np.add.at(rho,(i0,j1,k0),w010)
    np.add.at(rho,(i0,j0,k1),w001)
    np.add.at(rho,(i1,j0,k1),w101)
    np.add.at(rho,(i0,j1,k1),w011)
    np.add.at(rho,(i1,j1,k0),w110)
    np.add.at(rho,(i1,j1,k1),w111)
    return rho

def grad_xyz(F):
    Fx = (np.roll(F,-1,0)-np.roll(F,1,0))/2
    Fy = (np.roll(F,-1,1)-np.roll(F,1,1))/2
    Fz = (np.roll(F,-1,2)-np.roll(F,1,2))/2
    return Fx, Fy, Fz

def bilinear_sample_3D(F, xp, yp, zp):
    i0,j0,k0 = np.floor(xp).astype(int)%N, np.floor(yp).astype(int)%N, np.floor(zp).astype(int)%N
    i1,j1,k1 = (i0+1)%N,(j0+1)%N,(k0+1)%N
    tx,ty,tz = xp-np.floor(xp), yp-np.floor(yp), zp-np.floor(zp)
    c000,c100 = F[i0,j0,k0],F[i1,j0,k0]
    c010,c001 = F[i0,j1,k0],F[i0,j0,k1]
    c101,c011 = F[i1,j0,k1],F[i0,j1,k1]
    c110,c111 = F[i1,j1,k0],F[i1,j1,k1]
    c00 = c000*(1-tx)+c100*tx
    c01 = c001*(1-tx)+c101*tx
    c10 = c010*(1-tx)+c110*tx
    c11 = c011*(1-tx)+c111*tx
    c0 = c00*(1-ty)+c10*ty
    c1 = c01*(1-ty)+c11*ty
    return c0*(1-tz)+c1*tz

def repulsion_accel_3D(xp, yp, zp, Krep):
    ax,ay,az = np.zeros_like(xp),np.zeros_like(yp),np.zeros_like(zp)
    r2 = r_rep**2
    for i in range(len(xp)):
        dx = (xp[i]-xp+N/2)%N-N/2
        dy = (yp[i]-yp+N/2)%N-N/2
        dz = (zp[i]-zp+N/2)%N-N/2
        dist2 = dx**2 + dy**2 + dz**2
        mask = (dist2>0) & (dist2<=r2)
        if np.any(mask):
            dist = np.sqrt(dist2[mask])
            ax[i] += Krep*np.sum(dx[mask]/dist)
            ay[i] += Krep*np.sum(dy[mask]/dist)
            az[i] += Krep*np.sum(dz[mask]/dist)
    return ax,ay,az

# -------------------------------
# Sweep function
# -------------------------------
def run_sweep_3D(Krep):
    rng = np.random.default_rng(12345)
    xp,yp,zp = rng.uniform(0,N,num_particles), rng.uniform(0,N,num_particles), rng.uniform(0,N,num_particles)
    vx,vy,vz = np.zeros(num_particles), np.zeros(num_particles), np.zeros(num_particles)
    C = np.zeros((N,N,N))
    central_avg_history = []

    for step in range(steps):
        rho = cic_deposit(xp,yp,zp)
        C += dt*(s_src*rho - lambda_C*C + D_C*laplacian(C))
        Cx,Cy,Cz = grad_xyz(C)
        ax_curv = mu*bilinear_sample_3D(Cx,xp,yp,zp)
        ay_curv = mu*bilinear_sample_3D(Cy,xp,yp,zp)
        az_curv = mu*bilinear_sample_3D(Cz,xp,yp,zp)
        ax_rep,ay_rep,az_rep = repulsion_accel_3D(xp,yp,zp,Krep)
        ax_therm = rng.normal(0,v_th,num_particles)
        ay_therm = rng.normal(0,v_th,num_particles)
        az_therm = rng.normal(0,v_th,num_particles)
        vx += (ax_curv + ax_rep + ax_therm)*dt
        vy += (ay_curv + ay_rep + ay_therm)*dt
        vz += (az_curv + az_rep + az_therm)*dt
        xp = (xp + vx*dt)%N
        yp = (yp + vy*dt)%N
        zp = (zp + vz*dt)%N

        central = C[N//2-1:N//2+2,N//2-1:N//2+2,N//2-1:N//2+2]
        central_avg_history.append(np.mean(central))

    return np.array(central_avg_history)

# -------------------------------
# Run sweep over Krep
# -------------------------------
Krep_values = np.linspace(0.5,5.0,10)
final_central = []

for krep in Krep_values:
    print(f"Running Krep={krep:.2f}...")
    central_hist = run_sweep_3D(krep)
    final_central.append(np.max(central_hist))

# -------------------------------
# Determine approximate threshold Krep
# -------------------------------
threshold = 0.05 * np.max(final_central)  # 5% below peak as "core onset"
for krep, Cc in zip(Krep_values, final_central):
    if Cc >= threshold:
        print(f"Approximate threshold Krep ~ {krep:.2f}, Ccentral={Cc:.3f}")
        break

# -------------------------------
# Plot Ccentral vs Krep
# -------------------------------
plt.figure(figsize=(10,6))
plt.plot(Krep_values, final_central,'o-',color='blue')
plt.xlabel("Krep")
plt.ylabel("Max Central Average C")
plt.title("3D Threshold Core vs Krep")
plt.grid(True)
plt.show()

\documentclass[linenumbers]{aastex631}
\begin{document}

\title{Simulating Core–Cusp Formation in Dwarf and Massive Galaxies with a Lattice Model}

\author{Michael Feldstein}

\begin{abstract}
The cusp–core problem, in which low-mass galaxies exhibit shallower central densities than predicted by cold dark matter (CDM) simulations, provides context for this study. I present a lattice-based simulation framework in which baryonic particles evolve within a dynamic curvature field that responds to and reshapes the mass distribution. The model tests whether curvature-driven attraction, density-dependent repulsion, and thermal motion may lead to core-like structures in the absence of dark matter. By systematically varying the repulsion strength, $K_{\rm rep}$, three regimes become evident: low values yield cuspy profiles, high values destabilize the core, and intermediate values produce stable, shallow cores resembling those in dwarf galaxies. A narrow range in $K_{\rm rep}$ separates cuspy and core-like behavior. These results suggest that local, density-dependent feedback within a purely geometric framework could contribute to core formation in low-mass galaxies.
\end{abstract}

\section{Introduction}
The steep central density cusps predicted by cold dark matter (CDM) simulations contrast with the shallow cores observed in dwarf galaxies, posing a long-standing challenge in galaxy formation theory \citep{Moore1999, Gentile2004}. Standard CDM models often invoke exotic dark matter physics to reconcile this cusp–core problem. Here, I explore an alternative, purely geometric baryonic mechanism: a dynamic curvature lattice in which particle positions both respond to and reshape the local gravitational landscape. By incorporating density-dependent repulsion and random thermal motion, the model tests whether core-like structures can naturally arise in relatively low-mass systems while cusps persist in higher-mass analogs. This approach provides a framework for investigating core formation without dark matter.

\section{Methods}
Particles (representing baryonic matter) were simulated on a 2D periodic lattice of size $N \times N$, with each particle assigned a position $(x_i, y_i)$ and velocity $(v_{x,i}, v_{y,i})$. Their evolution is governed by three forces: attraction from the curvature field, density-dependent repulsion, and random thermal motion. The curvature lattice field, $C(x,y,t)$, represents the emergent gravitational landscape and evolves dynamically based on a source term from local particle density, a decay rate, and a diffusion constant that smooths local curvature variations. Particle acceleration is the sum of the curvature gradient, the density-dependent repulsion, and a small random velocity component drawn from a Gaussian distribution.

To prevent unphysical central collapse, each particle experiences a repulsive force proportional to its local density within a specified interaction radius. Particle positions and velocities are updated using a forward Euler scheme with periodic boundary conditions. Radial density profiles are measured relative to the lattice center to characterize core and cusp formation, providing the primary diagnostic for the simulations.

Simulations used a grid size of $N=128$, a time step of $\Delta t=0.05$, and 1000 steps. Two analogs were modeled: a dwarf system with $N_p=2000$ particles and a massive system with $N_p=20000$ particles. Complete simulation code and parameters are publicly available on Zenodo at \url{https://doi.org/10.5281/zenodo.16875971}.

\section{Results}
The strength of the density-dependent repulsion ($K_{\rm rep}$) decisively determines whether a central cusp or a shallow core develops. Varying $K_{\rm rep}$ produces qualitatively different structural outcomes ranging from steep cusps to unstable dynamically fluctuating centers to stable cores resembling those seen in dwarf galaxies.

A narrow "sweet spot" of intermediate $K_{\rm rep}$ values, where curvature-driven attraction and repulsive feedback are nearly balanced, produces stable cores. The system's behavior can be categorized into three distinct regimes:

\begin{itemize}
    \item $K_{\rm rep} \lesssim 0.5$ (Low Repulsion): The repulsive force is insufficient to prevent central collapse, producing a steep, cuspy radial density profile.
    \item $K_{\rm rep} \gtrsim 1.0$ (High Repulsion): Repulsion dominates, destabilizing the center and preventing formation of a stable core.
    \item $0.5 \lesssim K_{\rm rep} \lesssim 1.0$ (Intermediate): A stable, shallow core forms by balancing the curvature-driven attraction and density-dependent repulsion.
\end{itemize}

To quantify this behavior, a parameter sweep was performed on $K_{\rm rep}$ for the dwarf analog. The results, shown in Figure~\ref{fig:krep_sweep}, plot the maximum central curvature ($\mathrm{maxC}$) versus $K_{\rm rep}$. Here, $\mathrm{maxC}$ serves as a proxy for the steepness of the central radial density profile: higher $\mathrm{maxC}$ corresponds to cuspy centers, while lower values indicate flatter, core-like structures. The mean $\mathrm{maxC}$ is $0.42$, significantly higher than the median of $0.24$, indicating a right-skewed distribution with occasional high-curvature spikes. These patterns are consistent with the lattice influencing cusp formation and suggest that the core responds to repulsion strength in a non-linear fashion.


\begin{figure}[h]
    \centering
    \includegraphics[width=0.8\linewidth]{krep_sweep.png}
    \caption{Maximum central curvature ($\mathrm{maxC}$), serving as a proxy for central density, as a function of repulsion strength ($K_{\rm rep}$) for the dwarf galaxy analog. Higher $\mathrm{maxC}$ indicates a steeper, cuspy center, while lower values correspond to shallow cores. The dashed red line indicates the approximate threshold separating stable cores from cuspy states.}
    \label{fig:krep_sweep}
\end{figure}

\section{Discussion}
This first-principles simulation demonstrates that a dynamic curvature lattice, coupled with density-dependent repulsion, can reproduce core-like structures in dwarf galaxies while permitting cusp formation in more massive systems. The lattice acts as an emergent gravitational potential for particle distributions in the absence of dark matter. Curvature governs particle motion, and the resulting mass redistribution modifies the curvature, producing the observed core–cusp dichotomy \citep{Moore1999, Gentile2004}. Increasing particle density induces a repulsive component that prevents unphysical central collapse.

While highly idealized (2D, periodic, no explicit dark matter), the model provides a falsifiable framework. Systematically varying the repulsion strength or thermal parameters predicts quantifiable changes in the core density, which can be directly compared to observed galaxies. The identified change in behavior offers a testable prediction. Future work could extend the model to three dimensions, include realistic feedback processes, or explore connections to stellar and supernova-driven dynamics to further assess its applicability to real galaxies.

A separate simulation of a static lattice, in which the curvature field did not evolve in response to particle accumulation, yielded steep, cuspy profiles similar to standard CDM predictions \citep{Navarro1996}. This suggests that lattice feedback is essential for generating stable cores. Compared to particle-mesh gravity, which solves Poisson’s equation for a static potential, or reaction–diffusion analogs, which lack two-way curvature–particle feedback, the dynamic lattice approach provides a geometry-driven mechanism for the cusp–core phenomenon.

\section*{Acknowledgements}
The large language model, ChatGPT-5, helped in refining the language of this manuscript. The author remains solely responsible for the content, accuracy, and scientific integrity of this work.

\nocite{Feldstein2025}
\bibliographystyle{aasjournal}
\bibliography{references}

\end{document}

# --- Quick 3D Krep sweep ---
Krep_values = np.linspace(0.01, 2.0, 12)  # fewer points for speed
maxC_values = []

for krep in Krep_values:
    max_c = run_sweep_sim_3d(krep)  # run_sweep_sim_3d is the 3D version from earlier
    maxC_values.append(max_c)
    print(f"Krep = {krep:.3f}, maxC = {max_c:.4f}")

# Optional: store for later plotting
import numpy as np
np.savez("krep_maxC_3d.npz", Krep=Krep_values, maxC=maxC_values)

# --- Quick 3D Krep sweep ---
Krep_values = np.linspace(0.01, 2.0, 12)  # fewer points for speed
maxC_values = []

for krep in Krep_values:
    max_c = run_sweep_sim_3d(krep)  # run_sweep_sim_3d is the 3D version from earlier
    maxC_values.append(max_c)
    print(f"Krep = {krep:.3f}, maxC = {max_c:.4f}")

# Optional: store for later plotting
import numpy as np
np.savez("krep_maxC_3d.npz", Krep=Krep_values, maxC=maxC_values)

Krep_values = np.linspace(0.01, 2.0, 12)
maxC_values = []

for krep in Krep_values:
    max_c = run_sweep_sim_3d(krep)
    maxC_values.append(max_c)
    print(f"Krep = {krep:.3f}, maxC = {max_c:.4f}")

def laplacian_3d(F):
    # Compute discrete 3D Laplacian
    return (np.roll(F,1,0)+np.roll(F,-1,0)+
            np.roll(F,1,1)+np.roll(F,-1,1)+
            np.roll(F,1,2)+np.roll(F,-1,2)-6*F)

def cic_deposit_3d(xp, yp, zp, N):
    # Cloud-in-cell deposition for 3D grid
    rho = np.zeros((N,N,N))
    i0 = np.floor(xp).astype(int) % N
    j0 = np.floor(yp).astype(int) % N
    k0 = np.floor(zp).astype(int) % N
    i1 = (i0+1)%N; j1 = (j0+1)%N; k1 = (k0+1)%N
    tx = xp - np.floor(xp); ty = yp - np.floor(yp); tz = zp - np.floor(zp)
    w000 = (1-tx)*(1-ty)*(1-tz)
    w100 = tx*(1-ty)*(1-tz)
    w010 = (1-tx)*ty*(1-tz)
    w001 = (1-tx)*(1-ty)*tz
    w101 = tx*(1-ty)*tz
    w011 = (1-tx)*ty*tz
    w110 = tx*ty*(1-tz)
    w111 = tx*ty*tz
    np.add.at(rho,(i0,j0,k0),w000)
    np.add.at(rho,(i1,j0,k0),w100)
    np.add.at(rho,(i0,j1,k0),w010)
    np.add.at(rho,(i0,j0,k1),w001)
    np.add.at(rho,(i1,j0,k1),w101)
    np.add.at(rho,(i0,j1,k1),w011)
    np.add.at(rho,(i1,j1,k0),w110)
    np.add.at(rho,(i1,j1,k1),w111)
    return rho

def run_sweep_sim_3d(Krep, N=64, NP=1000, STEPS=200):
    # Quick 3D sweep simulation
    rng = np.random.default_rng(12345)
    xp = rng.normal(N/2, 10, size=NP) % N
    yp = rng.normal(N/2, 10, size=NP) % N
    zp = rng.normal(N/2, 10, size=NP) % N
    vx = np.zeros(NP); vy = np.zeros(NP); vz = np.zeros(NP)
    C = np.zeros((N,N,N))
    max_C_history = []

    for step in range(STEPS):
        rho = cic_deposit_3d(xp, yp, zp, N)
        C += 0.05*(2.5*rho - 0.005*C + 0.08*laplacian_3d(C))
        # Compute simple central differences for curvature gradient
        Cx = (np.roll(C,-1,0)-np.roll(C,1,0))/2
        Cy = (np.roll(C,-1,1)-np.roll(C,1,1))/2
        Cz = (np.roll(C,-1,2)-np.roll(C,1,2))/2
        ax = Krep*np.sum((xp[:,None]-xp[None,:])/((xp[:,None]-xp[None,:])**2+(yp[:,None]-yp[None,:])**2+(zp[:,None]-zp[None,:])**2+1e-6), axis=1)
        ay = Krep*np.sum((yp[:,None]-yp[None,:])/((xp[:,None]-xp[None,:])**2+(yp[:,None]-yp[None,:])**2+(zp[:,None]-zp[None,:])**2+1e-6), axis=1)
        az = Krep*np.sum((zp[:,None]-zp[None,:])/((xp[:,None]-xp[None,:])**2+(yp[:,None]-yp[None,:])**2+(zp[:,None]-zp[None,:])**2+1e-6), axis=1)
        vx += (Cx.flatten()[xp.astype(int)*N*N + yp.astype(int)*N + zp.astype(int)] + ax)*0.05
        vy += (Cy.flatten()[xp.astype(int)*N*N + yp.astype(int)*N + zp.astype(int)] + ay)*0.05
        vz += (Cz.flatten()[xp.astype(int)*N*N + yp.astype(int)*N + zp.astype(int)] + az)*0.05
        xp = (xp + vx*0.05) % N
        yp = (yp + vy*0.05) % N
        zp = (zp + vz*0.05) % N
        # Track max central curvature
        center_idx = (N//2, N//2, N//2)
        max_C_history.append(C[center_idx])

    return np.max(max_C_history)

Krep_values = np.linspace(0.01, 2.0, 12)
maxC_values = []

for krep in Krep_values:
    max_c = run_sweep_sim_3d(krep)
    maxC_values.append(max_c)
    print(f"Krep = {krep:.3f}, maxC = {max_c:.4f}")

import numpy as np
import matplotlib.pyplot as plt

# --- 3D grid parameters ---
N = 32          # Grid size (32x32x32 for quick run)
NP = 2000       # Number of particles
STEPS = 500     # Fewer steps for speed
DT = 0.05
v_th = 0.05

# --- Lattice parameters ---
s_src = 2.5
lam = 0.005
D_C = 0.08
mu = 2.0
r_rep = 3

# --- Helper functions ---
def laplacian_3d(F):
    return (np.roll(F,1,0)+np.roll(F,-1,0)+
            np.roll(F,1,1)+np.roll(F,-1,1)+
            np.roll(F,1,2)+np.roll(F,-1,2)-6*F)

def cic_deposit_3d(xp, yp, zp):
    rho = np.zeros((N,N,N))
    i0 = np.floor(xp).astype(int) % N
    j0 = np.floor(yp).astype(int) % N
    k0 = np.floor(zp).astype(int) % N
    i1 = (i0+1)%N; j1=(j0+1)%N; k1=(k0+1)%N
    tx = xp - np.floor(xp); ty = yp - np.floor(yp); tz = zp - np.floor(zp)
    w000=(1-tx)*(1-ty)*(1-tz)
    w100=tx*(1-ty)*(1-tz)
    w010=(1-tx)*ty*(1-tz)
    w001=(1-tx)*(1-ty)*tz
    w110=tx*ty*(1-tz)
    w101=tx*(1-ty)*tz
    w011=(1-tx)*ty*tz
    w111=tx*ty*tz
    np.add.at(rho,(i0,j0,k0),w000)
    np.add.at(rho,(i1,j0,k0),w100)
    np.add.at(rho,(i0,j1,k0),w010)
    np.add.at(rho,(i0,j0,k1),w001)
    np.add.at(rho,(i1,j1,k0),w110)
    np.add.at(rho,(i1,j0,k1),w101)
    np.add.at(rho,(i0,j1,k1),w011)
    np.add.at(rho,(i1,j1,k1),w111)
    return rho

def grad_3d(F):
    Fx = (np.roll(F,-1,0)-np.roll(F,1,0))/2.0
    Fy = (np.roll(F,-1,1)-np.roll(F,1,1))/2.0
    Fz = (np.roll(F,-1,2)-np.roll(F,1,2))/2.0
    return Fx, Fy, Fz

def bilinear_sample_3d(F, xp, yp, zp):
    i0 = np.floor(xp).astype(int) % N
    j0 = np.floor(yp).astype(int) % N
    k0 = np.floor(zp).astype(int) % N
    i1 = (i0+1)%N; j1=(j0+1)%N; k1=(k0+1)%N
    tx = xp - np.floor(xp); ty = yp - np.floor(yp); tz = zp - np.floor(zp)
    vals = (
        F[i0,j0,k0]*(1-tx)*(1-ty)*(1-tz) +
        F[i1,j0,k0]*tx*(1-ty)*(1-tz) +
        F[i0,j1,k0]*(1-tx)*ty*(1-tz) +
        F[i0,j0,k1]*(1-tx)*(1-ty)*tz +
        F[i1,j1,k0]*tx*ty*(1-tz) +
        F[i1,j0,k1]*tx*(1-ty)*tz +
        F[i0,j1,k1]*(1-tx)*ty*tz +
        F[i1,j1,k1]*tx*ty*tz
    )
    return vals

def local_density_3d(xp, yp, zp, r=r_rep):
    rho_local = np.zeros(len(xp))
    r2 = r**2
    for i in range(len(xp)):
        dx = (xp - xp[i] + N/2) % N - N/2
        dy = (yp - yp[i] + N/2) % N - N/2
        dz = (zp - zp[i] + N/2) % N - N/2
        dist2 = dx**2 + dy**2 + dz**2
        rho_local[i] = np.sum(dist2 <= r2)/(4/3*np.pi*r**3)
    return rho_local

def repulsion_accel_3d(xp, yp, zp, Krep, r=r_rep):
    rho_local = local_density_3d(xp, yp, zp, r)
    ax = np.zeros_like(xp); ay=np.zeros_like(yp); az=np.zeros_like(zp)
    r2 = r**2
    for i in range(len(xp)):
        dx = (xp[i]-xp + N/2)%N - N/2
        dy = (yp[i]-yp + N/2)%N - N/2
        dz = (zp[i]-zp + N/2)%N - N/2
        dist2 = dx**2 + dy**2 + dz**2
        mask = (dist2>0)&(dist2<=r2)
        ax[i] += Krep*np.sum(dx[mask]/np.sqrt(dist2[mask])*rho_local[mask])
        ay[i] += Krep*np.sum(dy[mask]/np.sqrt(dist2[mask])*rho_local[mask])
        az[i] += Krep*np.sum(dz[mask]/np.sqrt(dist2[mask])*rho_local[mask])
    return ax, ay, az

def run_sweep_sim_3d(Krep):
    rng = np.random.default_rng(12345)
    sigma = 5
    xp = rng.normal(N/2, sigma, size=NP) % N
    yp = rng.normal(N/2, sigma, size=NP) % N
    zp = rng.normal(N/2, sigma, size=NP) % N
    vx = np.zeros(NP); vy = np.zeros(NP); vz = np.zeros(NP)
    C = np.zeros((N,N,N))
    max_C_history = []

    for step in range(STEPS):
        rho = cic_deposit_3d(xp, yp, zp)
        C += DT*(s_src*rho - lam*C + D_C*laplacian_3d(C))
        Cx, Cy, Cz = grad_3d(C)
        ax_curv = mu*bilinear_sample_3d(Cx, xp, yp, zp)
        ay_curv = mu*bilinear_sample_3d(Cy, xp, yp, zp)
        az_curv = mu*bilinear_sample_3d(Cz, xp, yp, zp)
        ax_rep, ay_rep, az_rep = repulsion_accel_3d(xp, yp, zp, Krep)
        ax_therm = rng.normal(0, v_th, NP)
        ay_therm = rng.normal(0, v_th, NP)
        az_therm = rng.normal(0, v_th, NP)
        vx += (ax_curv+ax_rep+ax_therm)*DT
        vy += (ay_curv+ay_rep+ay_therm)*DT
        vz += (az_curv+az_rep+az_therm)*DT
        xp = (xp + vx*DT)%N
        yp = (yp + vy*DT)%N
        zp = (zp + vz*DT)%N
        center = (int(N/2), int(N/2), int(N/2))
        max_C_history.append(C[center])
    return np.max(max_C_history)

# --- Run the sweep ---
Krep_values = np.linspace(0.01, 2.0, 12)
maxC_values = []

print("Running 3D Krep sweep...\n")
for krep in Krep_values:
    max_c = run_sweep_sim_3d(krep)
    maxC_values.append(max_c)
    print(f"Krep = {krep:.3f}, maxC = {max_c:.4f}")

maxC_values = np.array(maxC_values)
mean_C = np.mean(maxC_values)
median_C = np.median(maxC_values)
threshold = 0.2  # example threshold for core formation

print(f"\nMean maxC = {mean_C:.4f}")
print(f"Median maxC = {median_C:.4f}")
print(f"Threshold maxC = {threshold}")

# --- Plot ---
plt.figure(figsize=(8,5))
plt.plot(Krep_values, maxC_values, 'o-', color='green', label='3D maxC')
plt.axhline(y=threshold, color='red', linestyle='--', label='Threshold')
plt.xlabel('Krep (Repulsion Strength)')
plt.ylabel('Max Central Curvature (maxC)')
plt.title('3D Core Stability Sweep')
plt.legend()
plt.grid(True)
plt.show()

import numpy as np
import matplotlib.pyplot as plt

# -------------------------------
# Fast Vectorized 3D Sweep
# -------------------------------
N = 64
num_particles = 8000
steps = 150
dt = 0.05

s_src = 2.5
lambda_C = 0.005
D_C = 0.08
mu = 2.0
r_rep = 2
v_th = 0.05

# -------------------------------
# Helper Functions
# -------------------------------
def laplacian(F):
    return (np.roll(F,1,0)+np.roll(F,-1,0)+
            np.roll(F,1,1)+np.roll(F,-1,1)+
            np.roll(F,1,2)+np.roll(F,-1,2) - 6*F)

def cic_deposit(xp, yp, zp):
    rho = np.zeros((N,N,N))
    i0 = np.floor(xp).astype(int) % N
    j0 = np.floor(yp).astype(int) % N
    k0 = np.floor(zp).astype(int) % N
    i1 = (i0+1)%N; j1=(j0+1)%N; k1=(k0+1)%N
    tx = xp - np.floor(xp); ty = yp - np.floor(yp); tz = zp - np.floor(zp)
    w000=(1-tx)*(1-ty)*(1-tz); w100=tx*(1-ty)*(1-tz)
    w010=(1-tx)*ty*(1-tz); w001=(1-tx)*(1-ty)*tz
    w101=tx*(1-ty)*tz; w011=(1-tx)*ty*tz
    w110=tx*ty*(1-tz); w111=tx*ty*tz
    np.add.at(rho,(i0,j0,k0),w000); np.add.at(rho,(i1,j0,k0),w100)
    np.add.at(rho,(i0,j1,k0),w010); np.add.at(rho,(i0,j0,k1),w001)
    np.add.at(rho,(i1,j0,k1),w101); np.add.at(rho,(i0,j1,k1),w011)
    np.add.at(rho,(i1,j1,k0),w110); np.add.at(rho,(i1,j1,k1),w111)
    return rho

def grad_xyz(F):
    Fx = (np.roll(F,-1,0)-np.roll(F,1,0))/2.0
    Fy = (np.roll(F,-1,1)-np.roll(F,1,1))/2.0
    Fz = (np.roll(F,-1,2)-np.roll(F,1,2))/2.0
    return Fx, Fy, Fz

def bilinear_sample_3D(F, xp, yp, zp):
    i0 = np.floor(xp).astype(int) % N; j0 = np.floor(yp).astype(int) % N; k0 = np.floor(zp).astype(int) % N
    i1 = (i0+1)%N; j1 = (j0+1)%N; k1 = (k0+1)%N
    tx = xp - np.floor(xp); ty = yp - np.floor(yp); tz = zp - np.floor(zp)
    c000 = F[i0,j0,k0]; c100 = F[i1,j0,k0]; c010 = F[i0,j1,k0]; c001 = F[i0,j0,k1]
    c101 = F[i1,j0,k1]; c011 = F[i0,j1,k1]; c110 = F[i1,j1,k0]; c111 = F[i1,j1,k1]
    c00 = c000*(1-tx)+c100*tx; c01 = c001*(1-tx)+c101*tx; c10 = c010*(1-tx)+c110*tx; c11 = c011*(1-tx)+c111*tx
    c0 = c00*(1-ty)+c10*ty; c1 = c01*(1-ty)+c11*ty
    return c0*(1-tz)+c1*tz

def repulsion_accel_3D_vec(xp, yp, zp, Krep):
    # Compute all pairwise displacements vectorized
    dx = (xp[:,None]-xp[None,:] + N/2)%N - N/2
    dy = (yp[:,None]-yp[None,:] + N/2)%N - N/2
    dz = (zp[:,None]-zp[None,:] + N/2)%N - N/2
    dist2 = dx**2 + dy**2 + dz**2
    mask = (dist2>0) & (dist2 <= r_rep**2)
    dist = np.sqrt(dist2 + np.eye(len(xp)))  # avoid divide by zero
    ax = Krep*np.sum(np.divide(dx, dist, out=np.zeros_like(dx), where=mask), axis=1)
    ay = Krep*np.sum(np.divide(dy, dist, out=np.zeros_like(dy), where=mask), axis=1)
    az = Krep*np.sum(np.divide(dz, dist, out=np.zeros_like(dz), where=mask), axis=1)
    return ax, ay, az

# -------------------------------
# Sweep function
# -------------------------------
def run_sweep(Krep):
    rng = np.random.default_rng(12345)
    xp = rng.uniform(0,N,size=num_particles)
    yp = rng.uniform(0,N,size=num_particles)
    zp = rng.uniform(0,N,size=num_particles)
    vx = np.zeros(num_particles); vy = np.zeros(num_particles); vz = np.zeros(num_particles)
    C = np.zeros((N,N,N))
    maxC_hist = []
    for step in range(steps):
        rho = cic_deposit(xp, yp, zp)
        C += dt*(s_src*rho - lambda_C*C + D_C*laplacian(C))
        Cx,Cy,Cz = grad_xyz(C)
        ax_curv = mu*bilinear_sample_3D(Cx, xp, yp, zp)
        ay_curv = mu*bilinear_sample_3D(Cy, xp, yp, zp)
        az_curv = mu*bilinear_sample_3D(Cz, xp, yp, zp)
        ax_rep, ay_rep, az_rep = repulsion_accel_3D_vec(xp, yp, zp, Krep)
        ax_therm = rng.normal(0,v_th,num_particles)
        ay_therm = rng.normal(0,v_th,num_particles)
        az_therm = rng.normal(0,v_th,num_particles)
        vx += (ax_curv + ax_rep + ax_therm)*dt
        vy += (ay_curv + ay_rep + ay_therm)*dt
        vz += (az_curv + az_rep + az_therm)*dt
        xp = (xp + vx*dt)%N; yp = (yp + vy*dt)%N; zp = (zp + vz*dt)%N
        maxC_hist.append(np.max(C))
    return np.max(maxC_hist)

# -------------------------------
# Run sweep
# -------------------------------
if __name__=="__main__":
    Krep_values = np.linspace(0.01,2.0,15)
    Cmax_vals = []
    for K in Krep_values:
        print(f"Running Krep={K:.3f}")
        Cmax_vals.append(run_sweep(K))
    Cmax_vals = np.array(Cmax_vals)

    plt.figure(figsize=(10,6))
    plt.plot(Krep_values, Cmax_vals, marker='o', color='purple')
    plt.xlabel("Krep")
    plt.ylabel("Max Central Curvature (Cmax)")
    plt.title("Fast Vectorized 3D Exploratory Sweep")
    plt.grid(True)
    plt.show()

import numpy as np
import matplotlib.pyplot as plt

# -------------------------------
# Fast Exploratory 3D Simulation
# -------------------------------
N = 80                   # slightly larger grid
num_particles = 3000     # fewer particles for speed
steps = 200              # shorter run
dt = 0.05

s_src = 2.5
lambda_C = 0.005
D_C = 0.08
mu = 2.0
r_rep = 2
v_th = 0.05

# -------------------------------
# Helper functions (same as before)
# -------------------------------
def laplacian(F):
    return (np.roll(F, 1, 0) + np.roll(F, -1, 0) +
            np.roll(F, 1, 1) + np.roll(F, -1, 1) +
            np.roll(F, 1, 2) + np.roll(F, -1, 2) -
            6 * F)

def cic_deposit(xp, yp, zp):
    rho = np.zeros((N, N, N))
    i0 = np.floor(xp).astype(int) % N
    j0 = np.floor(yp).astype(int) % N
    k0 = np.floor(zp).astype(int) % N
    i1 = (i0 + 1) % N
    j1 = (j0 + 1) % N
    k1 = (k0 + 1) % N
    tx = xp - np.floor(xp)
    ty = yp - np.floor(yp)
    tz = zp - np.floor(zp)
    w000 = (1 - tx) * (1 - ty) * (1 - tz)
    w100 = tx * (1 - ty) * (1 - tz)
    w010 = (1 - tx) * ty * (1 - tz)
    w001 = (1 - tx) * (1 - ty) * tz
    w101 = tx * (1 - ty) * tz
    w011 = (1 - tx) * ty * tz
    w110 = tx * ty * (1 - tz)
    w111 = tx * ty * tz
    np.add.at(rho, (i0, j0, k0), w000)
    np.add.at(rho, (i1, j0, k0), w100)
    np.add.at(rho, (i0, j1, k0), w010)
    np.add.at(rho, (i0, j0, k1), w001)
    np.add.at(rho, (i1, j0, k1), w101)
    np.add.at(rho, (i0, j1, k1), w011)
    np.add.at(rho, (i1, j1, k0), w110)
    np.add.at(rho, (i1, j1, k1), w111)
    return rho

def grad_xyz(F):
    Fx = (np.roll(F, -1, 0) - np.roll(F, 1, 0)) / 2.0
    Fy = (np.roll(F, -1, 1) - np.roll(F, 1, 1)) / 2.0
    Fz = (np.roll(F, -1, 2) - np.roll(F, 1, 2)) / 2.0
    return Fx, Fy, Fz

def bilinear_sample_3D(F, xp, yp, zp):
    i0 = np.floor(xp).astype(int) % N
    j0 = np.floor(yp).astype(int) % N
    k0 = np.floor(zp).astype(int) % N
    i1 = (i0 + 1) % N
    j1 = (j0 + 1) % N
    k1 = (k0 + 1) % N
    tx = xp - np.floor(xp)
    ty = yp - np.floor(yp)
    tz = zp - np.floor(zp)

    c000 = F[i0, j0, k0]; c100 = F[i1, j0, k0]
    c010 = F[i0, j1, k0]; c001 = F[i0, j0, k1]
    c101 = F[i1, j0, k1]; c011 = F[i0, j1, k1]
    c110 = F[i1, j1, k0]; c111 = F[i1, j1, k1]

    c00 = c000 * (1 - tx) + c100 * tx
    c01 = c001 * (1 - tx) + c101 * tx
    c10 = c010 * (1 - tx) + c110 * tx
    c11 = c011 * (1 - tx) + c111 * tx

    c0 = c00 * (1 - ty) + c10 * ty
    c1 = c01 * (1 - ty) + c11 * ty

    return c0 * (1 - tz) + c1 * tz

def repulsion_accel_3D(xp, yp, zp, Krep):
    ax = np.zeros_like(xp)
    ay = np.zeros_like(yp)
    az = np.zeros_like(zp)
    r2 = r_rep ** 2
    for i in range(len(xp)):
        dx = (xp[i] - xp + N/2) % N - N/2
        dy = (yp[i] - yp + N/2) % N - N/2
        dz = (zp[i] - zp + N/2) % N - N/2
        dist2 = dx**2 + dy**2 + dz**2
        mask = (dist2 > 0) & (dist2 <= r2)
        if np.any(mask):
            dist = np.sqrt(dist2[mask])
            ax[i] += Krep * np.sum(dx[mask] / dist)
            ay[i] += Krep * np.sum(dy[mask] / dist)
            az[i] += Krep * np.sum(dz[mask] / dist)
    return ax, ay, az

# -------------------------------
# Sweep function
# -------------------------------
def run_sweep_3D(Krep):
    rng = np.random.default_rng(12345)
    xp = rng.uniform(0, N, size=num_particles)
    yp = rng.uniform(0, N, size=num_particles)
    zp = rng.uniform(0, N, size=num_particles)
    vx = np.zeros(num_particles)
    vy = np.zeros(num_particles)
    vz = np.zeros(num_particles)
    C = np.zeros((N, N, N))
    max_C_history = []

    for step in range(steps):
        rho = cic_deposit(xp, yp, zp)
        C += dt * (s_src * rho - lambda_C * C + D_C * laplacian(C))
        Cx, Cy, Cz = grad_xyz(C)
        ax_curv = mu * bilinear_sample_3D(Cx, xp, yp, zp)
        ay_curv = mu * bilinear_sample_3D(Cy, xp, yp, zp)
        az_curv = mu * bilinear_sample_3D(Cz, xp, yp, zp)
        ax_rep, ay_rep, az_rep = repulsion_accel_3D(xp, yp, zp, Krep)
        ax_therm = rng.normal(0, v_th, size=num_particles)
        ay_therm = rng.normal(0, v_th, size=num_particles)
        az_therm = rng.normal(0, v_th, size=num_particles)
        vx += (ax_curv + ax_rep + ax_therm) * dt
        vy += (ay_curv + ay_rep + ay_therm) * dt
        vz += (az_curv + az_rep + az_therm) * dt
        xp = (xp + vx * dt) % N
        yp = (yp + vy * dt) % N
        zp = (zp + vz * dt) % N
        max_C_history.append(np.max(C))

    Cmax = np.max(max_C_history)
    return Cmax

# -------------------------------
# Run the exploratory sweep
# -------------------------------
if __name__ == "__main__":
    Krep_values = np.linspace(0.5, 5.0, 10)  # start at 0.5, end at 5
    results = []

    for krep in Krep_values:
        print(f"Running Krep={krep:.2f}...")
        Cmax = run_sweep_3D(krep)
        results.append((krep, Cmax))

    results = np.array(results)

    # Save results
    np.savetxt("fast3D_cmax_vs_krep.txt", results, header="Krep\tCmax", fmt="%.6f")
    print("\nFast 3D sweep data saved as 'fast3D_cmax_vs_krep.txt'")

    # Plot
    plt.figure(figsize=(10,6))
    plt.plot(results[:,0], results[:,1], 'o-', color='green', label='Cmax')
    plt.xlabel("Krep")
    plt.ylabel("Max Central Curvature")
    plt.title("Fast Exploratory 3D Sweep")
    plt.grid(True)
    plt.legend()
    plt.show()

import matplotlib.pyplot as plt
import matplotlib.patches as patches

# Define the three regimes
regimes = [
    {"label": "Low Krep (<0.5)\nRepulsion weak\n→ Central collapse\n→ Steep cusp",
     "color": "#4c72b0", "maxC": 0.9},
    {"label": "Intermediate Krep (0.5–1.0)\nCurvature ≈ Repulsion\n→ Stable shallow core",
     "color": "#55a868", "maxC": 0.3},
    {"label": "High Krep (>1.0)\nRepulsion dominates\n→ Center unstable/fluctuating",
     "color": "#c44e52", "maxC": 0.6},
]

fig, ax = plt.subplots(figsize=(6, 6))
ax.axis('off')

# Draw boxes and arrows
y_start = 0.8
y_step = 0.25

for i, regime in enumerate(regimes):
    rect = patches.FancyBboxPatch(
        (0.1, y_start - i*y_step), 0.8, 0.2,
        boxstyle="round,pad=0.05", facecolor=regime["color"], alpha=0.7
    )
    ax.add_patch(rect)
    ax.text(0.5, y_start - i*y_step + 0.1, regime["label"],
            ha="center", va="center", fontsize=10, color="white" if i!=1 else "black")

# Draw arrows connecting boxes
for i in range(len(regimes)-1):
    ax.annotate("", xy=(0.5, y_start - (i+1)*y_step + 0.2),
                xytext=(0.5, y_start - i*y_step),
                arrowprops=dict(facecolor='black', shrink=0.05, width=1, headwidth=8))

# Add title
ax.text(0.5, 1.05, "Cusp–Core Regimes vs. Krep", ha="

import matplotlib.pyplot as plt
import matplotlib.patches as patches

# Define the three regimes
regimes = [
    {"label": "Low Krep (<0.5)\nRepulsion weak\n→ Central collapse\n→ Steep cusp",
     "color": "#4c72b0", "maxC": 0.9},
    {"label": "Intermediate Krep (0.5–1.0)\nCurvature ≈ Repulsion\n→ Stable shallow core",
     "color": "#55a868", "maxC": 0.3},
    {"label": "High Krep (>1.0)\nRepulsion dominates\n→ Center unstable/fluctuating",
     "color": "#c44e52", "maxC": 0.6},
]

fig, ax = plt.subplots(figsize=(6, 6))
ax.axis('off')

# Draw boxes and arrows
y_start = 0.8
y_step = 0.25

for i, regime in enumerate(regimes):
    rect = patches.FancyBboxPatch(
        (0.1, y_start - i*y_step), 0.8, 0.2,
        boxstyle="round,pad=0.05", facecolor=regime["color"], alpha=0.7
    )
    ax.add_patch(rect)
    ax.text(0.5, y_start - i*y_step + 0.1, regime["label"],
            ha="center", va="center", fontsize=10, color="white" if i!=1 else "black")

# Draw arrows connecting boxes
for i in range(len(regimes)-1):
    ax.annotate("", xy=(0.5, y_start - (i+1)*y_step + 0.2),
                xytext=(0.5, y_start - i*y_step),
                arrowprops=dict(facecolor='black', shrink=0.05, width=1, headwidth=8))

# Add title
ax.text(0.5, 1.05, "Cusp-Core Regimes vs. Krep", ha="center", fontsize=12, fontweight="bold")

plt.tight_layout()
plt.show()

import numpy as np
import matplotlib.pyplot as plt

# -------------------------------
# Minimal 3D Threshold Core Sweep
# -------------------------------
N = 80                   # grid size
num_particles = 5000     # more particles for 3D
steps = 400              # longer run for gradual core formation
dt = 0.05

s_src = 1.2              # reduced for smoother source
lambda_C = 0.005
D_C = 0.12               # slightly higher diffusion
mu = 2.0
r_rep = 2.5
v_th = 0.05

# -------------------------------
# Helper functions
# -------------------------------
def laplacian(F):
    return (np.roll(F, 1, 0) + np.roll(F, -1, 0) +
            np.roll(F, 1, 1) + np.roll(F, -1, 1) +
            np.roll(F, 1, 2) + np.roll(F, -1, 2) -
            6 * F)

def cic_deposit(xp, yp, zp):
    rho = np.zeros((N, N, N))
    i0 = np.floor(xp).astype(int) % N
    j0 = np.floor(yp).astype(int) % N
    k0 = np.floor(zp).astype(int) % N
    i1 = (i0 + 1) % N

import numpy as np
import matplotlib.pyplot as plt

# -------------------------------
# Minimal 3D Threshold Core Sweep
# -------------------------------
N = 80                   # grid size
num_particles = 5000     # more particles for 3D
steps = 400              # longer run for gradual core formation
dt = 0.05

s_src = 1.2              # reduced for smoother source
lambda_C = 0.005
D_C = 0.12               # slightly higher diffusion
mu = 2.0
r_rep = 2.5
v_th = 0.05

# -------------------------------
# Helper functions
# -------------------------------
def laplacian(F):
    return (np.roll(F, 1, 0) + np.roll(F, -1, 0) +
            np.roll(F, 1, 1) + np.roll(F, -1, 1) +
            np.roll(F, 1, 2) + np.roll(F, -1, 2) -
            6 * F)

def cic_deposit(xp, yp, zp):
    rho = np.zeros((N, N, N))
    i0 = np.floor(xp).astype(int) % N
    j0 = np.floor(yp).astype(int) % N
    k0 = np.floor(zp).astype(int) % N
    i1 = (i0 + 1) % N

import numpy as np
import matplotlib.pyplot as plt

# -------------------------------
# Minimal 3D Threshold Core Sweep
# -------------------------------
N = 80                   # grid size
num_particles = 5000     # more particles for 3D
steps = 400              # longer run for gradual core formation
dt = 0.05

s_src = 1.2              # reduced for smoother source
lambda_C = 0.005
D_C = 0.12               # slightly higher diffusion
mu = 2.0
r_rep = 2.5
v_th = 0.05

# -------------------------------
# Helper functions
# -------------------------------
def laplacian(F):
    return (np.roll(F, 1, 0) + np.roll(F, -1, 0) +
            np.roll(F, 1, 1) + np.roll(F, -1, 1) +
            np.roll(F, 1, 2) + np.roll(F, -1, 2) -
            6 * F)

def cic_deposit(xp, yp, zp):
    rho = np.zeros((N, N, N))
    i0 = np.floor(xp).astype(int) % N
    j0 = np.floor(yp).astype(int) % N
    k0 = np.floor(zp).astype(int) % N
    i1 = (i0 + 1) % N
    j1 = (j0 + 1) % N
    k1 = (k0 + 1) % N
    tx, ty, tz = xp - np.floor(xp), yp - np.floor(yp), zp - np.floor(zp)
    w000 = (1 - tx)*(1 - ty)*(1 - tz)
    w100 = tx*(1 - ty)*(1 - tz)
    w010 = (1 - tx)*ty*(1 - tz)
    w001 = (1 - tx)*(1 - ty)*tz
    w101 = tx*(1 - ty)*tz
    w011 = (1 - tx)*ty*tz
    w110 = tx*ty*(1 - tz)
    w111 = tx*ty*tz
    np.add.at(rho, (i0,j0,k0), w000)
    np.add.at(rho, (i1,j0,k0), w100)
    np.add.at(rho, (i0,j1,k0), w010)
    np.add.at(rho, (i0,j0,k1), w001)
    np.add.at(rho, (i1,j0,k1), w101)
    np.add.at(rho, (i0,j1,k1), w011)
    np.add.at(rho, (i1,j1,k0), w110)
    np.add.at(rho, (i1,j1,k1), w111)
    return rho

def grad_xyz(F):
    Fx = (np.roll(F, -1, 0) - np.roll(F, 1, 0))/2.0
    Fy = (np.roll(F, -1, 1) - np.roll(F, 1, 1))/2.0
    Fz = (np.roll(F, -1, 2) - np.roll(F, 1, 2))/2.0
    return Fx, Fy, Fz

def bilinear_sample_3D(F, xp, yp, zp):
    i0 = np.floor(xp).astype(int) % N
    j0 = np.floor(yp).astype(int) % N
    k0 = np.floor(zp).astype(int) % N
    i1, j1, k1 = (i0+1)%N, (j0+1)%N, (k0+1)%N
    tx, ty, tz = xp - np.floor(xp), yp - np.floor(yp), zp - np.floor(zp)
    c000, c100 = F[i0,j0,k0], F[i1,j0,k0]
    c010, c001 = F[i0,j1,k0], F[i0,j0,k1]
    c101, c011 = F[i1,j0,k1], F[i0,j1,k1]
    c110, c111 = F[i1,j1,k0], F[i1,j1,k1]
    c00 = c000*(1-tx)+c100*tx
    c01 = c001*(1-tx)+c101*tx
    c10 = c010*(1-tx)+c110*tx
    c11 = c011*(1-tx)+c111*tx
    c0 = c00*(1-ty)+c10*ty
    c1 = c01*(1-ty)+c11*ty
    return c0*(1-tz)+c1*tz

def repulsion_accel_3D(xp, yp, zp, Krep):
    ax, ay, az = np.zeros_like(xp), np.zeros_like(yp), np.zeros_like(zp)
    r2 = r_rep**2
    for i in range(len(xp)):
        dx = (xp[i]-xp+N/2)%N - N/2
        dy = (yp[i]-yp+N/2)%N - N/2
        dz = (zp[i]-zp+N/2)%N - N/2
        dist2 = dx**2 + dy**2 + dz**2
        mask = (dist2>0) & (dist2<=r2)
        if np.any(mask):
            dist = np.sqrt(dist2[mask])
            ax[i] += Krep * np.sum(dx[mask]/dist)
            ay[i] += Krep * np.sum(dy[mask]/dist)
            az[i] += Krep * np.sum(dz[mask]/dist)
    return ax, ay, az

# -------------------------------
# Sweep function
# -------------------------------
def run_sweep_3D(Krep):
    rng = np.random.default_rng(12345)
    xp, yp, zp = rng.uniform(0,N,num_particles), rng.uniform(0,N,num_particles), rng.uniform(0,N,num_particles)
    vx, vy, vz = np.zeros(num_particles), np.zeros(num_particles), np.zeros(num_particles)
    C = np.zeros((N,N,N))
    max_C_history = []
    central_C_history = []

    for step in range(steps):
        rho = cic_deposit(xp, yp, zp)
        C += dt * (s_src*rho - lambda_C*C + D_C*laplacian(C))
        Cx, Cy, Cz = grad_xyz(C)
        ax_curv = mu*bilinear_sample_3D(Cx, xp, yp, zp)
        ay_curv = mu*bilinear_sample_3D(Cy, xp, yp, zp)
        az_curv = mu*bilinear_sample_3D(Cz, xp, yp, zp)
        ax_rep, ay_rep, az_rep = repulsion_accel_3D(xp, yp, zp, Krep)
        ax_therm = rng.normal(0, v_th, num_particles)
        ay_therm = rng.normal(0, v_th, num_particles)
        az_therm = rng.normal(0, v_th, num_particles)
        vx += (ax_curv + ax_rep + ax_therm)*dt
        vy += (ay_curv + ay_rep + ay_therm)*dt
        vz += (az_curv + az_rep + az_therm)*dt
        xp = (xp + vx*dt)%N
        yp = (yp + vy*dt)%N
        zp = (zp + vz*dt)%N

        max_C_history.append(np.max(C))
        central = C[N//2-1:N//2+2, N//2-1:N//2+2, N//2-1:N//2+2]
        central_C_history.append(np.mean(central))

    return np.array(max_C_history), np.array(central_C_history)

# ----------------

import numpy as np
import matplotlib.pyplot as plt
import os

# =============================================================================
# 3D Dynamic Lattice Simulation for Core–Cusp Formation
# =============================================================================

# --- Simulation parameters ---
N = 64             # Grid size (64^3 for speed)
STEPS = 500
DT = 0.05

# Dwarf analog
NP_dwarf = 1000
Krep_dwarf = 1.0
v_th_dwarf = 0.1

# Massive analog
NP_massive = 5000
Krep_massive = 0.2
v_th_massive = 0.05

# Common parameters
PRINT_EVERY = 50
s_src = 2.5
lam = 0.005
D_C = 0.08
mu = 2.0
r_rep = 3

OUT_DIR = "dynamic_3d_output"
os.makedirs(OUT_DIR, exist_ok=True)

# --- Helper functions ---
def laplacian(F):
    return (
        np.roll(F, 1, 0) + np.roll(F, -1, 0) +
        np.roll(F, 1, 1) + np.roll(F, -1, 1) +
        np.roll(F, 1, 2) + np.roll(F, -1, 2) - 6*F
    )

def cic_deposit(xp, yp, zp):
    rho = np.zeros((N,N,N))
    i0 = np.floor(xp).astype(int) % N
    j0 = np.floor(yp).astype(int) % N
    k0 = np.floor(zp).astype(int) % N
    i1, j1, k1 = (i0+1)%N, (j0+1)%N, (k0+1)%N
    tx, ty, tz = xp - np.floor(xp), yp - np.floor(yp), zp - np.floor(zp)
    w000 = (1-tx)*(1-ty)*(1-tz)
    w100 = tx*(1-ty)*(1-tz)
    w010 = (1-tx)*ty*(1-tz)
    w001 = (1-tx)*(1-ty)*tz
    w101 = tx*(1-ty)*tz
    w011 = (1-tx)*ty*tz
    w110 = tx*ty*(1-tz)
    w111 = tx*ty*tz
    np.add.at(rho, (i0,j0,k0), w000)
    np.add.at(rho, (i1,j0,k0), w100)
    np.add.at(rho, (i0,j1,k0), w010)
    np.add.at(rho, (i0,j0,k1), w001)
    np.add.at(rho, (i1,j0,k1), w101)
    np.add.at(rho, (i0,j1,k1), w011)
    np.add.at(rho, (i1,j1,k0), w110)
    np.add.at(rho, (i1,j1,k1), w111)
    return rho

def grad_xyz(F):
    Fx = (np.roll(F,-1,0)-np.roll(F,1,0))/2.0
    Fy = (np.roll(F,-1,1)-np.roll(F,1,1))/2.0
    Fz = (np.roll(F,-1,2)-np.roll(F,1,2))/2.0
    return Fx, Fy, Fz

def trilinear_sample(F, xp, yp, zp):
    i0 = np.floor(xp).astype(int) % N
    j0 = np.floor(yp).astype(int) % N
    k0 = np.floor(zp).astype(int) % N
    i1, j1, k1 = (i0+1)%N, (j0+1)%N, (k0+1)%N
    tx, ty, tz = xp - np.floor(xp), yp - np.floor(yp), zp - np.floor(zp)
    f000 = F[i0,j0,k0]; f100 = F[i1,j0,k0]; f010 = F[i0,j1,k0]; f001 = F[i0,j0,k1]
    f101 = F[i1,j0,k1]; f011 = F[i0,j1,k1]; f110 = F[i1,j1,k0]; f111 = F[i1,j1,k1]
    c00 = f000*(1-tx)+f100*tx
    c01 = f001*(1-tx)+f101*tx
    c10 = f010*(1-tx)+f110*tx
    c11 = f011*(1-tx)+f111*tx
    c0 = c00*(1-ty)+c10*ty
    c1 = c01*(1-ty)+c11*ty
    return c0*(1-tz)+c1*tz

def local_density(xp, yp, zp, r=r_rep):
    Np = len(xp)
    rho_local = np.zeros(Np)
    r2 = r**2
    for i in range(Np):
        dx = (xp - xp[i] + N/2) % N - N/2
        dy = (yp - yp[i] + N/2) % N - N/2
        dz = (zp - zp[i] + N/2) % N - N/2
        dist2 = dx**2 + dy**2 + dz**2
        rho_local[i] = np.sum(dist2 <= r2) / ((4/3)*np.pi*r2**(3/2))
    return rho_local

def repulsion_accel(xp, yp, zp, Krep, r=r_rep):
    rho_local = local_density(xp, yp, zp, r)
    ax = np.zeros_like(xp)
    ay = np.zeros_like(yp)
    az = np.zeros_like(zp)
    r2 = r**2
    for i in range(len(xp)):
        dx = (xp[i] - xp + N/2) % N - N/2
        dy = (yp[i] - yp + N/2) % N - N/2
        dz = (zp[i] - zp + N/2) % N - N/2
        dist2 = dx**2 + dy**2 + dz**2
        mask = (dist2 > 0) & (dist2 <= r2)
        ax[i] += Krep * np.sum(dx[mask]/np.sqrt(dist2[mask]) * rho_local[mask])
        ay[i] += Krep * np.sum(dy[mask]/np.sqrt(dist2[mask]) * rho_local[mask])
        az[i] += Krep * np.sum(dz[mask]/np.sqrt(dist2[mask]) * rho_local[mask])
    return ax, ay, az

# --- Simulation runner ---
def run_simulation(NP_val, Krep, v_th, seed=12345):
    rng = np.random.default_rng(seed)
    xp = rng.normal(N/2, 10, NP_val) % N
    yp = rng.normal(N/2, 10, NP_val) % N
    zp = rng.normal(N/2, 10, NP_val) % N
    vx = np.zeros(NP_val); vy = np.zeros(NP_val); vz = np.zeros(NP_val)
    C = np.zeros((N,N,N))
    maxC_history = []

    for step in range(1, STEPS+1):
        rho = cic_deposit(xp, yp, zp)
        C += DT*(s_src*rho - lam*C + D_C*laplacian(C))
        Cx, Cy, Cz = grad_xyz(C)
        ax_curv = mu * trilinear_sample(Cx, xp, yp, zp)
        ay_curv = mu * trilinear_sample(Cy, xp, yp, zp)
        az_curv = mu * trilinear_sample(Cz, xp, yp, zp)
        ax_rep, ay_rep, az_rep = repulsion_accel(xp, yp, zp, Krep)
        ax_therm = rng.normal(0, v_th, NP_val)
        ay_therm = rng.normal(0, v_th, NP_val)
        az_therm = rng.normal(0, v_th, NP_val)
        vx += (ax_curv + ax_rep + ax_therm) * DT
        vy += (ay_curv + ay_rep + ay_therm) * DT
        vz += (az_curv + az_rep + az_therm) * DT
        xp = (xp + vx*DT) % N
        yp = (yp + vy*DT) % N
        zp = (zp + vz*DT) % N
        maxC_history.append(C[N//2,N//2,N//2])
        if step % PRINT_EVERY == 0:
            print(f"Step {step}/{STEPS}: max central curvature = {maxC_history[-1]:.4f}")

    return xp, yp, zp, np.array(maxC_history)

# --- Main execution ---
if __name__=="__main__":
    print("Running 3D dwarf analog...")
    xp_d, yp_d, zp_d, maxC_d = run_simulation(NP_dwarf, Krep_dwarf, v_th_dwarf)
    print("Running 3D massive analog...")
    xp_m, yp_m, zp_m, maxC_m = run_simulation(NP_massive, Krep_massive, v_th_massive)

    # Save results
    np.save(os.path.join(OUT_DIR,"positions_dwarf_3d.npy"), np.vstack([xp_d, yp_d, zp_d]))
    np.save(os.path.join(OUT_DIR,"maxC_dwarf_3d.npy"), maxC_d)
    np.save(os.path.join(OUT_DIR,"positions_massive_3d.npy"), np.vstack([xp_m, yp_m, zp_m]))
    np.save(os.path.join(OUT_DIR,"maxC_massive_3d.npy"), maxC_m)

    print(f"All 3D dynamic lattice data saved in folder '{OUT_DIR}'")