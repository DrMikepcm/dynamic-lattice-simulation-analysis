# -*- coding: utf-8 -*-
"""Matrix_simulation2.0.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1H4PUYlu2z_BN-kNu6zfU_Ph49ogMZH6v
"""

import matplotlib.pyplot as plt
import numpy as np

# Select two representative Krep values
Krep_stable = 0.219   # low, stable core
Krep_unstable = 1.372 # high, unstable cusp

# Extract central density vs step
steps_stable, density_stable = results[Krep_stable][:,0], results[Krep_stable][:,1]
steps_unstable, density_unstable = results[Krep_unstable][:,0], results[Krep_unstable][:,1]

# Plot
plt.figure(figsize=(10,6))
plt.plot(steps_stable, density_stable, color='blue', lw=2, label=f"Stable Krep={Krep_stable}")
plt.plot(steps_unstable, density_unstable, color='red', lw=2, label=f"Unstable Krep={Krep_unstable}")
plt.xlabel("Simulation Step")
plt.ylabel("Central Particle Count")
plt.title("Core Stability as a Function of Repulsion Strength Krep")
plt.legend()
plt.grid(True)

# Optional: annotate stability threshold region
plt.axvline(x=0, color='grey', alpha=0)  # placeholder if needed
plt.tight_layout()
plt.show()

import matplotlib.pyplot as plt

# Choose representative Krep values for stable and unstable cores
Krep_stable_val = 0.219   # example stable
Krep_unstable_val = 1.372 # example unstable

# Find the closest keys in the results dictionary
key_stable = min(results.keys(), key=lambda k: abs(k - Krep_stable_val))
key_unstable = min(results.keys(), key=lambda k: abs(k - Krep_unstable_val))

# Extract steps and central density
steps_stable, density_stable = results[key_stable][:,0], results[key_stable][:,1]
steps_unstable, density_unstable = results[key_unstable][:,0], results[key_unstable][:,1]

# Plot both on the same figure
plt.figure(figsize=(10,6))
plt.plot(steps_stable, density_stable, label=f"Stable Core (Krep={key_stable:.3f})", color='blue')
plt.plot(steps_unstable, density_unstable, label=f"Unstable Core (Krep={key_unstable:.3f})", color='red')
plt.xlabel("Simulation Step")
plt.ylabel("Central Particle Count")
plt.title("Core Stability vs Repulsion Strength")
plt.legend()
plt.grid(True)
plt.show()

import numpy as np
import matplotlib.pyplot as plt

# --- Simulation parameters ---
N = 128
NP = 2000
DT = 0.05
STEPS = 1000
PRINT_EVERY = 50

s_src = 2.5
lam = 0.005
D_C = 0.08
mu = 2.0
v_th = 0.1
r_rep = 3

# --- Helper functions ---
def laplacian(F):
    return (np.roll(F,1,0)+np.roll(F,-1,0)+np.roll(F,1,1)+np.roll(F,-1,1)-4*F)

def cic_deposit(xp, yp):
    rho = np.zeros((N,N))
    i0 = np.floor(xp).astype(int) % N
    j0 = np.floor(yp).astype(int) % N
    i1 = (i0+1)%N; j1=(j0+1)%N
    tx = xp - np.floor(xp); ty = yp - np.floor(yp)
    w00=(1-tx)*(1-ty); w10=tx*(1-ty); w01=(1-tx)*ty; w11=tx*ty
    np.add.at(rho, (i0,j0), w00)
    np.add.at(rho, (i1,j0), w10)
    np.add.at(rho, (i0,j1), w01)
    np.add.at(rho, (i1,j1), w11)
    return rho

def grad_xy(F):
    Fx = (np.roll(F,-1,1)-np.roll(F,1,1))/2.0
    Fy = (np.roll(F,-1,0)-np.roll(F,1,0))/2.0
    return Fx, Fy

def bilinear_sample(F, xp, yp):
    i0 = np.floor(xp).astype(int) % N
    j0 = np.floor(yp).astype(int) % N
    i1 = (i0+1)%N; j1=(j0+1)%N
    tx = xp - np.floor(xp)
    ty = yp - np.floor(yp)
    f00 = F[i0,j0]; f10 = F[i1,j0]; f01 = F[i0,j1]; f11 = F[i1,j1]

import numpy as np
import matplotlib.pyplot as plt

# --- Simulation parameters ---
N = 128
NP = 2000
DT = 0.05
STEPS = 1000
PRINT_EVERY = 50

s_src = 2.5
lam = 0.005
D_C = 0.08
mu = 2.0
v_th = 0.1
r_rep = 3

# --- Helper functions ---
def laplacian(F):
    return (np.roll(F,1,0)+np.roll(F,-1,0)+np.roll(F,1,1)+np.roll(F,-1,1)-4*F)

def cic_deposit(xp, yp):
    rho = np.zeros((N,N))
    i0 = np.floor(xp).astype(int) % N
    j0 = np.floor(yp).astype(int) % N
    i1 = (i0+1)%N; j1=(j0+1)%N
    tx = xp - np.floor(xp); ty = yp - np.floor(yp)
    w00=(1-tx)*(1-ty); w10=tx*(1-ty); w01=(1-tx)*ty; w11=tx*ty
    np.add.at(rho, (i0,j0), w00)
    np.add.at(rho, (i1,j0), w10)
    np.add.at(rho, (i0,j1), w01)
    np.add.at(rho, (i1,j1), w11)
    return rho

def grad_xy(F):
    Fx = (np.roll(F,-1,1)-np.roll(F,1,1))/2.0
    Fy = (np.roll(F,-1,0)-np.roll(F,1,0))/2.0
    return Fx, Fy

def bilinear_sample(F, xp, yp):
    i0 = np.floor(xp).astype(int) % N
    j0 = np.floor(yp).astype(int) % N
    i1 = (i0+1)%N; j1=(j0+1)%N
    tx = xp - np.floor(xp)
    ty = yp - np.floor(yp)
    f00 = F[i0,j0]; f10 = F[i1,j0]; f01 = F[i0,j1]; f11 = F[i1,j1]
    return (1-tx)*(1-ty)*f00 + tx*(1-ty)*f10 + (1-tx)*ty*f01 + tx*ty*f11

def local_density(xp, yp, r=r_rep):
    Np = len(xp)
    rho_local = np.zeros(Np)
    r2 = r**2
    for i in range(Np):
        dx = (xp - xp[i] + N/2) % N - N/2
        dy = (yp - yp[i] + N/2) % N - N/2
        dist2 = dx**2 + dy**2
        rho_local[i] = np.sum(dist2 <= r2) / (np.pi*r2)
    return rho_local

def repulsion_accel(xp, yp, Krep, r=r_rep):
    rho_local = local_density(xp, yp, r)
    ax = np.zeros_like(xp)
    ay = np.zeros_like(yp)
    r2 = r**2
    for i in range(len(xp)):
        dx = (xp[i] - xp + N/2) % N - N/2
        dy = (yp[i] - yp + N/2) % N - N/2
        dist2 = dx**2 + dy**2
        mask = (dist2 > 0) & (dist2 <= r2)
        ax[i] += Krep * np.sum(dx[mask]/np.sqrt(dist2[mask]) * rho_local[mask])
        ay[i] += Krep * np.sum(dy[mask]/np.sqrt(dist2[mask]) * rho_local[mask])
    return ax, ay

# --- Simulation runner ---
def run_sim(Krep):
    rng = np.random.default_rng(12345)
    cx, cy = N/2, N/2
    sigma = 10
    xp = rng.normal(cx, sigma, size=NP) % N
    yp = rng.normal(cy, sigma, size=NP) % N
    vx = np.zeros(NP)
    vy = np.zeros(NP)
    C = np.zeros((N,N))
    center_density = []

    for step in range(1, STEPS+1):
        rho = cic_deposit(xp, yp)
        C += DT*(s_src*rho - lam*C + D_C*laplacian(C))
        Cx, Cy = grad_xy(C)
        ax_curv = mu * bilinear_sample(Cx, xp, yp)
        ay_curv = mu * bilinear_sample(Cy, xp, yp)
        ax_rep, ay_rep = repulsion_accel(xp, yp, Krep)
        ax_therm = rng.normal(0, v_th, size=NP)
        ay_therm = rng.normal(0, v_th, size=NP)
        vx += (ax_curv + ax_rep + ax_therm)*DT
        vy += (ay_curv + ay_rep + ay_therm)*DT
        xp = (xp + vx*DT) % N
        yp = (yp + vy*DT) % N
        if step % PRINT_EVERY == 0 or step==1:
            dx = (xp - cx + N/2) % N - N/2
            dy = (yp - cy + N/2) % N - N/2
            r2 = dx**2 + dy**2
            center_density.append((step, np.sum(r2 <= 1)))
    return np.array(center_density)

# --- Run parameter sweep ---
Krep_values = np.linspace(0.01, 2.0, 20)
results = {}

for Krep in Krep_values:
    print(f"Running Krep={Krep:.3f}...")
    results[Krep] = run_sim(Krep)

# --- Save results to file (Google Drive) ---
np.save("/content/drive/MyDrive/krep_sweep_results.npy", results)
print("Saved results to Google Drive!")

from google.colab import drive
drive.mount('/content/drive')

np.save("/content/drive/MyDrive/simulation_results/krep_sweep_results.npy", results)
print("Results saved!")

!mkdir -p /content/drive/MyDrive/simulation_results

np.save("/content/drive/MyDrive/simulation_results/krep_sweep_results.npy", results)
print("Results saved!")

import matplotlib.pyplot as plt

# Example: maxC values from your previous simulation sweep
Krep_values = [0.010, 0.115, 0.219, 0.324, 0.429, 0.534, 0.638, 0.743, 0.848, 0.953,
               1.057, 1.162, 1.267, 1.372, 1.476, 1.581, 1.686, 1.791, 1.895, 2.000]
maxC_values = [0.00488, 0.03861, 0.08249, 0.17249, 0.02921, 0.31195, 0.15188, 0.11947,
               0.12898, 0.12105, 0.34623, 0.80668, 0.45475, 1.22258, 0.29804, 0.17487,
               0.88935, 1.55356, 0.49632, 0.99879]

plt.figure(figsize=(10,6))

for Krep, maxC in zip(Krep_values, maxC_values):
    data = results[Krep]  # your central density array from previous simulation
    steps, density = data[:,0], data[:,1]
    plt.plot(steps, density, label=f"Krep={Krep:.3f}, maxC={maxC:.3f}")

plt.xlabel("Simulation Step")
plt.ylabel("Central Particle Count")
plt.title("Central Density vs Simulation Step for Different Repulsion Strengths")
plt.legend(bbox_to_anchor=(1.05, 1), loc='upper left')  # place legend outside plot
plt.grid(True)
plt.tight_layout()
plt.show()

import numpy as np
import matplotlib.pyplot as plt

# Load results (if not in memory)
results = np.load("/content/drive/MyDrive/krep_sweep_results.npy", allow_pickle=True).item()

# Choose representative Krep values
Krep_stable_val = 0.2   # below stability threshold
Krep_unstable_val = 1.4 # above stability threshold

# Find the closest keys in the results dictionary
key_stable = min(results.keys(), key=lambda k: abs(k - Krep_stable_val))
key_unstable = min(results.keys(), key=lambda k: abs(k - Krep_unstable_val))

# Extract central density vs step
steps_stable, density_stable = results[key_stable][:,0], results[key_stable][:,1]
steps_unstable, density_unstable = results[key_unstable][:,0], results[key_unstable][:,1]

# Plot
plt.figure(figsize=(10,6))
plt.plot(steps_stable, density_stable, label=f"Stable core, Krep={key_stable:.2f}", color='blue')
plt.plot(steps_unstable, density_unstable, label=f"Unstable core, Krep={key_unstable:.2f}", color='red')
plt.xlabel("Simulation Step")
plt.ylabel("Central Particle Count")
plt.title("Representative Stable vs Unstable Core Dynamics")
plt.legend()
plt.grid(True)
plt.show()

import numpy as np
import matplotlib.pyplot as plt

# Data you have
Krep = np.array([0.01, 0.1147, 0.219, 0.324, 0.4289, 0.5336, 0.6384,
                 0.8478, 0.9526, 1.1621, 1.3715, 1.4763, 1.5810, 1.6857, 1.8952])
maxC = np.array([0.0029876, 0.0145048, 0.027054, 0.0827306, 0.3099, 0.5028, 0.5938,
                 0.4763, 0.4719, 0.7503, 0.3014, 0.01961, 0.7673, 0.1027, 0.6119])
num_wells = np.array([1,2,1,1,4,4,4,1,2,2,1,4,4,2,3])

# Define stable vs unstable based on maxC or Krep threshold
stable_mask = Krep <= 0.5
unstable_mask = Krep > 0.5

plt.figure(figsize=(10,6))

# Stable points
plt.scatter(Krep[stable_mask], maxC[stable_mask], color='blue', s=80, label='Stable core (low Krep)')
# Unstable points
plt.scatter(Krep[unstable_mask], maxC[unstable_mask], color='red', s=80, label='Unstable core (high Krep)')

# Optional: annotate number of wells
for i in range(len(Krep)):
    plt.text(Krep[i]+0.02, maxC[i], str(num_wells[i]), fontsize=9, verticalalignment='bottom')

plt.xlabel("Repulsion Strength $K_{rep}$", fontsize=14)
plt.ylabel("Maximum Central Curvature (maxC)", fontsize=14)
plt.title("Stability Transition in Central Curvature vs Repulsion Strength", fontsize=16)
plt.grid(True)
plt.legend()
plt.tight_layout()
plt.show()

import numpy as np
import matplotlib.pyplot as plt
import os

# -------------------- Simulation parameters --------------------
N = 128
NP = 2000
DT = 0.05
STEPS = 1000
PRINT_EVERY = 50

# Physics
s_src = 2.5
lam = 0.005
D_C = 0.08
mu = 2.0
v_th = 0.1
r_rep = 3

# -------------------- Helper functions --------------------
def laplacian(F):
    return (np.roll(F,1,0)+np.roll(F,-1,0)+np.roll(F,1,1)+np.roll(F,-1,1)-4*F)

def cic_deposit(xp, yp, mass_per_particle=1.0):
    rho = np.zeros((N,N))
    i0 = np.floor(xp).astype(int) % N
    j0 = np.floor(yp).astype(int) % N
    i1 = (i0+1)%N; j1=(j0+1)%N
    tx = xp - np.floor(xp); ty = yp - np.floor(yp)
    w00=(1-tx)*(1-ty); w10=tx*(1-ty); w01=(1-tx)*ty; w11=tx*ty
    np.add.at(rho, (i0,j0), mass_per_particle*w00)
    np.add.at(rho, (i1,j0), mass_per_particle*w10)
    np.add.at(rho, (i0,j1), mass_per_particle*w01)
    np.add.at(rho, (i1,j1), mass_per_particle*w11)
    return rho

def g

import numpy as np
import matplotlib.pyplot as plt
import os

# -------------------- Simulation parameters --------------------
N = 128
NP = 2000
DT = 0.05
STEPS = 1000
PRINT_EVERY = 50

# Physics
s_src = 2.5
lam = 0.005
D_C = 0.08
mu = 2.0
v_th = 0.1
r_rep = 3

# -------------------- Helper functions --------------------
def laplacian(F):
    return (np.roll(F,1,0)+np.roll(F,-1,0)+np.roll(F,1,1)+np.roll(F,-1,1)-4*F)

def cic_deposit(xp, yp, mass_per_particle=1.0):
    rho = np.zeros((N,N))
    i0 = np.floor(xp).astype(int) % N
    j0 = np.floor(yp).astype(int) % N
    i1 = (i0+1)%N; j1=(j0+1)%N
    tx = xp - np.floor(xp); ty = yp - np.floor(yp)
    w00=(1-tx)*(1-ty); w10=tx*(1-ty); w01=(1-tx)*ty; w11=tx*ty
    np.add.at(rho, (i0,j0), mass_per_particle*w00)
    np.add.at(rho, (i1,j0), mass_per_particle*w10)
    np.add.at(rho, (i0,j1), mass_per_particle*w01)
    np.add.at(rho, (i1,j1), mass_per_particle*w11)
    return rho

def grad_xy(F):
    Fx = (np.roll(F,-1,1)-np.roll(F,1,1))/2.0
    Fy = (np.roll(F,-1,0)-np.roll(F,1,0))/2.0
    return Fx, Fy

def bilinear_sample(F, xp, yp):
    i0 = np.floor(xp).astype(int) % N
    j0 = np.floor(yp).astype(int) % N
    i1 = (i0+1)%N; j1=(j0+1)%N
    tx = xp - np.floor(xp); ty = yp - np.floor(yp)
    f00 = F[i0,j0]; f10 = F[i1,j0]; f01 = F[i0,j1]; f11 = F[i1,j1]
    return (1-tx)*(1-ty)*f00 + tx*(1-ty)*f10 + (1-tx)*ty*f01 + tx*ty*f11

def local_density(xp, yp, r=r_rep):
    Np = len(xp)
    rho_local = np.zeros(Np)
    r2 = r**2
    for i in range(Np):
        dx = (xp - xp[i] + N/2) % N - N/2
        dy = (yp - yp[i] + N/2) % N - N/2
        dist2 = dx**2 + dy**2
        rho_local[i] = np.sum(dist2 <= r2) / (np.pi*r2)
    return rho_local

def repulsion_accel(xp, yp, Krep, r=r_rep):
    rho_local = local_density(xp, yp, r)
    ax = np.zeros_like(xp)
    ay = np.zeros_like(yp)
    r2 = r**2
    for i in range(len(xp)):
        dx = (xp[i] - xp + N/2) % N - N/2
        dy = (yp[i] - yp + N/2) % N - N/2
        dist2 = dx**2 + dy**2
        mask = (dist2 > 0) & (dist2 <= r2)
        ax[i] += Krep * np.sum(dx[mask]/np.sqrt(dist2[mask]) * rho_local[mask])
        ay[i] += Krep * np.sum(dy[mask]/np.sqrt(dist2[mask]) * rho_local[mask])
    return ax, ay

# -------------------- Simulation runner --------------------
def run_simulation(Krep):
    rng = np.random.default_rng(12345)
    cx, cy = N/2, N/2
    sigma = 10
    xp = rng.normal(cx, sigma, size=NP) % N
    yp = rng.normal(cy, sigma, size=NP) % N
    vx = np.zeros(NP)
    vy = np.zeros(NP)
    C = np.zeros((N,N))
    center_density = []

    for step in range(1, STEPS+1):
        rho = cic_deposit(xp, yp)
        C += DT*(s_src*rho - lam*C + D_C*laplacian(C))
        Cx, Cy = grad_xy(C)
        ax_curv = mu * bilinear_sample(Cx, xp, yp)
        ay_curv = mu * bilinear_sample(Cy, xp, yp)
        ax_rep, ay_rep = repulsion_accel(xp, yp, Krep)
        ax_therm = rng.normal(0, v_th, size=NP)
        ay_therm = rng.normal(0, v_th, size=NP)
        vx += (ax_curv + ax_rep + ax_therm)*DT
        vy += (ay_curv + ay_rep + ay_therm)*DT
        xp = (xp + vx*DT) % N
        yp = (yp + vy*DT) % N

        if step % PRINT_EVERY == 0 or step==1:
            dx = (xp - cx + N/2) % N - N/2
            dy = (yp - cy + N/2) % N - N/2
            r2 = dx**2 + dy**2
            center_density.append((step, np.sum(r2 <= 1)))
    return np.array(center_density)

# -------------------- Run representative cases --------------------
Krep_stable = 0.2
Krep_unstable = 1.4

results = {}
results[Krep_stable] = run_simulation(Krep_stable)
results[Krep_unstable] = run_simulation(Krep_unstable)

# -------------

import numpy as np
import matplotlib.pyplot as plt

# Krep, maxC, num_wells
data = np.array([
    [0.01, 0.002987611519, 1],
    [0.1147368421, 0.01450489112, 2],
    [0.2194736842, 0.0270544621, 1],
    [0.3242105263, 0.0827306693, 1],
    [0.4289473684, 0.3099037143, 4],
    [0.5336842105, 0.5028794246, 4],
    [0.6384210526, 0.5938726394, 4],
    [0.8478947368, 0.4763001364, 1],
    [0.9526315789, 0.4719650226, 2],
    [1.162105263, 0.7503789098, 2],
    [1.371578947, 0.3014787289, 1],
    [1.476315789, 0.01961467648, 4],
    [1.581052632, 0.767378772, 4],
    [1.685789474, 0.1027301698, 2],
    [1.895263158, 0.6119791821, 3]
])

Krep = data[:,0]
maxC = data[:,1]
num_wells = data[:,2]

mean_maxC = np.mean(maxC)
median_maxC = np.median(maxC)
std_maxC = np.std(maxC)
min_maxC = np.min(maxC)
max_maxC = np.max(maxC)

print(f"Mean maxC: {mean_maxC:.3f}")
print(f"Median maxC: {median_maxC:.3f}")
print(f"Std maxC: {std_maxC:.3f}")
print(f"Min maxC: {min_maxC:.3f}")
print(f"Max maxC: {max_maxC:.3f}")

import numpy as np
import matplotlib.pyplot as plt
import os

# -------------------- Simulation parameters --------------------
N = 128
NP = 2000
DT = 0.05
STEPS = 1000
PRINT_EVERY = 50

# Physics
s_src = 2.5
lam = 0.005
D_C = 0.08
mu = 2.0
v_th = 0.1
r_rep = 3

# -------------------- Helper functions --------------------
def laplacian(F):
    return (np.roll(F,1,0)+np.roll(F,-1,0)+np.roll(F,1,1)+np.roll(F,-1,1)-4*F)

def cic_deposit(xp, yp, mass_per_particle=1.0):
    rho = np.zeros((N,N))
    i0 = np.floor(xp).astype(int) % N
    j0 = np.floor(yp).astype(int) % N
    i1 = (i0+1)%N; j1=(j0+1)%N
    tx = xp - np.floor(xp); ty = yp - np.floor(yp)
    w00=(1-tx)*(1-ty); w10=tx*(1-ty); w01=(1-tx)*ty; w11=tx*ty
    np.add.at(rho, (i0,j0), mass_per_particle*w00)
    np.add.at(rho, (i1,j0), mass_per_particle*w10)
    np.add.at(rho, (i0,j1), mass_per_particle*w01)
    np.add.at(rho, (i1,j1), mass_per_particle*w11)
    return rho

def grad_xy(F):
    Fx = (np.roll(F,-1,1)-np.roll(F,1,1))/2.0
    Fy = (np.roll(F,-1,0)-np.roll(F,1,0))/2.0
    return Fx, Fy

def bilinear_sample(F, xp, yp):
    i0 = np.floor(xp).astype(int) % N
    j0 = np.floor(yp).astype(int) % N
    i1 = (i0+1)%N; j1=(j0+1)%N
    tx = xp - np.floor(xp); ty = yp - np.floor(yp)
    f00 = F[i0,j0]; f10 = F[i1,j0]; f01 = F[i0,j1]; f11 = F[i1,j1]
    return (1-tx)*(1-ty)*f00 + tx*(1-ty)*f10 + (1-tx)*ty*f01 + tx*ty*f11

def local_density(xp, yp, r=r_rep):
    Np = len(xp)
    rho_local = np.zeros(Np)
    r2 = r**2
    for i in range(Np):
        dx = (xp - xp[i] + N/2) % N - N/2
        dy = (yp - yp[i] + N/2) % N - N/2
        dist2 = dx**2 + dy**2
        rho_local[i] = np.sum(dist2 <= r2) / (np.pi*r2)
    return rho_local

def repulsion_accel(xp, yp, Krep, r=r_rep):
    rho_local = local_density(xp, yp, r)
    ax = np.zeros_like(xp)
    ay = np.zeros_like(yp)
    r2 = r**2
    for i in range(len(xp)):
        dx = (xp[i] - xp + N/2) % N - N/2
        dy = (yp[i] - yp + N/2) % N - N/2
        dist2 = dx**2 + dy**2
        mask = (dist2 > 0) & (dist2 <= r2)
        ax[i] += Krep * np.sum(dx[mask]/np.sqrt(dist2[mask]) * rho_local[mask])
        ay[i] += Krep * np.sum(dy[mask]/np.sqrt(dist2[mask]) * rho_local[mask])
    return ax, ay

# -------------------- Simulation runner --------------------
def run_simulation(Krep):
    rng = np.random.default_rng(12345)
    cx, cy = N/2, N/2
    sigma = 10
    xp = rng.normal(cx, sigma, size=NP) % N
    yp = rng.normal(cy, sigma, size=NP) % N
    vx = np.zeros(NP)
    vy = np.zeros(NP)
    C = np.zeros((N,N))
    center_density = []

    for step in range(1, STEPS+1):
        rho = cic_deposit(xp, yp)
        C += DT*(s_src*rho - lam*C + D_C*laplacian(C))
        Cx, Cy = grad_xy(C)
        ax_curv = mu * bilinear_sample(Cx, xp, yp)
        ay_curv = mu * bilinear_sample(Cy, xp, yp)
        ax_rep, ay_rep = repulsion_accel(xp, yp, Krep)
        ax_therm = rng.normal(0, v_th, size=NP)
        ay_therm = rng.normal(0, v_th, size=NP)
        vx += (ax_curv + ax_rep + ax_therm)*DT
        vy += (ay_curv + ay_rep + ay_therm)*DT
        xp = (xp + vx*DT) % N
        yp = (yp + vy*DT) % N

        if step % PRINT_EVERY == 0 or step==1:
            dx = (xp - cx + N/2) % N - N/2
            dy = (yp - cy + N/2) % N - N/2
            r2 = dx**2 + dy**2
            center_density.append((step, np.sum(r2 <= 1)))
    return np.array(center_density)

# -------------------- Run representative cases --------------------
Krep_stable = 0.2
Krep_unstable = 1.4

results = {}
results[Krep_stable] = run_simulation(Krep_stable)
results[Krep_unstable] = run_simulation(Krep_unstable)

# -------------------- Save results --------------------
save_path = "/content/drive/MyDrive/krep_stable_unstable.npy"
os.makedirs(os.path.dirname(save_path), exist_ok=True)
np.save(save_path, results)
print(f"Results saved to {save_path}")

# -------------------- Plot --------------------
plt.figure(figsize=(10,6))
for K, color, label in zip([Krep_stable,Krep_unstable], ['blue','red'], ['Stable core','Unstable core']):
    steps, density = results[K][:,0], results[K][:,1]
    plt.plot(steps, density, label=f"{label}, Krep={K:.2f}", color=color)
plt.xlabel("Simulation Step")
plt.ylabel("Central Particle Count")
plt.title("Representative Stable vs Unstable Core Dynamics")
plt.legend()
plt.grid(True)
plt.show()

import pandas as pd
import matplotlib.pyplot as plt
import numpy as np
from scipy.interpolate import make_interp_spline

# Example: load your saved CSV from Colab Drive
# Replace with the actual path where you saved it
df = pd.read_csv('/content/drive/MyDrive/krep_results.csv')

# Function to plot with smoothing
def smooth_plot(x, y, ax, label, color):
    # Sort data by x for correct smoothing
    sort_idx = np.argsort(x)
    x_sorted = np.array(x)[sort_idx]
    y_sorted = np.array(y)[sort_idx]

    # Fit spline for smooth curve
    spline = make_interp_spline(x_sorted, y_sorted, k=3)
    x_smooth = np.linspace(x_sorted.min(), x_sorted.max(), 300)
    y_smooth = spline(x_smooth)

    # Scatter points
    ax.scatter(x, y, color=color, alpha=0.6, label=f"{label} data")
    # Smooth curve
    ax.plot(x_smooth, y_smooth, color=color, linewidth=2, label=f"{label} trend")
    ax.set_xlabel("k_rep")
    ax.set_ylabel(label)
    ax.legend()

# Create subplots
fig, axs = plt.subplots(2, 1, figsize=(8, 10))

smooth_plot(df['krep'], df['maxC'], axs[0], "maxC", "blue")
smooth_plot(df['krep'], df['num_wells'], axs[1], "num_wells", "red")

plt.tight_layout()
plt.show()

from google.colab import drive
import os

# Mount Google Drive
drive.mount('/content/drive')

# Path where we expect the file
path = '/content/drive/MyDrive/krep_results.csv'

# Check if it exists
if os.path.exists(path):
    print("✅ File found:", path)
else:
    print("❌ File NOT found at:", path)
    print("\nFiles in MyDrive root:")
    for f in os.listdir('/content/drive/MyDrive'):
        print(" -", f)

from google.colab import drive
import os

# Mount Google Drive
drive.mount('/content/drive')

# Path where we expect the file
path = '/content/drive/MyDrive/krep_results.csv'

# Check if it exists
if os.path.exists(path):
    print("✅ File found:", path)
else:
    print("❌ File NOT found at:", path)
    print("\nFiles in MyDrive root:")
    for f in os.listdir('/content/drive/MyDrive'):
        print(" -", f)

import pandas as pd

path = '/content/drive/MyDrive/krep_maxC_results.csv'
df = pd.read_csv(path)
df.head()

stable_idx = maxC < 0.5
unstable_idx = maxC >= 0.5

plt.figure(figsize=(8,5))
plt.plot(Krep[stable_idx], maxC[stable_idx], 'bo', label='Stable cores')
plt.plot(Krep[unstable_idx], maxC[unstable_idx], 'ro', label='Unstable cores')
plt.xlabel("Krep")
plt.ylabel("maxC (maximum curvature)")
plt.title("Stability Transition with Repulsive Strength")
plt.legend()
plt.grid(True)
plt.show()

plt.figure(figsize=(8,5))
plt.scatter(Krep, num_wells, c=num_wells, cmap='viridis', s=100)
plt.colorbar(label='Number of Wells')
plt.xlabel("Krep")
plt.ylabel("Number of Wells")
plt.title("Core Fragmentation vs Repulsion Strength")
plt.show()