# -*- coding: utf-8 -*-
"""Matrix_simulation.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1AcgyVBflEXPu1RxL3IjtmykyFJXH-5yK
"""

import numpy as np
import matplotlib.pyplot as plt

# -------------------- Grid & Time --------------------
N = 128
NP = 2000          # fixed particle number
DT = 0.05
STEPS = 1000
PRINT_EVERY = 50

# -------------------- Physics --------------------
s_src = 2.5
lam = 0.005
D_C = 0.08
mu = 2.0
v_th = 0.1
r_rep = 3

# -------------------- Helper functions --------------------
def laplacian(F):
    return (np.roll(F,1,0)+np.roll(F,-1,0)+np.roll(F,1,1)+np.roll(F,-1,1)-4*F)

def cic_deposit(xp, yp, mass_per_particle=1.0):
    rho = np.zeros((N,N))
    i0 = np.floor(xp).astype(int) % N
    j0 = np.floor(yp).astype(int) % N
    i1 = (i0+1)%N; j1=(j0+1)%N
    tx = xp - np.floor(xp); ty = yp - np.floor(yp)
    w00=(1-tx)*(1-ty); w10=tx*(1-ty); w01=(1-tx)*ty; w11=tx*ty
    np.add.at(rho, (i0,j0), mass_per_particle*w00)
    np.add.at(rho, (i1,j0), mass_per_particle*w10)
    np.add.at(rho, (i0,j1), mass_per_particle*w01)
    np.add.at(rho, (i1,j1), mass_per_particle*w11)
    return rho

def grad_xy(F):
    Fx = (np.roll(F,-1,1)-np.roll(F,1,1))/2.0
    Fy = (np.roll(F,-1,0)-np.roll(F,1,0))/2.0
    return Fx, Fy

def bilinear_sample(F, xp, yp):
    i0 = np.floor(xp).astype(int) % N
    j0 = np.floor(yp).astype(int) % N
    i1 = (i0+1)%N
    j1 = (j0+1)%N
    tx = xp - np.floor(xp)
    ty = yp - np.floor(yp)
    f00 = F[i0,j0]; f10 = F[i1,j0]; f01 = F[i0,j1]; f11 = F[i1,j1]
    return (1-tx)*(1-ty)*f00 + tx*(1-ty)*f10 + (1-tx)*ty*f01 + tx*ty*f11

def local_density(xp, yp, r=r_rep):
    Np = len(xp)
    rho_local = np.zeros(Np)
    r2 = r**2
    for i in range(Np):
        dx = (xp - xp[i] + N/2) % N - N/2
        dy = (yp - yp[i] + N/2) % N - N/2
        dist2 = dx**2 + dy**2
        rho_local[i] = np.sum(dist2 <= r2) / (np.pi*r2)
    return rho_local

def repulsion_accel(xp, yp, Krep, r=r_rep):
    rho_local = local_density(xp, yp, r)
    ax = np.zeros_like(xp)
    ay = np.zeros_like(yp)
    r2 = r**2
    for i in range(len(xp)):
        dx = (xp[i] - xp + N/2) % N - N/2
        dy = (yp[i] - yp + N/2) % N - N/2
        dist2 = dx**2 + dy**2
        mask = (dist2 > 0) & (dist2 <= r2)
        ax[i] += Krep * np.sum(dx[mask]/np.sqrt(dist2[mask]) * rho_local[mask])
        ay[i] += Krep * np.sum(dy[mask]/np.sqrt(dist2[mask]) * rho_local[mask])
    return ax, ay

# -------------------- Simulation Runner --------------------
def run_simulation(Krep, label):
    rng = np.random.default_rng(12345)
    cx, cy = N/2, N/2
    sigma = 10
    xp = rng.normal(cx, sigma, size=NP) % N
    yp = rng.normal(cy, sigma, size=NP) % N
    vx = np.zeros(NP)
    vy = np.zeros(NP)
    C = np.zeros((N,N))
    center_density = []

    for step in range(1, STEPS+1):
        rho = cic_deposit(xp, yp)
        C += DT*(s_src*rho - lam*C + D_C*laplacian(C))
        Cx, Cy = grad_xy(C)
        ax_curv = mu * bilinear_sample(Cx, xp, yp)
        ay_curv = mu * bilinear_sample(Cy, xp, yp)
        ax_rep, ay_rep = repulsion_accel(xp, yp, Krep)
        ax_therm = rng.normal(0, v_th, size=NP)
        ay_therm = rng.normal(0, v_th, size=NP)
        vx += (ax_curv + ax_rep + ax_therm)*DT
        vy += (ay_curv + ay_rep + ay_therm)*DT
        xp = (xp + vx*DT) % N
        yp = (yp + vy*DT) % N
        if step % PRINT_EVERY == 0 or step==1:
            # central density (radius=1 cell)
            dx = (xp - cx + N/2) % N - N/2
            dy = (yp - cy + N/2) % N - N/2
            r2 = dx**2 + dy**2
            center_density.append((step, np.sum(r2 <= 1)))
    return np.array(center_density)

# -------------------- Repulsion Sweep --------------------
Krep_values = [0.05, 0.1, 0.2, 0.5, 1.0]
results = {}

for Krep in Krep_values:
    print(f"\nRunning simulation with Krep={Krep}...")
    results[Krep] = run_simulation(Krep, label=f"Krep={Krep}")

# -------------------- Plot --------------------
plt.figure(figsize=(10,6))
for Krep in Krep_values:
    steps, density = results[Krep][:,0], results[Krep][:,1]
    plt.plot(steps, density, label=f"Krep={Krep}")
plt.xlabel("Simulation Step")
plt.ylabel("Central Particle Count")
plt.title("Effect of Repulsive Strength on Core Stability")
plt.legend()
plt.grid(True)
plt.show()

# Example: see central particle counts for Krep=0.2
data_02 = results[0.2]  # shape: (number of recorded steps, 2)
print("Step, central count")
for step, count in data_02:
    print(f"{int(step)}, {int(count)}")

import numpy as np
import matplotlib.pyplot as plt
import pandas as pd
import os

# ===== Google Drive setup =====
from google.colab import drive
drive.mount('/content/drive')
save_dir = "/content/drive/My Drive/krep_sweep_results"
os.makedirs(save_dir, exist_ok=True)

# ===== Simulation function placeholder =====
# Replace with your actual simulation call that returns maxC and num_wells
def run_simulation(krep_value):
    # Example: fake results â€” replace with your real simulation logic
    np.random.seed(int(krep_value * 1000))
    num_wells = np.random.randint(0, 5)
    maxC = np.random.random() * krep_value
    return maxC, num_wells

# ===== Sweep parameters =====
krep_values = np.linspace(0.01, 2.0, 20)  # 20 values
results = []

for krep in krep_values:
    maxC, num_wells = run_simulation(krep)
    if num_wells > 0:  # Only keep "real" results
        results.append({"krep": krep, "maxC": maxC, "num_wells": num_wells})

# ===== Save raw data =====
df = pd.DataFrame(results)
df_path = os.path.join(save_dir, "krep_sweep_data.csv")
df.to_csv(df_path, index=False)

# ===== Heatmap =====
if len(df) > 0:
    pivot_df = pd.DataFrame({
        "krep": [r["krep"] for r in results],
        "maxC": [r["maxC"] for r in results]
    })

    fig, ax = plt.subplots(figsize=(10, 6))
    sc = ax.scatter(pivot_df["krep"], pivot_df["maxC"],
                    c=pivot_df["maxC"], cmap="viridis", s=100, edgecolor="k")
    plt.colorbar(sc, label="maxC")
    ax.set_xlabel("krep")
    ax.set_ylabel("maxC")
    ax.set_title("maxC vs. krep (only real results)")
    plt.grid(True)

    heatmap_path = os.path.join(save_dir, "krep_sweep_heatmap.png")
    plt.savefig(heatmap_path, dpi=300)
    plt.show()

print(f"Saved data to {df_path}")
print(f"Saved heatmap to {heatmap_path}")

import numpy as np
import matplotlib.pyplot as plt
import pandas as pd
import os
from google.colab import drive

# === MOUNT DRIVE ===
drive.mount('/content/drive')
save_dir = "/content/drive/MyDrive/krep_test"
os.makedirs(save_dir, exist_ok=True)

# === PARAMETERS ===
krep_values = np.linspace(0.01, 2.0, 20)  # 20 values for faster testing
timesteps = 1000  # shorter run for testing
results = []

# === SIMULATION FUNCTION (example placeholder) ===
def run_simulation(krep):
    # Replace this with your real simulation call
    # This returns maxC after running timesteps
    maxC = np.random.random() * krep  # placeholder: simulate some dependency
    return maxC

# === RUN SIMULATIONS ===
for krep in krep_values:
    maxC = run_simulation(krep)
    if maxC > 0.001:  # Only keep "real" results (adjust threshold as needed)
        results.append((krep, maxC))
    print(f"krep={krep:.3f}, maxC={maxC:.5f}")

# === SAVE RESULTS ===
df = pd.DataFrame(results, columns=["krep", "maxC"])
csv_path = os.path.join(save_dir, "krep_maxC_results.csv")
df.to_csv(csv_path, index=False)

# === HEATMAP ===
plt.figure(figsize=(8, 5))
plt.imshow(df["maxC"].values.reshape(-1, 1),
           cmap="viridis", aspect="auto",
           extent=[0, 1, krep_values.min(), krep_values.max()])
plt.colorbar(label="maxC")
plt.xlabel("Dummy axis")
plt.ylabel("krep")
plt.title("maxC vs krep (test run)")
plt.tight_layout()
plt.savefig(os.path.join(save_dir, "krep_maxC_heatmap.png"), dpi=300)
plt.show()

print(f"Saved results to: {csv_path}")

import numpy as np
import matplotlib.pyplot as plt
import pandas as pd

# --- Your real data ---
krep = np.array([0.010, 0.115, 0.219, 0.324, 0.429, 0.534, 0.638, 0.743,
                 0.848, 0.953, 1.057, 1.162, 1.267, 1.372, 1.476, 1.581,
                 1.686, 1.791, 1.895, 2.000])
maxC = np.array([0.00488, 0.03861, 0.08249, 0.17249, 0.02921, 0.31195,
                 0.15188, 0.11947, 0.12898, 0.12105, 0.34623, 0.80668,
                 0.45475, 1.22258, 0.29804, 0.17487, 0.88935, 1.55356,
                 0.49632, 0.99879])

# --- Save CSV ---
df = pd.DataFrame({"krep": krep, "maxC": maxC})
csv_path = "/content/drive/MyDrive/krep_maxC_results.csv"
df.to_csv(csv_path, index=False)

# --- Line plot ---
plt.figure(figsize=(8,5))
plt.plot(krep, maxC, marker='o', linestyle='-')
plt.xlabel("Krep (repulsion strength)")
plt.ylabel("Max C (central curvature)")
plt.title("Central curvature vs repulsive strength")
plt.grid(True)
plt.tight_layout()
plt.savefig("/content/drive/MyDrive/krep_maxC_lineplot.png", dpi=300)
plt.show()

# --- Optional: Heatmap ---
plt.figure(figsize=(6,5))
plt.imshow(maxC.reshape(-1,1), cmap='viridis', aspect='auto',
           extent=[0,1, krep.min(), krep.max()])
plt.colorbar(label='Max C')
plt.xlabel("Dummy axis")
plt.ylabel("Krep")
plt.title("Heatmap of central curvature vs Krep")
plt.tight_layout()
plt.savefig("/content/drive/MyDrive/krep_maxC_heatmap.png", dpi=300)
plt.show()

import numpy as np
import matplotlib.pyplot as plt

# --- Raw data ---
Krep = np.array([0.010, 0.115, 0.219, 0.324, 0.429, 0.534, 0.638, 0.743, 0.848, 0.953,
                 1.057, 1.162, 1.267, 1.372, 1.476, 1.581, 1.686, 1.791, 1.895, 2.000])
maxC = np.array([0.00488, 0.03861, 0.08249, 0.17249, 0.02921, 0.31195, 0.15188, 0.11947,
                 0.12898, 0.12105, 0.34623, 0.80668, 0.45475, 1.22258, 0.29804, 0.17487,
                 0.88935, 1.55356, 0.49632, 0.99879])

# --- Basic statistics ---
print("Statistics for maxC:")
print(f"Mean: {np.mean(maxC):.4f}")
print(f"Median: {np.median(maxC):.4f}")
print(f"Min: {np

import numpy as np
import matplotlib.pyplot as plt

# --- Raw data ---
Krep = np.array([0.010, 0.115, 0.219, 0.324, 0.429, 0.534, 0.638, 0.743, 0.848, 0.953,
                 1.057, 1.162, 1.267, 1.372, 1.476, 1.581, 1.686, 1.791, 1.895, 2.000])
maxC = np.array([0.00488, 0.03861, 0.08249, 0.17249, 0.02921, 0.31195, 0.15188, 0.11947,
                 0.12898, 0.12105, 0.34623, 0.80668, 0.45475, 1.22258, 0.29804, 0.17487,
                 0.88935, 1.55356, 0.49632, 0.99879])

# --- Basic statistics ---
print("Statistics for maxC:")
print(f"Mean: {np.mean(maxC):.4f}")
print(f"Median: {np.median(maxC):.4f}")
print(f"Min: {np.min(maxC):.4f}")
print(f"Max: {np.max(maxC):.4f}")
print(f"Std: {np.std(maxC):.4f}")

# --- Define stability regions ---
stable_threshold = 0.2  # empirically chosen from your data
stable = maxC <= stable_threshold
unstable = maxC > stable_threshold

print("\nStable Krep values (core remains stable):", Krep[stable])
print("Unstable Krep values (core is highly dynamic):", Krep[unstable])

# --- Plot maxC vs Krep ---
plt.figure(figsize=(10,6))
plt.plot(Krep, maxC, marker='o', linestyle='-', color='blue', label='maxC')
plt.axhline(y=stable_threshold, color='red', linestyle='--', label='Stability threshold')
plt.xlabel("Krep (Repulsion Strength)")
plt.ylabel("maxC (Max Central Curvature / Density)")
plt.title("Analysis of Core Stability vs Repulsive Strength")
plt.legend()
plt.grid(True)
plt.show()

import numpy as np
import matplotlib.pyplot as plt

# --- Raw data ---
Krep = np.array([0.010, 0.115, 0.219, 0.324, 0.429, 0.534, 0.638, 0.743, 0.848, 0.953,
                 1.057, 1.162, 1.267, 1.372, 1.476, 1.581, 1.686, 1.791, 1.895, 2.000])
maxC = np.array([0.00488, 0.03861, 0.08249, 0.17249, 0.02921, 0.31195, 0.15188, 0.11947,
                 0.12898, 0.12105, 0.34623, 0.80668, 0.45475, 1.22258, 0.29804, 0.17487,
                 0.88935, 1.55356, 0.49632, 0.99879])

# --- Basic statistics ---
print("Statistics for maxC:")
print(f"Mean: {np.mean(maxC):.4f}")
print(f"Median: {np.median(maxC):.4f}")
print(f"Min: {np.min(maxC):.4f}")
print(f"Max: {np.max(maxC):.4f}")
print(f"Std: {np.std(maxC):.4f}")

# --- Define stability regions ---
stable_threshold = 0.2  # empirically chosen from your data
stable = maxC <= stable_threshold
unstable = maxC > stable_threshold

print("\nStable Krep values (core remains stable):", Krep[stable])
print("Unstable Krep values (core is highly dynamic):", Krep[unstable])

# --- Plot maxC vs Krep ---
plt.figure(figsize=(10,6))
plt.plot(Krep, maxC, marker='o', linestyle='-', color='blue', label='maxC')
plt.axhline(y=stable_threshold, color='red', linestyle='--', label='Stability threshold')
plt.xlabel("Krep (Repulsion Strength)")
plt.ylabel("maxC (Max Central Curvature / Density)")
plt.title("Analysis of Core Stability vs Repulsive Strength")
plt.legend()
plt.grid(True)
plt.show()

import numpy as np
import matplotlib.pyplot as plt
import os

# -------------------- Grid & Time --------------------
N = 128
NP = 2000
DT = 0.05
STEPS = 1000
PRINT_EVERY = 50

# -------------------- Physics --------------------
s_src = 2.5
lam = 0.005
D_C = 0.08
mu = 2.0
v_th = 0.1
r_rep = 3

# -------------------- Helper functions --------------------
def laplacian(F):
    return (np.roll(F,1,0)+np.roll(F,-1,0)+np.roll(F,1,1)+np.roll(F,-1,1)-4*F)

def cic_deposit(xp, yp, mass_per_particle=1.0):
    rho = np.zeros((N,N))
    i0 = np.floor(xp).astype(int) % N
    j0 = np.floor(yp).astype(int) % N
    i1 = (i0+1)%N; j1=(j0+1)%N
    tx = xp - np.floor(xp); ty = yp - np.floor(yp)
    w00=(1-tx)*(1-ty); w10=tx*(1-ty); w01=(1-tx)*ty; w11=tx*ty
    np.add.at(rho, (i0,j0), mass_per_particle*w00)
    np.add.at(rho, (i1,j0), mass_per_particle*w10)
    np.add.at(rho, (i0,j1), mass_per_particle*w01)
    np.add.at(rho, (i1,j1), mass_per_particle*w11)
    return rho

def grad_xy(F):
    Fx = (np.roll(F,-1,1)-np.roll(F,1,1))/2.0
    Fy = (np.roll(F,-1,0)-np.roll(F,1,0))/2.0
    return Fx, Fy

def bilinear_sample(F, xp, yp):
    i0 = np.floor(xp).astype(int) % N
    j0 = np.floor(yp).astype(int) % N
    i1 = (i0+1)%N
    j1 = (j0+1)%N
    tx = xp - np.floor(xp)
    ty = yp - np.floor(yp)
    f00 = F[i0,j0]; f10 = F[i1,j0]; f01 = F[i0,j1]; f11 = F[i1,j1]
    return (1-tx)*(1-ty)*f00 + tx*(1-ty)*f10 + (1-tx)*ty*f01 + tx*ty*f11

def local_density(xp, yp, r=r_rep):
    Np = len(xp)
    rho_local = np.zeros(Np)
    r2 = r**2
    for i in range(Np):
        dx = (xp - xp[i] + N/2) % N - N/2
        dy = (yp - yp[i] + N/2) % N - N/2
        dist2 = dx**2 + dy**2
        rho_local[i] = np.sum(dist2 <= r2) / (np.pi*r2)
    return rho_local

def repulsion_accel(xp, yp, Krep, r=r_rep):
    rho_local = local_density(xp, yp, r)
    ax = np.zeros_like(xp)
    ay = np.zeros_like(yp)
    r2 = r**2
    for i in range(len(xp)):
        dx = (xp[i] - xp + N/2) % N - N/2
        dy = (yp[i] - yp + N/2) % N - N/2
        dist2 = dx**2 + dy**2
        mask = (dist2 > 0) & (dist2 <= r2)
        ax[i] += Krep * np.sum(dx[mask]/np.sqrt(dist2[mask]) * rho_local[mask])
        ay[i] += Krep * np.sum(dy[mask]/np.sqrt(dist2[mask]) * rho_local[mask])
    return ax, ay

# -------------------- Simulation Runner --------------------
def run_simulation(Krep):
    rng = np.random.default_rng(12345)
    cx, cy = N/2, N/2
    sigma = 10
    xp = rng.normal(cx, sigma, size=NP) % N
    yp = rng.normal(cy, sigma, size=NP) % N
    vx = np.zeros(NP)
    vy = np.zeros(NP)
    C = np.zeros((N,N))
    maxC_list = []

    for step in range(1, STEPS+1):
        rho = cic_deposit(xp, yp)
        C += DT*(s_src*rho - lam*C + D_C*laplacian(C))
        Cx, Cy = grad_xy(C)
        ax_curv = mu * bilinear_sample(Cx, xp, yp)
        ay_curv = mu * bilinear_sample(Cy, xp, yp)
        ax_rep, ay_rep = repulsion_accel(xp, yp, Krep)
        ax_therm = rng.normal(0, v_th, size=NP)
        ay_therm = rng.normal(0, v_th, size=NP)
        vx += (ax_curv + ax_rep + ax_therm)*DT
        vy += (ay_curv + ay_rep + ay_therm)*DT
        xp = (xp + vx*DT) % N
        yp = (yp + vy*DT) % N
        if step % PRINT_EVERY == 0 or step==1:
            maxC_list.append(np.max(C))
    return maxC_list

# -------------------- Krep Sweep --------------------
Krep_values = np.linspace(0.01, 2.0, 20)
all_maxC = []

for Krep in Krep_values:
    print(f"Running Krep={Krep:.3f}...")
    maxC_list = run_simulation(Krep)
    all_maxC.append(maxC_list)

all_maxC = np.array(all_maxC)  # shape: (20, len(maxC_list))

# -------------------- Save raw data --------------------
drive_path = "/content/drive/MyDrive/Krep_maxC_data.npy"
os.makedirs(os.path.dirname(drive_path), exist_ok=True)
np.save(drive_path, all_maxC)
print(f"Raw data saved to {drive_path}")

# -------------------- Plot heatmap --------------------
plt.figure(figsize=(10,6))
plt.imshow(all_maxC, origin='lower', aspect='auto',
           extent=[1, STEPS, Krep_values[0], Krep_values[-1]],
           cmap='viridis')
plt.colorbar(label='maxC (central curvature)')
plt.xlabel('Simulation Step')
plt.ylabel('Krep')
plt.title('Heatmap of maxC vs Krep')
plt.show()

import matplotlib.pyplot as plt
import numpy as np

# Select two representative Krep values
Krep_stable = 0.219   # low, stable core
Krep_unstable = 1.372 # high, unstable cusp

# Extract central density vs step
steps_stable, density_stable = results[Krep_stable][:,0], results[Krep_stable][:,1]
steps_unstable, density_unstable = results[Krep_unstable][:,0], results[Krep_unstable][:,1]

# Plot
plt.figure(figsize=(10,6))
plt.plot(steps_stable, density_stable, color='blue', lw=2, label=f"Stable Krep={Krep_stable}")
plt.plot(steps_unstable, density_unstable, color='red', lw=2, label=f"Unstable Krep={Krep_unstable}")
plt.xlabel("Simulation Step")
plt.ylabel("Central Particle Count")
plt.title("Core Stability as a Function of Repulsion Strength Krep")
plt.legend()
plt.grid(True)

# Optional: annotate stability threshold region
plt.axvline(x=0, color='grey', alpha=0)  # placeholder if needed
plt.tight_layout()
plt.show()

import numpy as np
import pickle

# ---------------- Simulation parameters ----------------
N = 128
STEPS = 1000
DT = 0.05
NP = 2000
v_th = 0.1
PRINT_EVERY = 200

# Physics parameters
s_src = 2.5
lam = 0.005
D_C = 0.08
mu = 2.0
r_rep = 3

# --- Helper functions (as before) ---
def laplacian(F):
    return (np.roll(F,1,0)+np.roll(F,-1,0)+np.roll(F,1,1)+np.roll(F,-1,1)-4*F)

def cic_deposit(xp, yp):
    rh